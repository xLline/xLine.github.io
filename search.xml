<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Git的HTTP协议凭证存储</title>
    <url>/2020/05/22/Redis-credential/</url>
    <content><![CDATA[<p>凭证存储为了解决Git使用HTTP协议访问远程仓库账号密码需要多次输入的问题。</p>
<a id="more"></a>

<p>解决这个问题，我们可以使用<code>git-credential-store</code>和<code>git-credential-cache</code>来管理密码，前者在文件（.gitconfig文件同目录下的.git-credentials中）中用明文存储密码，后者存在内存中。<br>命令如下：</p>
<figure class="highlight m"><table><tbody><tr><td class="code"><pre><span class="line">// 默认<span class="number">15</span>分钟 将账号密码存储在内存</span><br><span class="line">git config --global credential.helper cache</span><br><span class="line">// 设置一个小时内记住密码</span><br><span class="line">git config credential.helper <span class="string">'cache --timeout=3600'</span></span><br><span class="line">// 密码存储到磁盘</span><br><span class="line">git config --global credential.helper store</span><br><span class="line">// 删除credential配置</span><br><span class="line">git config --system --unset credential.helper</span><br></pre></td></tr></tbody></table></figure>

<p>也可以依赖第三方：<br>Mac系统，Git默认提供<code>osxkeychain</code>辅助程序来管理你的密码，使用命令<code>git config --global credential.helper osxkeychain</code>实现。<br>Windows系统，安装<code>git-credential-winstore</code>全称是Windows Credential Store for Git，可以将https方式的Git登陆用户名和密码保存在Windows自带的凭据管理系统中，比credential.helper方式更加安全。<br>安装方式：<br>1、下载后解压文件后复制git-credential-winstore.exe 文件到git安装目录的bin目录里面<br>2、将 Git 添加到环境变量。打开环境变量（计算机右键 - &gt; 高级系统设置 -&gt; 环境变量 -&gt; 在系统变量里面找到path双击 ）<br>3、将 Git 安装目录bin文件夹目录添加到步骤2打开的path的最后面，前面添加一个分号。<br>4、双击 bin 目录下的 git-credential-winstore.exe 文件，有个浮层，一般点击是按钮。<br>5、重启 git bash ，会有一个浮层让你输入用户名和密码。</p>
<p>如果安装的是GitGUI，则提供的是<code>git-credential-manager</code>。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>credential</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis集群配置</title>
    <url>/2020/05/16/Redis-config/</url>
    <content><![CDATA[<p>本文是在本地环境学习配置Redis集群的流程文。使用Redis版本为5.0.8，基于VMware中的centOS7系统。</p>
<a id="more"></a>

<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>选择自己喜欢需要的版本，根据<a href="https://redis.io/download" target="_blank" rel="noopener">Redis官方文档</a>引导执行安装编译。</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">mkdir redis-cluster</span><br><span class="line"><span class="built_in">cd</span> redis-cluster <span class="comment"># 该文件我用来存放redis源码</span></span><br><span class="line">wget http://download.redis.io/releases/redis-5.0.8.tar.gz</span><br><span class="line">tar xzf redis-5.0.8.tar.gz</span><br><span class="line"><span class="built_in">cd</span> redis-5.0.8</span><br><span class="line">make</span><br></pre></td></tr></tbody></table></figure>
<p>执行完成。为了方便操作，我将在src目录下生成的可执行文件拷贝到/usr/local/redis目录下。执行命令如下</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span></span><br><span class="line">sudo mkdir redis </span><br><span class="line">sudo chown -R xugz:xugz redis</span><br><span class="line"><span class="built_in">cd</span> redis</span><br><span class="line">mkdir bin conf</span><br><span class="line"><span class="built_in">cd</span> bin</span><br><span class="line">cp ~/redis-cluster/redis-5.0.8/src/redis-* .</span><br><span class="line"><span class="built_in">cd</span> ../conf <span class="comment"># 进入conf文件夹，将源码中的redis配置文件拷贝过来，重命名为6380.conf（我虚拟机上6379端口已被占用）</span></span><br><span class="line">cp ~/redis-cluster/redis-5.0.8/redis.conf 6380.conf</span><br></pre></td></tr></tbody></table></figure>

<h1 id="配置最简单的主从"><a href="#配置最简单的主从" class="headerlink" title="配置最简单的主从"></a>配置最简单的主从</h1><p>为了方便我在同一台机器上启动两个实例实现。</p>
<h2 id="启动master"><a href="#启动master" class="headerlink" title="启动master"></a>启动master</h2><p>修改配置文件必要选项，如将<code>port</code>修改为未被占用的端口如6380。将 <code>daemonize</code>改为 <code>yes</code>，后台程序方式运行。修改pidfile，让其生成到有权限的目录下<code>pidfile /usr/local/redis/redis_6380.pid</code><br>指定6380.conf为其配置文件，启动实例 <code>/usr/local/redis/bin/redis-server /usr/local/redis/conf/6380.conf</code>。</p>
<h2 id="启动slave"><a href="#启动slave" class="headerlink" title="启动slave"></a>启动slave</h2><p>复制一份redis配置文件命名为6381.conf，修改对应的端口和pidfile配置。加入 <code>slaveof 127.0.0.1 6380</code>，意思是将自己作为127.0.0.1主机6380端口的备服。<br>启动实例 <code>/usr/local/redis/bin/redis-server /usr/local/redis/conf/6381.conf</code>。</p>
<p>使用<code>ps -ef | grep redis</code>检查两个进程是否正常存在。<br>使用<code>./redis-cli -h 127.0.0.1 -p 6380</code>命令指定端口和服务器进入客户端，使用<code>info</code>命令查看Replication选项确定是否配置成功，使用<code>role</code>也可。</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master <span class="comment"># 角色，master代表是主机</span></span><br><span class="line">connected_slaves:1 <span class="comment"># 连接的从机的数量 我们这里只配置了6381一个</span></span><br><span class="line">slave0:ip=127.0.0.1,port=6381,state=online,offset=280,lag=0</span><br></pre></td></tr></tbody></table></figure>
<p>下图为验证主备功能的。图片显示6380主服务器可读可写，6381备服只有读取权限。</p>
<img src="/2020/05/16/Redis-config/slave_readonly.png" class="" title="主备功能数据获取验证"> 

<h1 id="使用哨兵模式实现主从切换"><a href="#使用哨兵模式实现主从切换" class="headerlink" title="使用哨兵模式实现主从切换"></a>使用哨兵模式实现主从切换</h1><p><a href="http://www.redis.cn/topics/sentinel.html" target="_blank" rel="noopener">参考Redis中文文档中对哨兵的描述</a></p>
<blockquote>
<p>Redis的Sentinel系统用于管理多个Redis服务器（instance），该系统执行以下三个任务:</p>
<ol>
<li>监控（Monitoring）：Sentinel会不断地检查你的主服务器和从服务器是否运作正常。</li>
<li>提醒（Notification）：当被监控的某个Redis服务器出现问题时，Sentinel可以通过API向管理员或者其他应用程序发送通知。</li>
<li>自动故障迁移（Automatic failover）：当一个主服务器不能正常工作时，Sentinel会开始一次自动故障迁移操作，它会将失效主服务器的其中一个从服务器升级为新的主服务器， 让失效主服务器的其他从服务器改为复制新的主服务器；当客户端试图连接失效的主服务器时，集群也会向客户端返回新主服务器的地址，使得集群可以使用新主服务器代替失效服务器。</li>
</ol>
</blockquote>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>Redis 源码中包含了一个名为 sentinel.conf 的文件， 这个文件是一个带有详细注释的 Sentinel 配置文件示例。<br>运行一个 Sentinel 所需的配置如下所示：</p>
<figure class="highlight php"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 端口</span></span><br><span class="line">port <span class="number">6380</span>  </span><br><span class="line"><span class="comment">// 工作目录</span></span><br><span class="line">dir /usr/local/redis/tmp</span><br><span class="line"><span class="comment">// 指定的要检测的实例。参数分别是 别名 ip 端口 server异常时需要确认异常的哨兵个数。1表示至少1个setinel实例同时检测到redis server异常时才将redis server的状态判决为"宕机"</span></span><br><span class="line">sentinel monitor mymaster <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">6380</span> <span class="number">1</span> </span><br><span class="line"><span class="comment">// 指定某个sentinel实例监控到某个redis实例持续异常多长时间后，会判决其状态为down。单位毫秒</span></span><br><span class="line">sentinel down-after-milliseconds mymaster <span class="number">60000</span> </span><br><span class="line"><span class="comment">// 若sentinel在该配置值内未能完成failover操作（即故障时master/slave自动切换），则认为本次failover失败</span></span><br><span class="line">sentinel failover-timeout mymaster <span class="number">180000</span> </span><br><span class="line"><span class="comment">// 指定failover过程中，同时被sentinel reconfigure的最大slave实例数。由于reconfigure过程中，对应的slave会中断响应客户端请求，故为避免所有的slave同时不可用，该值需适当配小。</span></span><br><span class="line">sentinel parallel-syncs mymaster <span class="number">1</span></span><br><span class="line"><span class="comment">// know-salve 代表已知的从机</span></span><br><span class="line">sentinel known-slave mymaster <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">6381</span> </span><br><span class="line"><span class="comment">// 同时一时间最多3个slave可同时更新配置</span></span><br><span class="line">sentinel leader-epoch mymaster <span class="number">3</span></span><br></pre></td></tr></tbody></table></figure>
<p>将Redis源码中的 sentinel.conf 的文件拷贝到/usr/local/redis/conf目录下，修改自身需要的配置选项。</p>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>对于 redis-sentinel 程序，可以用<code>./redis-sentinel /path/to/sentinel.conf</code>命令来启动 Sentinel 系统。或者使用<code>nohup /usr/local/redis/bin/redis-sentinel /usr/local/redis/conf/sentinel.conf  &amp;</code>不挂断地运行命令。<br>对于 redis-server 程序，可以用<code>./redis-server /path/to/sentinel.conf --sentinel</code>命令来启动一个运行在 Sentinel 模式下的 Redis 服务器。<br>启动完成后我进行了数据验证，下图是验证用到的相关命令（注意redis服务的切换）</p>
<img src="/2020/05/16/Redis-config/sentinel_look.png" class="" title="验证哨兵功能"> 
<p>通过上图的验证我们发现：本来主机是6380可以读写，从服务器是6381只可读。手动杀掉主服务器的运行进程，等待最大持续异常时间（down-after-milliseconds）后，哨兵会将主服务器自动切换成6381，将6380作为6381的备服。即使我们后续将6380再次启动，6380仍是6381的备服，数据只读。这在哨兵的服务进程中也有体现，见下图</p>
<img src="/2020/05/16/Redis-config/sentinel_work.png" class=""> 

<h1 id="主从从配置"><a href="#主从从配置" class="headerlink" title="主从从配置"></a>主从从配置</h1><p>如果让所有的slave节点数据的复制和同步都由master节点来处理，会造成master节点I/O压力过大。所以我们打算将6380作为主服务器，用于写入操作，6381和6382作为备服负责读操作。为了减轻master压力，让6382数据备份来源改成6381，实现主从从模式。</p>
<h2 id="配置修改"><a href="#配置修改" class="headerlink" title="配置修改"></a>配置修改</h2><h3 id="redis-conf"><a href="#redis-conf" class="headerlink" title="redis.conf"></a>redis.conf</h3><p>确认以下参数：port、pidfile、daemonize、dbfilename和dir。<br>将slaveof选项添加到备服。将6382数据备份来源改成6381，6381的数据备份来源还是6380。6382的部分配置如下</p>
<figure class="highlight php"><table><tbody><tr><td class="code"><pre><span class="line">bind <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">port <span class="number">6382</span></span><br><span class="line">daemonize yes</span><br><span class="line">pidfile <span class="string">"/usr/local/redis/redis_6382.pid"</span></span><br><span class="line">slaveof <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">6381</span></span><br><span class="line">dbfilename <span class="string">"dump6382.rdb"</span></span><br><span class="line">dir <span class="string">"/usr/local/redis/datadir/"</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="Sentinel-conf"><a href="#Sentinel-conf" class="headerlink" title="Sentinel.conf"></a>Sentinel.conf</h3><p>哨兵启动后其实自动修改配置文件，一般建议不要手工修改。<br>如果之前配的是一主多从，配置中会存在sentinel known-slave选项。如果我们要配置主从从，要把多余的从在配置文件手工删掉。</p>
<h2 id="便捷操作"><a href="#便捷操作" class="headerlink" title="便捷操作"></a>便捷操作</h2><p>为了操作方便，将多台服务启动命令整合到可执行脚本。</p>
<h3 id="server-start"><a href="#server-start" class="headerlink" title="server_start"></a>server_start</h3><p>该脚本是为了方便启动redis server。在~/redis-cluster目录下新增文件server_start，同时启动三台redis实例和哨兵后台运行。脚本内容如下</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">/usr/local/redis/bin/redis-server /usr/local/redis/conf/6380.conf</span><br><span class="line">/usr/local/redis/bin/redis-server /usr/local/redis/conf/6381.conf</span><br><span class="line">/usr/local/redis/bin/redis-server /usr/local/redis/conf/6382.conf</span><br><span class="line">nohup /usr/local/redis/bin/redis-sentinel /usr/local/redis/conf/sentinel.conf  &amp;</span><br></pre></td></tr></tbody></table></figure>

<h3 id="cli-start"><a href="#cli-start" class="headerlink" title="cli_start"></a>cli_start</h3><p>该脚本是为了方便启动redis server。在~/redis-cluster目录下新增文件cli_start，可支持传入端口参数。脚本内容如下</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$1</span>"</span> ]   <span class="comment">#-n 传入参数不为空 $1代表第二参数，$0是可执行文件名自己本身</span></span><br><span class="line">  <span class="keyword">then</span></span><br><span class="line">  /usr/<span class="built_in">local</span>/redis/bin/redis-cli -h 127.0.0.1 -p <span class="variable">$1</span></span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> <span class="built_in">echo</span> <span class="string">"error,no port"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></tbody></table></figure>
<p>将redis server启动后，使用<code>./cli-start port</code>命令进入客户端，各自键入info命令尝试插入获取数据验证发现：6380为master，可读可写。其有一个从服为6381，6381角色为slave，他也有一个从服为6382。6381和6382都只可读。</p>
<h1 id="cluster集群"><a href="#cluster集群" class="headerlink" title="cluster集群"></a>cluster集群</h1><p><a href="http://www.redis.cn/topics/cluster-tutorial.html" target="_blank" rel="noopener">参考Redis中文文档中对集群的描述</a></p>
<h2 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h2><p>搭建集群的第一件事情我们需要一些运行在 集群模式的Redis实例. 这意味这集群并不是由一些普通的Redis实例组成的，集群模式需要通过配置启用，开启集群模式后的Redis实例便可以使用集群特有的命令和特性了.</p>
<p>下面是一个最少选项的集群的配置文件:</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">port 7000</span><br><span class="line">pidfile <span class="string">"/usr/local/redis/redis_7000.pid"</span></span><br><span class="line"><span class="comment"># 表示打开集群 </span></span><br><span class="line">cluster-enabled yes </span><br><span class="line">cluster-node-timeout 5000</span><br><span class="line"><span class="comment"># 开启AOF存储模式</span></span><br><span class="line">appendonly yes </span><br><span class="line"><span class="comment">#集群模式下,每个redis节点生成一个配置文件，由redis自己维护。文件名区分开即可  下面两个文件名如果不像我一样放在同目录的话，可以不修改</span></span><br><span class="line">cluster-config-file nodes_7000.conf</span><br><span class="line">appendfilename <span class="string">"appendonly_7000.aof"</span></span><br><span class="line"><span class="comment"># 注释掉dbfilename 关闭RDB改用AOF</span></span><br><span class="line"><span class="comment"># dbfilename </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关掉RDB存储</span></span><br><span class="line">save　<span class="string">""</span></span><br><span class="line"><span class="comment">#save 900 1</span></span><br><span class="line"><span class="comment">#save 300 10</span></span><br><span class="line"><span class="comment">#save 60 1000</span></span><br></pre></td></tr></tbody></table></figure>
<p>要让集群正常运作至少需要三个主节点，不过在刚开始试用集群功能时， 官方强烈建议使用六个节点： 其中三个为主节点， 而其余三个则是各个主节点的从节点。所以我们创建进入一个新目录cluster_conf，并创建六个以端口号为名字的Redis.conf文件，文件的内容可以使用上面的示例配置文件，稍后我们将运行六个Redis实例。</p>
<h2 id="安装Ruby"><a href="#安装Ruby" class="headerlink" title="安装Ruby"></a>安装Ruby</h2><p>低版本的redis需要安装ruby环境，现在高版本的redis-cli已经支持集群了，不再需要安装ruby了。</p>
<p>切换到root账号，执行默认安装。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">su - root </span><br><span class="line">yum -y install ruby ruby-devel rubygems rpm-build</span><br><span class="line">gem install redis</span><br></pre></td></tr></tbody></table></figure>
<p>或者编译安装。<a href="http://www.ruby-lang.org/en/downloads/" target="_blank" rel="noopener">官方下载地址</a><br> <code>wget https://cache.ruby-lang.org/pub/ruby/2.4/ruby-2.7.1.tar.gz --no-check-certificate</code></p>
<h2 id="搭建集群"><a href="#搭建集群" class="headerlink" title="搭建集群"></a>搭建集群</h2><p>首先启动六个实例，我们可以使用<code>/usr/local/redis/bin/redis-server /usr/local/redis/cluster_conf/7000.conf</code>命令一条条启动，也可以封装到可执行脚本中。<br>启动完成 <code>ps -ef | grep redis</code> 查看如下</p>
<img src="/2020/05/16/Redis-config/cluster_start.png" class=""> 
<p>现在我们已经有了六个正在运行中的 Redis 实例， 接下来我们需要使用这些实例来创建集群， 并为每个节点编写配置文件。<br>通过使用 Redis 集群命令行工具 redis-trib ，编写节点配置文件的工作可以非常容易地完成：redis-trib 位于 Redis 源码的 src 文件夹中，它是一个 Ruby 程序，这个程序通过向实例发送特殊命令来完成创建新集群，检查集群，或者对集群进行重新分片（reshared）等工作。</p>
<p>创建一个新的集群, 选项–replicas 1 表示我们希望为集群中的每个主节点创建一个从节点。下面命令默认创建7000 7001 7002 为主节点，7003 7004 7005为备节点。<br>低版本使用：<code>./redis-trib.rb create --replicas 1 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005</code><br>Redis5.0后不再支持上条命令，需要使用redis-cli来实现。如下<br><code>./redis-cli --cluster create 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 --cluster-replicas 1</code><br>之后跟着的其他参数则是这个集群实例的地址列表,3个master3个slave redis-trib 会打印出一份预想中的配置给你看，如果你觉得没问题的话，就可以输入yes，redis-trib 就会将这份配置应用到集群当中,让各个节点开始互相通讯,最后可以得到如下信息：</p>
<blockquote>
<p>[OK] All nodes agree about slots configuration.<br>[OK] All 16384 slots covered.</p>
</blockquote>
<p>这表示集群中的 16384 个槽都有至少一个主节点在处理， 集群运作正常。此时，我们可以使用<code>redis-cli -c -p 7000</code>命令连接到7000端口的客户端，也可以通过脚本进入。相关验证如下图</p>
<img src="/2020/05/16/Redis-config/cluster_sess.png" class=""> 

<p><span style="font-size: 13px; color: #777;">官方提供了一个自动化脚本,在 redis源码目录的utils文件夹，下面有个create-cluster文件夹，下面有个create-cluster脚本。也可以根据里面的代码进行脚本执行搭建。</span></p>
<h1 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h1><h2 id="ERR-Slot-xxxxx-is-already-busy-Redis-CommandError"><a href="#ERR-Slot-xxxxx-is-already-busy-Redis-CommandError" class="headerlink" title="ERR Slot xxxxx is already busy (Redis::CommandError)"></a>ERR Slot xxxxx is already busy (Redis::CommandError)</h2><p>如果上一次运行出错，则必须去datadir对应目录去手工删除自动生成的cluster配置文件。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>cluster</tag>
        <tag>sentinel</tag>
      </tags>
  </entry>
  <entry>
    <title>Git常用命令整理</title>
    <url>/2020/03/11/Git-base/</url>
    <content><![CDATA[<p>整理 Git 中常见、常用命令提供快速翻阅。</p>
<a id="more"></a>

<p>使用 <code>git --version</code> 查看当前版本。</p>
<h1 id="Git-配置"><a href="#Git-配置" class="headerlink" title="Git 配置"></a>Git 配置</h1><p><code>git config --list</code> 命令用来列出所有 Git 当时能找到的配置。<br>通过输入 <code>git config &lt;key&gt;</code> 来检查 Git 的某一项配置。</p>
<p>设置你的用户名和邮件地址</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">git config --global user.name "xugz"</span><br><span class="line">git config --global user.email "xugz_@outlook.com"</span><br></pre></td></tr></tbody></table></figure>
<p><code>git config --global alias.last 'log -1 HEAD'</code> 创建别名。此时我们可以用 <code>git last</code> 命令代替 <code>git log -1 HEAD</code> 来查看最后一次提交。<br><code>git config --global core.autocrlf false</code> 设置是否自动转化行结束符。</p>
<blockquote>
</blockquote>
<div style="font-size: 13px; margin-left: 0.5em; color: #777;  margin-top: -10px">
windows下和linux下的文本文件的换行符不一致。<br>
windows：两个字符，CR+LF，即一个回车，一个换行 <br>
linux及OS X：一个字符，LF，在Linux下查看文件会在行末多个^M。<br>
在windows下，git安装时，默认该选项为true，从仓库下载下来，结尾会改为CRLF格式。当提交文件到仓库时，会将CRLF格式转为LF。这样可以保证仓库中的文件是LF结尾的。<br>
<span style="color: #555">windows下开发将编辑器默认设置为LF格式（如VSCode，在settings中设置file:eol 选项为\n），core.autocrlf 该项设置为false最好。</span>
</div><br>

<h1 id="获取-Git-仓库"><a href="#获取-Git-仓库" class="headerlink" title="获取 Git 仓库"></a>获取 Git 仓库</h1><p>通常有两种获取 Git 项目仓库的方式：</p>
<ol>
<li>将尚未进行版本控制的本地目录转换为 Git 仓库；</li>
<li>从其它服务器 克隆 一个已存在的 Git 仓库  </li>
</ol>
<p>使用 <code>git init</code> 在已存在的本地目录中初始化仓库。  </p>
<p><code>git clone &lt;url&gt; [rename_dir_name]</code> 命令将指定仓库克隆下来，默认配置下远程 Git 仓库中的每一个文件的每一个版本都将被拉取下来。<br>这会在当前目录下创建 和你指定URL对应仓库名同名 的目录，并在这个目录下初始化一个 <code>.git</code> 文件夹， 从远程仓库拉取下所有数据放入 <code>.git</code> 文件夹，然后从中读取最新版本的文件的拷贝。如果你想在克隆远程仓库的时候，自定义本地仓库的名字，你可以通过额外的参数指定新的目录名。  </p>
<h1 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h1><p><code>git branch</code> 会列出你在本地的分支。<br><code>git branch &lt;branch_name&gt;</code> 使用该命令创建新分支。<br><code>git branch -d &lt;branch_name&gt;</code> 删除指定分支。<br><code>git branch -v</code> 查看每一个分支的最后一次提交。<br><code>git branch --merged</code> 查看哪些分支已经合并到当前分支， <code>git branch --no-merged</code> 查看尚未合并到当前分支的分支。  </p>
<p><code>git checkout &lt;branch_name&gt;</code>切换分支。<br><code>git checkout -b &lt;branch_name&gt;</code> 创建新分支并切换。  </p>
<p><code>git stash</code> 命令用来临时地保存一些还没有提交的工作，以便在分支上不需要提交未完成工作就可以清理工作目录。<br><code>git stash list</code> 用以查看贮藏的内容。<br><code>git stash apply [stash_name]</code> 应用指定贮藏版本，不指定的话默认最新的贮藏。<br><code>git stash drop [stash_name]</code> 删除指定贮藏版本。<code>git stash clean</code> 清空所有贮藏版本。</p>
<p><code>git merge &lt;branch_name&gt;</code> 将指定分支合并到你的当前分支。</p>
<h1 id="查看变更"><a href="#查看变更" class="headerlink" title="查看变更"></a>查看变更</h1><p>用 <code>git status</code> 命令查看文件状态。<br><code>-s</code> 选项可以以简洁的方式查看更改。<span style="font-size: 13px; margin-left: 0.5em; color: #777;  margin-top: -10px">新添加的未跟踪文件前面有 ?? 标记，新添加到暂存区中的文件前面有 A 标记，修改过的文件前面有 M 标记。 </span>   </p>
<p><code>git diff</code> 能通过文件补丁的格式具体地显示尚未缓存文件的变更对比。<br><code>git diff --staged</code> 或 <code>git diff --cached</code> 命令查看已暂存的将要添加到下次提交里的内容，这条命令将比对已暂存文件与最后一次提交的文件差异。<br><code>git diff HEAD</code> 查看已缓存文件的与未缓存文件的所有改动。<br><code>git diff --stat</code> 显示变动摘要。    </p>
<p>用 <code>git log</code> 用 <code>--oneline</code> 选项来查看历史记录的紧凑简洁的版本。<br>使用 <code>git log --oneline --graph</code> 选项，开启了拓扑图查看历史中什么时候出现了分支、合并。  </p>
<h1 id="提交变更"><a href="#提交变更" class="headerlink" title="提交变更"></a>提交变更</h1><p>用 <code>git add &lt;filename/.&gt;</code> 命令添加需要追踪的新文件和待提交的更改。  </p>
<p><code>git checkout &lt;filename&gt;/.</code> 撤销对指定文件/所有变更的修改。   </p>
<p><code>git commit</code> 提交更新。<br><code>-m</code> 用于备注提交说明。<br> <code>-a</code> 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 <code>git add</code> 步骤。<br><code>--amend</code> 选项用来重新提交。例如，你提交后发现忘记了暂存某些需要的修改，可以像下面这样操作。从效果上来说，就像是旧的提交从未存在过一样，它并不会出现在仓库的历史中。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">git commit -m 'initial commit'</span><br><span class="line">git add forgotten_file</span><br><span class="line">git commit --amend</span><br></pre></td></tr></tbody></table></figure>
<p>用 <code>git rm &lt;filename&gt;</code> 从暂存区域移除指定文件。  </p>
<p><code>git reset HEAD/&lt;filename&gt;</code>  取消缓存已缓存的全部内容/指定文件。  </p>
<p><code>git mv file_from file_to</code> 移动/重命名已跟踪的文件。</p>
<h1 id="远程仓库的使用"><a href="#远程仓库的使用" class="headerlink" title="远程仓库的使用"></a>远程仓库的使用</h1><p><code>git remote -v</code> 命令查看已经配置的远程仓库服务器名字及对应URL。<br><code>git remote add &lt;shortname&gt; &lt;url&gt;</code> 添加一个新的远程 Git 仓库，同时指定一个方便使用的简写。  </p>
<p><code>git fetch &lt;remote&gt;</code> 从远端仓库获取新分支与数据。</p>
<p><code>git pull</code> 从远端仓库提取数据并尝试合并到当前分支。</p>
<p><code>git push [alias] [branch]</code> 推送你的新分支与数据到某个远端仓库。<br><code>git push origin --delete &lt;branch_name&gt;</code> 删除指定的远端分支</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>基于win+PHPStorm+Linux的推荐开发环境配置</title>
    <url>/2019/12/06/DevelopTool-phpstorm/</url>
    <content><![CDATA[<p>想要在Windows开发可偏偏有拓展包依赖于Linux？也不想使用samba进行网络映射挂载虚拟盘？那这里还有一个方法，使用PHPstorm配置下下就可以。<br>当前我的环境在Vmware，基于centos7使用Docker搭建的。具体步骤见详情。</p>
<a id="more"></a>

<p><strong>虚拟机部分</strong><br>使用非Root账户创建一个空文件夹<br>设置SSH权限和密码，确保本地可以正常连接到虚拟机。不清楚的话可以参考<a href="https://xlline.github.io/2019/10/31/SSH%E7%A7%98%E9%92%A5%E6%93%8D%E4%BD%9C/">点我，我是猴子派来的救兵</a><br>确保当前容器已经正常启动且已实现代码映射到虚拟机<br><strong>主机部分</strong><br>本地我们要新建一个空目录（存放我们即将要同步的代码），使用PHPstorm打开，此时是一个空项目。PHP storm会在我们新建的目录里生成 .idea 文件夹。<br>File-&gt;Settings-&gt;Build,Execution,Deployment中点击Deployment。选择”+”中的SFTP创建新连接，键入你喜欢的连接名。<br>在Connection中填写基础连接配置</p>
<div style="width: 71%;margin: left"><img src="/2019/12/06/DevelopTool-phpstorm/setting_1.png" class=""></div>

<p>在Mappings中填写本地路径和目标路径</p>
<div style="width: 71%;margin: left"><img src="/2019/12/06/DevelopTool-phpstorm/setting_2.png" class=""></div>

<p>在Excluded Paths中填写我们要忽略排除的文件路径</p>
<div style="width: 71%;margin: left"><img src="/2019/12/06/DevelopTool-phpstorm/setting_3.png" class=""></div>

<p>配置完成点击应用就可以啦。在Tools-&gt;Deployment下选择Upload to swoole(这里的swoole是你创建的连接名，我本地是swoole)手动上传到远端，选择Automatic Upload(always)自动上传。</p>
<div style="width: 61%;margin: left"><img src="/2019/12/06/DevelopTool-phpstorm/setting_4.png" class=""></div>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>IDE</tag>
        <tag>PHPStorm</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker配置Samba文件共享服务</title>
    <url>/2019/12/03/Docker-samba/</url>
    <content><![CDATA[<p>在windows网络环境中，主机之间进行文件和打印机共享是通过微软公司自己的SMB/CIFS网络协议实现的。SMB（Server Message Block，服务消息块）和CIFS（Common Internet File System，通用互联网文件系统）协议是微软的私有协议，在Samba项目出现之前，并不能直接与Linux/UNIX系统进行通信。<br>Samba是著名的开源软件项目之一，它在Linux/UNIX系统中实现了微软的SMB/CIFS网络协议，从而使得跨平台的文件共享变得更加容易。在部署Windows、Linux/UNIX混合平台的企业环境时，选用Samba可以很好地解决不同系统之间的文件互访问题。</p>
<a id="more"></a>
<p>选择高下载量的镜像拉取 <code>docker pull dperson/samba</code><br>关闭必要端口防火墙，执行下面命令</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">sudo iptables -I INPUT -p tcp --dport 139 -j ACCEPT</span><br><span class="line">sudo iptables -I INPUT -p tcp --dport 445 -j ACCEPT</span><br><span class="line"></span><br><span class="line">sudo iptables -I INPUT -p udp --dport 137 -j ACCEPT</span><br><span class="line">sudo iptables -I INPUT -p udp --dport 138 -j ACCEPT</span><br></pre></td></tr></tbody></table></figure>
<p>运行执行以下命令后，在window本机使用window+R调出运行窗口，输入 linux主机的IP回车，比如 <code>\\192.168.2.156</code>即可看到分享的xugz_tp5文件目录。选中目录右键选择映射网络驱动器选择喜欢的盘，即可在计算机中找到。如此可实现先共享文件夹到本地盘。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">docker run -it -p 139:139 -p 445:445  --name smb -d --rm  \</span><br><span class="line"> -v /home/xugz/tp5/web:/mount \</span><br><span class="line"> dperson/samba \</span><br><span class="line"> -u "xugz;123" \</span><br><span class="line"> -s "xugz_tp5;/mount/;yes;no;yes;all;all;all" \</span><br><span class="line"> -w "WORKGROUP" \</span><br><span class="line"> -g "force user= xugz" \</span><br><span class="line"> -g "guest account= xugz"</span><br></pre></td></tr></tbody></table></figure>
<p>Samba在<a href="https://hub.docker.com/r/dperson/samba" target="_blank" rel="noopener">docker镜像地址</a>中介绍了很多参数选项，简单记录上条命令用到的</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">-u "&lt;username;password&gt;[;ID;group;GID]"  </span><br><span class="line">   设置用户及密码</span><br><span class="line">-s "&lt;name;/path&gt;[;browse;readonly;guest;users;admins;writelist;comment]"</span><br><span class="line">    配置一个共享。其中&lt;name;/path&gt;为必须参数</span><br><span class="line">    &lt;name&gt; 分享名称</span><br><span class="line">    &lt;path&gt; 要分享的路径</span><br><span class="line">    [browsable] 是否可浏览 参数值为:'yes' or 'no'</span><br><span class="line">    [readonly] 是否只读 参数值为:'yes' or 'no'</span><br><span class="line">    [guest] 游客模式 参数值为:'yes' or 'no'</span><br><span class="line">    [users] 用户列表 参数值为:'all' or 允许的用户秒表，多用户使用','分割</span><br><span class="line">    [admins] 系统用户 参数值为:'none' or 系统用户列表</span><br><span class="line">    [writelist] 可以写入RO共享的用户列表</span><br><span class="line">    [comment] 分享描述</span><br><span class="line">-w "&lt;workgroup&gt;" 配置要使用的工作组 比如要和windows共享，这里的工作组路径在 控制面板&gt;系统和安全&gt;系统&gt;工作组设置里面。（此电脑右键选择管理以快速打开）</span><br><span class="line">-g "&lt;parameter&gt;" 配置全局变量 相当于修改配置文件 smb.conf</span><br><span class="line">    格式参考： -g "log level = 2"</span><br><span class="line">    上行命令中我们使用用户xugz挂载程序文件夹到mount文件夹，所以mount目录下文件的所有者为xugz。当我们在外部访问分享文件夹此时新建文件，他的所属者默认为smbuser（我们可以通过 docker run -it dperson/samba sh 进入命令行查看 /etc/samba/smb.conf）配置force user指定用户以解决用户</span><br><span class="line">    map to guest 匿名访问且无密码    guest account 匿名用户映射到指定账户</span><br></pre></td></tr></tbody></table></figure><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Smaba</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker+ThinkPHP5部署基础</title>
    <url>/2019/12/03/Docker-tp5-base/</url>
    <content><![CDATA[<p>本篇是使用Docker部署ThinkPHP运行环境的命令笔记。这里ThinkPHP框架版本为5.0.24。主要包括Apache下的基本运行、apache角度的URL重写、添加PHP拓展、连接数据库和结合redis的简单操作示例等。</p>
<a id="more"></a>
<p>下载框架 <a href="http://www.thinkphp.cn/down.html" target="_blank" rel="noopener">官网框架下载地址</a>到本地，使用ftp方式上传到虚拟机tool目录中。</p>
<h1 id="结合apache的基本运行"><a href="#结合apache的基本运行" class="headerlink" title="结合apache的基本运行"></a>结合apache的基本运行</h1><p>创建一个目录叫做tp5<br>在tp5中创建两个目录。一个放程序文件(web)，一个放docker-compose.yml(compose)</p>
<p>解压框架压缩包至目录 /home/xugz/tp5/web，使用命令 <code>cd tool &amp;&amp; unzip mydata.zip -d ../tp5/web</code> 解压至指定目录<br>如果没有安装zip和unzip。执行 <code>sudo yum install zip unzip -y</code><br>我们需要将TP5web文件夹整个目录挂载到PHP-FPM容器，Apache容器仅仅挂载public文件夹，httpd.conf文件中fpm配置改为：<code>ProxyPassMatch ^/(.*\.php)$ fcgi://192.138.0.2:9000/php/public/$1</code></p>
<p>docker-compose.yml文件中添加如下内容</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">version: "3"</span><br><span class="line">services:</span><br><span class="line">  fpm:</span><br><span class="line">   image: php:7.2.0-fpm-alpine3.6</span><br><span class="line">   container_name: fpm</span><br><span class="line">   volumes:</span><br><span class="line">      - /home/xugz/tp5/web:/php</span><br><span class="line">   networks:</span><br><span class="line">      mywebnet:</span><br><span class="line">       ipv4_address: 192.138.0.2</span><br><span class="line">  httpd:</span><br><span class="line">   image: httpd:2.4-alpine</span><br><span class="line">   container_name: httpd</span><br><span class="line">   ports:</span><br><span class="line">      - 8081:80</span><br><span class="line">   volumes:</span><br><span class="line">      - /home/xugz/tp5/web/public:/usr/local/apache2/htdocs/</span><br><span class="line">      - /home/xugz/conf/httpd.conf:/usr/local/apache2/conf/httpd.conf</span><br><span class="line">   networks:</span><br><span class="line">      mywebnet:</span><br><span class="line">       ipv4_address: 192.138.0.3</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  mywebnet:</span><br><span class="line">     driver: bridge</span><br><span class="line">     ipam:</span><br><span class="line">       config:</span><br><span class="line">         - subnet: 192.138.0.0/16</span><br></pre></td></tr></tbody></table></figure>
<p>保存文件使用 <code>docker-compose up -d</code> 编译运行成功后使用 <code>curl localhost:8081/index.php</code>验证。</p>
<h1 id="添加控制器、url重写"><a href="#添加控制器、url重写" class="headerlink" title="添加控制器、url重写"></a>添加控制器、url重写</h1><p>tp5默认有个控制器，位置在: application/index/controller/index.php</p>
<p>在我们开启防火墙端口<code>sudo iptables -A INPUT -p tcp -m tcp --dport 8081 -j ACCEPT</code> 后，可以在windows本机通过 <code>虚拟机:端口/index.php</code><br>tp5创建控制可以用命令直接帮你创建：<code>php think make:controller index/test</code> <span style="font-size: 13px; color: #777;"> 需要确保本地有PHP环境</span> 当然我们也可以手工创建</p>
<p>开启apache重写模块<br>取消本行注释 <code>LoadModule rewrite_module modules/mod_rewrite.so</code><br>在网站配置相关节点加入  <code>AllowOverride all</code></p>
<div style="width: 67%;margin: left"><img src="/2019/12/03/Docker-tp5-base/rewrite_conf.png" class=""></div>

<p>完成后使用 <code>docker-compose restart</code> 让其重启重新构建容器<br><code>虚拟机:端口/index</code> 访问Index目录下index文件 <code>虚拟机:端口/index/index/test</code> 访问Index目录下index中的test方法<br><code>虚拟机:端口/index/user</code> 访问Index目录下user文件index方法 <code>虚拟机:端口/index/user_index</code> 访问Index目录下UserIndex文件index方法</p>
<h1 id="添加PHP扩展"><a href="#添加PHP扩展" class="headerlink" title="添加PHP扩展"></a>添加PHP扩展</h1><p>在容器中直接修改安装的话，容器删除后重新启动时，拓展和配置等都会丢失，所以我们在docker-compose文件中进行构建。在docker-compose.yml文件同目录创建新文件夹叫做build.<br>参考地址： <a href="https://hub.docker.com/_/php/" target="_blank" rel="noopener">https://hub.docker.com/_/php/</a></p>
<h2 id="PDO-MYSQL扩展"><a href="#PDO-MYSQL扩展" class="headerlink" title="PDO_MYSQL扩展"></a>PDO_MYSQL扩展</h2><p>默认的PHP–FPM容器没有PDO_MYSQL扩展，我们需要指定安装。<br>在build里面新建一个Dockerfile文件，注意文件名 我们这次随便取，譬如叫做phpfpm，配置镜像源并更新apk包后执行安装PDO_MYSQL扩展。参考命令</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">FROM php:7.2.0-fpm-alpine3.6</span><br><span class="line">RUN echo http://mirrors.ustc.edu.cn/alpine/v3.6/main &gt; /etc/apk/repositories &amp;&amp; echo http://mirrors.ustc.edu.cn/alpine/v3.6/community &gt;&gt; /etc/apk/repositories</span><br><span class="line">RUN apk update &amp;&amp; apk upgrade</span><br><span class="line">RUN docker-php-ext-install pdo_mysql</span><br></pre></td></tr></tbody></table></figure>
<p>返回上级目录修改docker-compose.yml文件，增加fpm服务标签</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">fpm:</span><br><span class="line">  build:</span><br><span class="line">   context: ./build</span><br><span class="line">   dockerfile: phpfpm</span><br><span class="line">  ……</span><br></pre></td></tr></tbody></table></figure>
<h2 id="redis拓展"><a href="#redis拓展" class="headerlink" title="redis拓展"></a>redis拓展</h2><p>在build里面新建一个Dockerfile文件，随便取，譬如叫做phpredis，安装redis依赖使用pecl来安装Redis扩展。参考命令</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">FROM php:7.2.0-fpm-alpine3.6</span><br><span class="line">RUN apk add autoconf gcc g++ make </span><br><span class="line">COPY ./redis-4.0.1 / # curl 'http://pecl.php.net/get/redis-4.0.1.tgz' -o redis-4.0.1.tgz</span><br><span class="line">RUN pecl install redis-4.0.1 \</span><br><span class="line">    &amp;&amp; docker-php-ext-enable redis</span><br></pre></td></tr></tbody></table></figure>
<p>返回上级目录修改docker-compose.yml文件，增加fpm服务build标签</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">fpm:</span><br><span class="line">  build:</span><br><span class="line">   context: ./build</span><br><span class="line">   dockerfile: phpredis</span><br><span class="line">  ……</span><br></pre></td></tr></tbody></table></figure>
<p>构建fpm服务设置 <code>docker-compose build fpm</code>， 完成后我们发现他帮我们新建了一个镜像，原有镜像没有所需拓展，删除原有启动新镜像<br><code>docker-compose stop fpm &amp;&amp; docker-compose rm fpm &amp;&amp; docker-compose up -d fpm</code></p>
<h1 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h1><p>编辑TP5对应的compose配置docker-compose.yml文件，加入MySQL的配置</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">mysql:</span><br><span class="line">   image: mysql:5.7</span><br><span class="line">   container_name: mysqld</span><br><span class="line">   ports:</span><br><span class="line">     - 3306:3306</span><br><span class="line">   volumes:</span><br><span class="line">     - /home/xugz/mysql/conf:/etc/mysql/conf.d</span><br><span class="line">     - /home/xugz/mysql/data:/var/lib/mysql</span><br><span class="line">   environment:</span><br><span class="line">     - MYSQL_ROOT_PASSWORD=123456</span><br><span class="line">   networks:</span><br><span class="line">     - mywebnet</span><br></pre></td></tr></tbody></table></figure>
<p>然后使用 <code>docker-compose up -d mysql</code> 创建MySQL服务器容器<br>在应用程序web目录里application/database.php中修改MySQL配置，参考配置如下</p>
<div style="width: 67%;margin: left"><img src="/2019/12/03/Docker-tp5-base/db_conn_conf.png" class=""></div>

<p>配置完成后，可定义模型和数据库调用尝试验证。<a href="https://www.kancloud.cn/manual/thinkphp5/135187" target="_blank" rel="noopener">点我，我是隐藏的参考地址</a></p>
<h1 id="结合redis容器基本操作"><a href="#结合redis容器基本操作" class="headerlink" title="结合redis容器基本操作"></a>结合redis容器基本操作</h1><p>拉取官方镜像 <code>docker pull redis:alpine</code><br>在conf目录下拉取redis配置文件 <code>wget https://raw.githubusercontent.com/antirez/redis/5.0/redis.conf</code><br>编辑redis.conf文件修改一些基本参数  如 <code>bind 0.0.0.0</code> 和 <code>dir /data</code></p>
<p>编辑TP5对应的compose配置docker-compose.yml文件，加入Redis的配置</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">redis:</span><br><span class="line">    image: redis:alpine</span><br><span class="line">    container_name: redis</span><br><span class="line">    ports:</span><br><span class="line">     - 6379:6379</span><br><span class="line">    volumes:</span><br><span class="line">     - /home/xugz/tp5/conf/redis.conf:/usr/local/etc/redis/redis.conf</span><br><span class="line">     - /home/xugz/tp5/redisdata:/data # 这里的data和 conf/redis.conf中的dir配置保持一致</span><br><span class="line">    networks:</span><br><span class="line">      mywebnet:</span><br><span class="line">       ipv4_address: 192.138.0.10</span><br></pre></td></tr></tbody></table></figure>
<p>修改application/config.php中关于缓存相关配置，参考如图</p>
<div style="width: 68%;margin: left"><img src="/2019/12/03/Docker-tp5-base/redis_conf.png" class=""></div>

<p>然后使用 <code>docker-compose up -d</code> 创建redis服务器容器。成功的话使用 <code>docker exec -it redis redis-cli</code> 可进入Redis客户端。也可以写简单的测试验证，最简单的代码如图</p>
<div style="width: 67%;margin: left"><img src="/2019/12/03/Docker-tp5-base/code_redis.png" class=""></div>

<p>使用浏览器访问 <code>http://192.168.2.156:8081/news</code> 即可看到测试数据<br>参考文档： <a href="https://hub.docker.com/_/redis/" target="_blank" rel="noopener">https://hub.docker.com/_/redis/</a></p>
<h1 id="上传文件-todo"><a href="#上传文件-todo" class="headerlink" title="上传文件 todo"></a>上传文件 todo</h1><p>默认模板配置已完成 <a href="https://www.kancloud.cn/manual/thinkphp5/119298" target="_blank" rel="noopener">参考地址</a>。默认模板实例代码已创建 <a href="https://www.kancloud.cn/manual/thinkphp5/155159" target="_blank" rel="noopener">模板实例代码参考地址</a><br>此时我们刷新页面报错：<em>mkdir():Permission denied</em>。这是因为主机上的用户和容器里用户未对应导致的权限问题。<br>如果你是apline 3.4 版本在数据源中加入 <code>echo http://nl.alpinelinux.org/alpine/edge/testing &gt;&gt; /etc/apk/repositories</code> 然后执行 <code>apk -no-cache add shadow</code>。是 alpine 3.6.则直接安装即可 <code>apk  add shadow</code>。通过 <a href="https://pkgs.alpinelinux.org/contents?file=usermod&amp;path=&amp;name=&amp;branch=&amp;repo=&amp;arch=" target="_blank" rel="noopener">地址</a> 找到对于 usermod文件的所在包。<br>完成之后执行 <code>usermod -u 1000 www-data &amp;&amp; groupmod -g 1000 www-data</code>修改用户www-data的用户以及群组ID为1000。搞定后要重启容器。</p>
<p>使用 <code>cat /etc/passwd</code> 命令查看用户归属组等信息</p>
<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="浏览器访问报错-variable-type-error-array"><a href="#浏览器访问报错-variable-type-error-array" class="headerlink" title="浏览器访问报错 variable type error:array"></a>浏览器访问报错 variable type error:array</h2><p>默认输出类型导致解析异常。在应用程序web目录里application/config.php中修改，如 <code>default_return_type = 'json'</code></p>
<h2 id="wget文件报错-unable-to-resolve-host-address"><a href="#wget文件报错-unable-to-resolve-host-address" class="headerlink" title="wget文件报错 unable to resolve host address"></a>wget文件报错 unable to resolve host address</h2><p>因为VPS的本地DNS不通导致的，我们需要修改当前VPS的DNS。<br>修改 /etc/resolv.conf 文件，增加DNS nameserver 8.8.8.8保存退出后重试。</p>
<h2 id="查看运行在docker中的redis版本"><a href="#查看运行在docker中的redis版本" class="headerlink" title="查看运行在docker中的redis版本"></a>查看运行在docker中的redis版本</h2><p>使用命令  `docker exec -it <containerid or="" name=""> redis-server -v</containerid></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Docker</category>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Docker</tag>
        <tag>ThinkPHP</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker结合MySQL常用操作</title>
    <url>/2019/12/03/Docker-mysql-base/</url>
    <content><![CDATA[<p>本篇是一些Docker结合MySQL常用操作的笔记。这里MySQL版本为5.7。主要是使用Docker搭建MySQL并导入数据、基于alpine镜像构建MySQL客户端、制作MySQL备份专用镜像和使用crontab实现数据库定时备份。</p>
<a id="more"></a>

<h1 id="启动MySQL容器、导入数据"><a href="#启动MySQL容器、导入数据" class="headerlink" title="启动MySQL容器、导入数据"></a>启动MySQL容器、导入数据</h1><p>拉取官方镜像 <code>docker pull mysql:5.7</code><br>启动MySQL <span style="font-size: 13px; color: #777;"> -e 设置环境变量 MYSQL_ROOT_PASSWORD 是root的密码</span><br><code>docker run --name mysql --rm -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123123 -d mysql:5.7</code><br>测试连接 <code>docker exec -it mysql mysql -u root -p123123</code> 或者 <code>docker exec -it mysql mysql -u root -p</code><br>实际运行必定要配置文件，根据官网的提示，配置文件在 /etc/mysql/my.cnf，数据目录在 /var/lib/mysql。</p>
<p>本地新建mysql目录，其中新建conf和data目录。conf挂载/etc/mysql/conf.d，data挂载/var/lib/mysql</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">vim /home/xugz/mysql/conf/conf.cnf</span><br><span class="line"></span><br><span class="line"># 下面是对应配置信息</span><br><span class="line">[mysqld]</span><br><span class="line">server-id = 1 #服务Id唯一 用于主从同步</span><br><span class="line">port = 3306</span><br><span class="line">log-error = /var/log/mysql/error.log #错误日志</span><br><span class="line">#只能用IP地址</span><br><span class="line">skip_name_resolve </span><br><span class="line">#数据库默认字符集</span><br><span class="line">character-set-server = utf8mb4</span><br><span class="line">#数据库字符集对应一些排序等规则 </span><br><span class="line">collation-server = utf8mb4_general_ci</span><br><span class="line">#设置client连接mysql时的字符集,防止乱码</span><br><span class="line">init_connect='SET NAMES utf8mb4'</span><br><span class="line">#最大连接数</span><br><span class="line">max_connections = 300</span><br></pre></td></tr></tbody></table></figure>
<p>修改完成后启动，确定放行3306端口</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">docker run --name mysql --rm -p 3306:3306 \</span><br><span class="line">-v /home/xugz/mysql/conf:/etc/mysql/conf.d  -v /home/xugz/mysql/data:/var/lib/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=123123 -d mysql:5.7</span><br></pre></td></tr></tbody></table></figure>
<p>使用 <code>docker logs</code> 查看是否存在报错或者使用客户端进入MySQL确认配置是否生效。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">docker exec -it mysql mysql -uroot -p123123</span><br><span class="line"># 或者上行命令使用  docker exec -it mysql bash 然后  mysql -uroot -p123123 正常来说会进入mysql交互界面</span><br><span class="line">show variables like '%max_connections%'； #查看最大连接数是否和配置一致用于判断配置是否生效。</span><br></pre></td></tr></tbody></table></figure>
<p>利用容器执行命令导入SQL文件</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">docker cp test.sql mysql:/tmp</span><br><span class="line">docker exec -it mysql mysql -uroot -p123123 </span><br><span class="line"> create database test;</span><br><span class="line"> use test;</span><br><span class="line"> source /tmp/test.sql;</span><br></pre></td></tr></tbody></table></figure>

<h1 id="基于alpine构建MySQL客户端"><a href="#基于alpine构建MySQL客户端" class="headerlink" title="基于alpine构建MySQL客户端"></a>基于alpine构建MySQL客户端</h1><p>alpine使用的是apk包管理器,命令，如apk add 、apk update 、apk del。默认镜像源可能比较慢，常用的有<br>中科大镜像源：<a href="http://mirrors.ustc.edu.cn/alpine/" target="_blank" rel="noopener">http://mirrors.ustc.edu.cn/alpine/</a> 阿里云镜像源：<a href="http://mirrors.aliyun.com/alpine/" target="_blank" rel="noopener">http://mirrors.aliyun.com/alpine/</a></p>
<p>拉取官方镜像 <code>docker pull alpine</code><br>新建目录 <code>mkdir mytool</code> 并在目录中新建Dockerfile文件，键入以下内容。安装MySQL客户端</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">FROM alpine:latest</span><br><span class="line">RUN echo http://mirrors.aliyun.com/alpine/v3.10/main &gt; /etc/apk/repositories</span><br><span class="line">RUN echo http://mirrors.aliyun.com/alpine/v3.10/community &gt;&gt; /etc/apk/repositories</span><br><span class="line">RUN apk update &amp;&amp; apk upgrade</span><br><span class="line">RUN apk add mysql-client</span><br><span class="line">ENTRYPOINT ["mysql"]</span><br></pre></td></tr></tbody></table></figure>
<p>如果不知道当前 alpine的版本，可以通过 <code>docker exec -it 容器名 sh</code>  通过命令行方式进入容器 使用命令 <code>cat /etc/issue</code> 查看。</p>
<p><span style="font-size: 13px; color: #777;">不使用dockerfile的话，手工配置加速镜像源使用命令<br><code>docker exec -it tmp sh -c "echo \"http://mirrors.aliyun.com/alpine/v3.10/main/\" &gt; /etc/apk/repositories"</code><br><code>docker exec -it tmp sh -c "echo \"http://mirrors.aliyun.com/alpine/v3.10/community/\" &gt;&gt; /etc/apk/repositories"</code><br>当然设置好后，还得  执行<code>apk update &amp;&amp; apk upgrade</code><br></span><br>构建镜像，使用命令编译 <code>docker build -t mytool:1.0 .</code><br>使用<code>docker run -it --name tmp  mytool:1.0 mysql -h 192.168.2.156 -uroot -p123123</code> 运行验证。<br><span style="font-size: 13px; color: #777;">这里的192.168.2.156是MySQL服务端部署主机的IP</span></p>
<p><a href="https://hub.docker.com/_/alpine/" target="_blank" rel="noopener">alpine镜像官方文档</a></p>
<h1 id="制作MySQL备份专用镜像"><a href="#制作MySQL备份专用镜像" class="headerlink" title="制作MySQL备份专用镜像"></a>制作MySQL备份专用镜像</h1><p>我们现在想要制作一个MySQL备份数据库数据的镜像，要求存放到指定目录 /home/xugz/mysql/database_bak/下，文件名与数据库名一致。<br>数据库备份命令<code>mysqldump -u用户名 -p密码 数据库名 &gt; 导出的文件名</code>。<br>修改原mytool目录中的Dockerfile文件，覆盖以下内容，注意需要去掉注释哦</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">FROM mytool:1.0 # 基于上文中alpine构建的MySQL客户端</span><br><span class="line">ENV mysql_host  192.168.2.156 # 环境变量 目标连接服务器</span><br><span class="line">ENV mysql_user root # 环境变量 默认用户为 root</span><br><span class="line">ENV mysql_pass 123123 # 环境变量 连接mysql服务器主机对应用户的密码</span><br><span class="line">ENV mysql_db test</span><br><span class="line">ENTRYPOINT mysqldump -h$mysql_host  -u$mysql_user -p$mysql_pass $mysql_db &gt; /data/$mysql_db.sql</span><br></pre></td></tr></tbody></table></figure>
<p>构建镜像，使用命令编译<code>docker build -t mytool:1.1 .</code><br>新建备份目录地址 <code>mkdir database_bak</code><br>运行并挂载指定目录 <code>docker run -it --name bakup --rm -v /home/xugz/mysql/database_bak:/data mytool:1.1</code></p>
<p>或者增加环境变量指定，用于跨主机备份，参考以下命令</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">docker run -it --name bakup --rm -v /home/xugz/mysql/database_bak:/data \</span><br><span class="line">-e mysql_pass=qwe123 -e mysql_host=192.168.222.1 -e mysql_db=db_test_products -e mysql_user=root \</span><br><span class="line">mytool:1.1</span><br></pre></td></tr></tbody></table></figure>
<p>运行完成后，可到备份目标地址查看是否存在文件。</p>
<h1 id="crontab定时备份数据表"><a href="#crontab定时备份数据表" class="headerlink" title="crontab定时备份数据表"></a>crontab定时备份数据表</h1><p>一般我们先写个脚本文件，塞入计划语句，然后加入到计划任务中。</p>
<p>新建dbback目录，进入新建备份计划脚本文件  <code>vi /bakup.sh</code> 塞入以下内容</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">if [ ! -d "/data" ]; then</span><br><span class="line">  mkdir /data</span><br><span class="line">fi</span><br><span class="line">mysqldump -h$mysql_host  -u$mysql_user -p$mysql_pass $mysql_db &gt; /data/$mysql_db-$(date +%Y%m%d_%H%M%S).sql</span><br></pre></td></tr></tbody></table></figure>
<p>保存文件后，授予脚本可执行权限 <code>chmod +x bakup.sh</code>。新建Dockerfile文件，添加以下内容，注意需要去掉注释哦</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">FROM mytool:1.0</span><br><span class="line">ENV mysql_host 192.168.2.156</span><br><span class="line">ENV mysql_user root</span><br><span class="line">ENV mysql_pass 123123</span><br><span class="line">ENV mysql_db test</span><br><span class="line">COPY ./bakup.sh /</span><br><span class="line">RUN chmod +x bakup.sh</span><br><span class="line">ENV cron_conf  "*       *       *       *       *  "</span><br><span class="line">RUN echo "$cron_conf /bakup.sh" &gt;&gt;  /var/spool/cron/crontabs/root</span><br><span class="line">ENTRYPOINT ["crond","-f"] # alpine中crond -f 命令为在客户端执行</span><br></pre></td></tr></tbody></table></figure>

<p>执行编译 <code>docker build -t mysqlbakup:1.0 .</code><br>使用下面命令运行，备份192.168.2.125主机上的db_test_products表</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">docker run -d --name bakup -v /home/xugz/mysql/database_bak:/data \</span><br><span class="line">-e mysql_pass=qwe123 -e mysql_host=192.168.2.125 -e mysql_db=db_test_products -e mysql_user=root \</span><br><span class="line">mysqlbakup:1.0</span><br></pre></td></tr></tbody></table></figure><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL指定日期加减</title>
    <url>/2019/12/02/MySQL-time-addsub/</url>
    <content><![CDATA[<p>MySQL官网是不承认时间直接相加减的，本篇记录时间加减操作需要注意点，加深记忆，避免以后入坑。<br>先来看看MySQL中常用的内建日期函数</p>
<table>
<thead>
<tr>
<th align="center"><strong>函数</strong></th>
<th align="center"><strong>描述</strong></th>
<th align="center"><strong>语法</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">NOW()</td>
<td align="center">返回当前的日期和时间</td>
<td align="center">NOW()</td>
</tr>
<tr>
<td align="center">CURDATE()</td>
<td align="center">返回当前的日期，该函数相当于current_date关键字</td>
<td align="center">CURDATE()</td>
</tr>
<tr>
<td align="center">CURTIME()</td>
<td align="center">返回当前的时间，相当于current_time关键字</td>
<td align="center">CURTIME()</td>
</tr>
<tr>
<td align="center">DATE()</td>
<td align="center">提取日期或日期/时间表达式的日期部分</td>
<td align="center">DATE(date) date 参数是合法的日期表达式</td>
</tr>
<tr>
<td align="center">EXTRACT()</td>
<td align="center">用于返回日期/时间的单独部分，如年、月、日、小时、分钟等</td>
<td align="center">EXTRACT(unit FROM date) date 参数是合法的日期表达式</td>
</tr>
<tr>
<td align="center">DATE_ADD()</td>
<td align="center">给日期添加指定的时间间隔</td>
<td align="center">DATE_ADD(date,INTERVAL expr type) date 是合法的日期表达式，expr 是时间间隔。</td>
</tr>
<tr>
<td align="center">DATE_SUB()</td>
<td align="center">从日期减去指定的时间间隔</td>
<td align="center">DATE_SUB(date,INTERVAL expr type) date 是合法的日期表达式，expr 是时间间隔。</td>
</tr>
<tr>
<td align="center">DATEDIFF()</td>
<td align="center">返回两个日期之间的天数</td>
<td align="center">DATEDIFF(date1,date2) date1 和 date2 是合法的日期或日期/时间表达式。</td>
</tr>
<tr>
<td align="center">DATE_FORMAT()</td>
<td align="center">用不同的格式显示日期/时间</td>
<td align="center">DATE_FORMAT(date,format) date 是合法的日期。format 规定日期/时间的输出格式。</td>
</tr>
</tbody></table>
<a id="more"></a>
<p>比如说，我们现在想要查询得出当前日期的一天前和五天前的日期，测试SQL语句如下</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">SELECT NOW(),CURDATE(), CURTIME(), DATE_SUB(CURDATE(),INTERVAL 1 DAY),CURDATE()-1, DATE_SUB(CURDATE(),INTERVAL 5 DAY), CURDATE()-5;</span><br></pre></td></tr></tbody></table></figure>
<div style="width: 85%;margin: left"><img src="/2019/12/02/MySQL-time-addsub/sql_result.png" class="" title="执行SQL得到的结果"></div>
明显发现使用 CURDATE()函数直接进行加减存在问题，需要留意。当我们需要日期加减操作时，可使用 DATE_SUB() 和 DATE_ADD() 函数。

<p>DATE_ADD()和DATE_SUB()函数常用type参数有： </p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">MICROSECOND 微秒 </span><br><span class="line">SECOND 秒</span><br><span class="line">MINUTE 分钟</span><br><span class="line">HOUR 小时</span><br><span class="line">DAY 天</span><br><span class="line">WEEK 周</span><br><span class="line">MONTH 月 </span><br><span class="line">QUARTER 季度 </span><br><span class="line">YEAR 年</span><br></pre></td></tr></tbody></table></figure><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker搭建PHP运行环境</title>
    <url>/2019/11/29/Docker-php-base/</url>
    <content><![CDATA[<p>本篇是使用Docker安装PHP运行环境的命令笔记。这里PHP版本为7.0+。主要是手动运行php+fpm+apache步骤、使用compose编排php+fpm+apache 和nginx+PHP-FPM环境搭建过程简述。</p>
<a id="more"></a>

<h1 id="运行PHP程序"><a href="#运行PHP程序" class="headerlink" title="运行PHP程序"></a>运行PHP程序</h1><p>拉取7.2版本的官方PHP镜像 <code>docker pull php:7.2-cli</code><br>运行刚才的镜像<span style="font-size: 13px; color: #777;"> –rm 运行完自己干掉自己，一般用于执行临时任务</span></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">docker run -it --rm --name runphp -v  /home/xugz/php:/usr/src/myphp  php:7.2-cli \</span><br><span class="line">php /usr/src/myphp/index.php</span><br></pre></td></tr></tbody></table></figure>
<h1 id="手动运行php-fpm-apache"><a href="#手动运行php-fpm-apache" class="headerlink" title="手动运行php+fpm+apache"></a>手动运行php+fpm+apache</h1><p>我们尽可能的使用基于alpine的镜像。<br>安装FPM镜像 <code>docker pull php:7.2.0-fpm-alpine3.6</code> ，使用命令<code>docker run -d --rm --name fpm php:7.2.0-fpm-alpine3.6</code>  让容器以后台守护模式运行<br>安装Apache镜像 <code>docker pull httpd:2.4-alpine</code>，写一个测试HTML网页，使用命令 <code>docker run -d -p 80:80 --rm --name myweb -v /home/xugz/php:/usr/local/apache2/htdocs/ httpd:2.4-alpine</code>映射80端口挂载默认网站路径，尝试是否正常使用。一般来说应该是可使用的。</p>
<p>然后我们需要修改配置文件。我们可以自己准备配置，或者从容器中拷贝一个。根据文档，容器里默认的配置文件路径为/usr/local/apache2/conf/httpd.conf。<br>使用 <code>docker exec -it myweb cat /usr/local/apache2/conf/httpd.conf</code>查看配置文件信息<br>使用 <code>docker cp myweb:/usr/local/apache2/conf/httpd.conf /home/xugz/conf/</code>复制文件<br>修改配置文件 <code>vi /home/xugz/conf/httpd.conf</code> 找到以下内容，把前面的#号去掉开启对应模块</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">LoadModule proxy_module modules/mod_proxy.so</span><br><span class="line">LoadModule proxy_http_module modules/mod_proxy_http.so</span><br><span class="line">LoadModule proxy_fcgi_module modules/mod_proxy_fcgi.so</span><br></pre></td></tr></tbody></table></figure>
<p>另需增加修改配置如下内容</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;VirtualHost *:80&gt;</span><br><span class="line">    ServerAdmin xugz@com.cn</span><br><span class="line">    DocumentRoot "/usr/local/apache2/htdocs"</span><br><span class="line">    ServerName localhost</span><br><span class="line">    &lt;Directory "/usr/local/apache2/htdocs"&gt;</span><br><span class="line">     Options None</span><br><span class="line">     Require all granted</span><br><span class="line">    &lt;/Directory&gt;</span><br><span class="line">    ProxyRequests Off</span><br><span class="line">    ProxyPassMatch ^/(.*\.php)$ fcgi://192.158.0.2:9000/php/$1 </span><br><span class="line">    #转向fpm基本配置。使用docker network ls &amp;&amp; docker network inspect bridge 中查看FPM的inet</span><br><span class="line">&lt;/VirtualHost&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>启动fpm的时候把php文件夹挂载到fpm容器中，因此fpm容器的启动要增加文件挂载，命令改成<br><code>docker run -d --rm --name fpm -v /home/xugz/php:/php php:7.2.0-fpm-alpine3.6</code><br>重新运行apache容器</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">docker run -d  -p 80:80 --name myweb -v /home/xugz/php:/usr/local/apache2/htdocs/  \</span><br><span class="line">-v /home/xugz/conf/httpd.conf:/usr/local/apache2/conf/httpd.conf \</span><br><span class="line">httpd:2.4-alpine</span><br></pre></td></tr></tbody></table></figure>
<p>没有异常的话，可用 <code>curl localhost</code> 和 <code>curl localhost/index.php</code> 测试。</p>
<h1 id="compose编排php-fpm-apache"><a href="#compose编排php-fpm-apache" class="headerlink" title="compose编排php+fpm+apache"></a>compose编排php+fpm+apache</h1><p>为了让我们容器的启动和删除操作方便，所以要我们要使用docker compose ，一款编排工具。<br>下载安装步骤见本站其他篇，<a href="https://xlline.github.io/2019/11/25/Docker-Nginx负载均衡/#compose">点我瞬时移动</a>。新建目录webcompose目录，在目录中新建docker-compose.yml文件,拷贝如下内容(就是将上文中两条启动容器命令翻译成dockerfile)</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">version: "3"                                                                         </span><br><span class="line">services:                                                                            </span><br><span class="line">  fpm:                                                                               </span><br><span class="line">   image: php:7.2.0-fpm-alpine3.6                                                    </span><br><span class="line">   container_name: fpm                                                               </span><br><span class="line">   volumes:                                                                          </span><br><span class="line">      - /home/xugz/php:/php                                                          </span><br><span class="line">   networks:                                                                         </span><br><span class="line">      mywebnet:                                                                      </span><br><span class="line">       ipv4_address: 192.159.0.2  # 这里的IP需要和Apache配置文件httpd.conf中的ProxyPassMatch fcgi地址保持一致                                                 </span><br><span class="line">                                                                                     </span><br><span class="line">  httpd:                                                                             </span><br><span class="line">   image: httpd:2.4-alpine                                                           </span><br><span class="line">   container_name: httpd                                                             </span><br><span class="line">   ports:                                                                            </span><br><span class="line">      - 80:80                                                                        </span><br><span class="line">   volumes:                                                                          </span><br><span class="line">      - /home/xugz/php:/usr/local/apache2/htdocs/                                    </span><br><span class="line">      - /home/xugz/conf/httpd.conf:/usr/local/apache2/conf/httpd.conf                </span><br><span class="line">   networks:                                                                         </span><br><span class="line">      mywebnet:                                                                      </span><br><span class="line">       ipv4_address: 192.159.0.3  # 设置指定IP IP从0.1开始生成                                                </span><br><span class="line">                                                                                     </span><br><span class="line">                                                                                     </span><br><span class="line">networks:                                                                            </span><br><span class="line">  mywebnet:  # 如果之前创建了相同子网的网络 要先删掉之前的,否则冲突                                                          </span><br><span class="line">     driver: bridge                                                                  </span><br><span class="line">     ipam:                                                                           </span><br><span class="line">       config:                                                                       </span><br><span class="line">         - subnet: 192.159.0.0/16                                                    </span><br><span class="line">          # 子网随便填写 IP地址是以网络号和主机号来表示网络上的主机的，只有在一个网络号下的计算机之间才能“直接”互通，不同网络号的计算机要通过网关（Gateway）才能互通。但这样的划分在某些情况下显得并不十分灵活。为此IP网络还允许划分成更小的网络，称为子网（Subnet）。</span><br></pre></td></tr></tbody></table></figure>
<p>然后可以使用 <code>docker-compose up -d</code>启动可用 <code>curl localhost</code> 和 <code>curl localhost/index.php</code> 测试。</p>
<h1 id="搭建nginx-PHP-FPM环境"><a href="#搭建nginx-PHP-FPM环境" class="headerlink" title="搭建nginx+PHP-FPM环境"></a>搭建nginx+PHP-FPM环境</h1><p>使用命令 <code>docker pull nginx:1.13.9-alpine</code>安装Nginx<span style="font-size: 13px; color: #777;"><br>默认的网页文件夹是 /usr/share/nginx/html<br>默认的配置文件地址是/etc/nginx/nginx.conf</span><br>如果我们没有现成的配置文件，那么可以先胡乱启动下容器，然后拷贝到 我们的文件夹中。如下</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">docker run --name nginx --rm -d  nginx:1.13.9-alpine</span><br><span class="line">docker cp nginx:/etc/nginx/nginx.conf ~/conf</span><br></pre></td></tr></tbody></table></figure>
<p>普通html的情况下，nginx不需要做任何配置，使用如下命令重新运行后，尝试普通HTML访问是否正常</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">docker run --name nginx -d --rm -v /home/xugz/php:/usr/share/nginx/html \</span><br><span class="line">-p 80:80 nginx:1.13.9-alpine</span><br></pre></td></tr></tbody></table></figure>
<h2 id="nginx-FPM的配置"><a href="#nginx-FPM的配置" class="headerlink" title="nginx+FPM的配置"></a>nginx+FPM的配置</h2><p>nginx配置文件的内容参考</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">user  nginx;</span><br><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">error_log  /var/log/nginx/error.log warn;</span><br><span class="line">pid        /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">events {</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http {</span><br><span class="line">    include       /etc/nginx/mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '</span><br><span class="line">                      '$status $body_bytes_sent "$http_referer" '</span><br><span class="line">                      '"$http_user_agent" "$http_x_forwarded_for"';</span><br><span class="line"></span><br><span class="line">    access_log  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    #gzip  on;</span><br><span class="line"></span><br><span class="line">  #  include /etc/nginx/conf.d/*.conf;</span><br><span class="line">  server{</span><br><span class="line">    listen 80;</span><br><span class="line">    location / {</span><br><span class="line">    root  /usr/share/nginx/html; </span><br><span class="line">     index  index.html index.htm index.php;</span><br><span class="line">   }</span><br><span class="line">   location ~ \.php$ {</span><br><span class="line">        root /php;</span><br><span class="line">        fastcgi_pass 192.138.0.2:9000; # 这个192.138.0.2 是容器IP 需要指定</span><br><span class="line">        fastcgi_index index.php;</span><br><span class="line">        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;</span><br><span class="line">        include fastcgi_params;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>启动FPM和Nginx</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">docker network create --driver=bridge --subnet=192.138.0.0/16 mynginx</span><br><span class="line"></span><br><span class="line">docker run -d  --rm --name fpm \</span><br><span class="line">--network mynginx --ip 192.138.0.2 \ # 这个IP和Nginx配置文件中 fastcgi_pass配置的IP需要保持一致</span><br><span class="line">-v /home/xugz/php:/php \</span><br><span class="line">php:7.2.0-fpm-alpine3.6</span><br><span class="line"></span><br><span class="line">docker run --name nginx -d --rm -v /home/xugz/php:/usr/share/nginx/html \</span><br><span class="line">-v /home/xugz/conf/nginx.conf:/etc/nginx/nginx.conf \</span><br><span class="line">--network mynginx  -p 80:80 \</span><br><span class="line">nginx:1.13.9-alpine</span><br></pre></td></tr></tbody></table></figure>

<p>当然可以使用compose进行编排，很简单这里不就赘述了，不要忘记同步修改Apache和Nginx配置文件中的fpm部分，统一改成fpm的IP。<br><a href="https://hub.docker.com/_/nginx/" target="_blank" rel="noopener">nginx 官方镜像</a></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker-Machine</title>
    <url>/2019/11/28/Docker-Machine/</url>
    <content><![CDATA[<p>Docker Machine是简化的Docker安装的命令行工具,通过命令行即可在相应的平台上(目前支持在本机运行virtualbox虚拟主机，Hyper-V虚拟主机，VMware虚拟主机，AWS EC2，Azure，DigitalOcean，Google等公有云主机)安装Docker。（好比在你机器上装个虚拟机，老外帮你准备好了专门的ISO，docker 都帮你弄好了）</p>
<p>本篇主要涉及Docker-Machine创建虚拟Docker主机、创建私有镜像仓库，利用Docker-Machine在虚拟主机中使用compose启动Nginx负载均衡、设置IP转发在windows中访问。</p>
<a id="more"></a>

<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>使用如下命令，或者直接到<a href="https://github.com/docker/machine/releases" target="_blank" rel="noopener">对应github</a>下载，授予可执行权限，保证最后拷贝到环境变量相关目录里(/usr/local/bin/)即可。  </p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">curl -L https://github.com/docker/machine/releases/download/v0.16.2/docker-machine-`uname -s`-`uname -m` &gt;/tmp/docker-machine &amp;&amp; \</span><br><span class="line">chmod +x /tmp/docker-machine &amp;&amp; \</span><br><span class="line">sudo cp /tmp/docker-machine /usr/local/bin/docker-machine</span><br></pre></td></tr></tbody></table></figure>
<p><a href="https://docs.docker.com/machine/install-machine/" target="_blank" rel="noopener">Docker Machine安装参考文档</a></p>
<h1 id="创建Docker主机"><a href="#创建Docker主机" class="headerlink" title="创建Docker主机"></a>创建Docker主机</h1><p>首先我们需要安装virtualbox <a href="https://www.virtualbox.org/wiki/Linux_Downloads" target="_blank" rel="noopener">官方下载地址点我</a>。选择对应版本的rpm下载包，通过ftp方式拷贝到服务器，进行<code>yum install &lt;包名&gt; -y</code> 安装即可。同时，oracle也告诉我们存在其他方法 <a href="http://yum.oracle.com/getting-started.html" target="_blank" rel="noopener">参考地址</a>，如下</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">wget   http://yum.oracle.com/public-yum-ol7.repo</span><br><span class="line">然后把下载下来的文件拷贝到/etc/yum.repos.d中</span><br><span class="line">yum install VirtualBox-5.2</span><br></pre></td></tr></tbody></table></figure>
<p><a href="https://docs.docker.com/machine/drivers/virtualbox/" target="_blank" rel="noopener">创建Docker主机安装virtualbox参考地址</a><br>完成可以执行 <code>docker-machine create --driver=virtualbox vbox-test</code> 创建。<br>执行该命令，他首先检查 /home/xugz/.docker/machine/cache 是否存在，没有则创建文件夹；然后寻找该文件夹下是否有 boot2docker.iso文件（一个基于Tiny Core Linux的系统，里面Docker啥的都帮你搞定了），另外会默认会创建一个虚拟网卡 （vboxnet0）。所以如果太慢，我们可以去<a href="https://github.com/boot2docker/boot2docker/releases/" target="_blank" rel="noopener">boot2docker.iso对应gitHub下载地址</a>手工下载用ftp传到目标服务器再执行创建。</p>
<div style="width: 61%;margin: left"><img src="/2019/11/28/Docker-Machine/create.png" class=""></div>

<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><p>查看列表 <code>docker-machine ls</code><br>查看IP地址 <code>docker-machine ip 虚拟机名称</code><br>停止和开启 <code>docker-machine stop/start  虚拟机名称</code><br>查看环境变量 <code>docker-machine env vbox-test</code><br> 如果我们要操作machine里面的docker环境变量 ,可以不用进入到虚拟机<br> 使用eval命令（可以读取一连串的参数,然后按照参数特性来执行）<br> 此时我们执行 <code>eval $(docker-machine env vbox-test)</code><br> 这时我们本机的docker客户端就连接了vbox-test的docker服务端<br> 切换回来使用命令 <code>eval $(docker-machine env -u)</code><br>SSH的方式连接到虚拟机 <code>docker-machine ssh 虚拟机名称</code></p>
<h1 id="移植主机镜像到虚拟机"><a href="#移植主机镜像到虚拟机" class="headerlink" title="移植主机镜像到虚拟机"></a>移植主机镜像到虚拟机</h1><p><strong>创建私有镜像库</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">docker pull registry  # docker pull一个官方镜像 专门处理私有镜像的提交和拉取</span><br><span class="line">docker run -d -p 5000:5000 --name registry registry # 运行镜像生成新容器</span><br><span class="line">docker tag  centos:httpd  localhost:5000/web  # 给本地centos:httpd 镜像打标签，命名为localhost:5000/web</span><br><span class="line">docker push localhost:5000/web  # 提交镜像</span><br><span class="line">docker tag  centos:nginx localhost:5000/nginx</span><br><span class="line">docker push localhost:5000/nginx</span><br><span class="line">docker rmi localhost:5000/web # 提交完成后, 可以删除刚才创建的标签</span><br></pre></td></tr></tbody></table></figure>
<p><strong>查看仓库目录</strong><br>注意以下的命令要保证registry容器正在运行<br>可以利用API的方式 查看私有仓库中的目录 <code>curl http://localhost:5000/v2/_catalog</code> <a href="https://docs.docker.com/registry/spec/api/#listing-repositories" target="_blank" rel="noopener">参考文档</a><br><strong>同步镜像</strong><br>最后使用命令 <code>docker-machine ssh vbox-test</code> 进入<br><code>docker pull 192.168.99.1:5000/nginx</code> 将私有镜像库中的Nginx下载到虚拟机里 主机的IP:端口</p>
<p>修改镜像名使用tag命令 <code>docker tag &lt;原镜像名称&gt; &lt;新的镜像名&gt;</code> 完成后再把原镜像删除即可。我也不知道为什么官方没有rename命令，非得整这么麻烦。等我学会Go语言，就来本地尝试下。</p>
<h1 id="利用Docker-Machine在虚拟主机中使用compose启动Nginx负载均衡"><a href="#利用Docker-Machine在虚拟主机中使用compose启动Nginx负载均衡" class="headerlink" title="利用Docker-Machine在虚拟主机中使用compose启动Nginx负载均衡"></a>利用Docker-Machine在虚拟主机中使用compose启动Nginx负载均衡</h1><p>这里我们也想使用compose进行容器统一管理，之前我们在宿主机中安装了compose（位置在：/usr/local/bin/docker-compose）我们可以直接拷贝就行了。</p>
<h2 id="拷贝compose-到虚拟主机"><a href="#拷贝compose-到虚拟主机" class="headerlink" title="拷贝compose 到虚拟主机"></a>拷贝compose 到虚拟主机</h2><p>利用scp命令 <a href="https://docs.docker.com/machine/reference/scp/#example" target="_blank" rel="noopener">参考文档</a><br>我们进入宿主机执行  <code>docker-machine scp  /usr/local/bin/docker-compose  vbox-test:/home/docker/.local/bin</code><br><span style="font-size: 13px; color: #777;"> /home/docker/.local/bin 是虚拟机用户的一个环境变量 （也可以自己设置）</span><br>把我们之前做的compose配置文件拷贝过去 <code>docker-machine scp -r  mycompose vbox-test:/home/docker/</code>(如果是文件夹，则要加入-r 进行递归操作)。然后修改docker-compose.yml镜像配置改为虚拟主机自己的。<br>我们的compose里面有个映射文件，也就是把主机的文件映射到容器。那么是否我们也需要 把网站文件给拷贝到 虚拟机里面呢？<br>答案是不需要，我们可以使用 mount命令来完成。</p>
<h2 id="映射文件挂载到虚拟主机"><a href="#映射文件挂载到虚拟主机" class="headerlink" title="映射文件挂载到虚拟主机"></a>映射文件挂载到虚拟主机</h2><p><a href="https://docs.docker.com/machine/reference/mount/" target="_blank" rel="noopener">mount命令参考文档</a><br>官方提醒我们，需要依赖使用sshfs将目录从虚拟机挂载到本地主机。SSHFS可以利用SFTP的方式把远程文件映射到本机 。<br>在宿主机的安装sshfs，安装如下依赖</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">yum install -y epel-release</span><br><span class="line">yum install -y fuse-sshfs</span><br></pre></td></tr></tbody></table></figure>
<p>首先在虚拟机里创建一个文件夹叫做 nginx <code>docker-machine ssh vbox-test mkdir nginx</code><br>主机上也创建一个文件夹 （空的），叫做 vbox-nginx。<br>挂载使用命令 <code>docker-machine mount vbox-test:/home/docker/nginx  /home/xugz/mnginx</code> 需要注意不在挂载点目录执行<br>取消挂载使用命令 <code>docker-machine mount -u vbox-test:/home/docker/nginx  /home/xugz/mnginx</code></p>
<p>把本地主机之前的nginx文件夹里面的文件，拷贝到mnginx里面。进入nginx文件夹使用命令<code>cp . /home/xugz/mnginx -r</code><br>对应修改docker-compose.yml中对应文件挂载的配置。我们以后只要在宿主机修改文件就可以了。<br>接下来我们就可以利用 <code>docker-compose up -d</code> 在我们的虚拟机中启动容器了。</p>
<h2 id="外部访问-IP转发"><a href="#外部访问-IP转发" class="headerlink" title="外部访问 IP转发"></a>外部访问 IP转发</h2><p>在虚拟主机中使用<code>curl localhost:9090</code>访问<br>在宿主机中使用 <code>curl $(docker-machine ip vbox-test):9090</code>访问<br>在windows里访问使用VBoxManage（我们上面虚了好几层了哦<del>~</del>）<br>简单说一下virtualbox的几个命令 <a href="https://www.virtualbox.org/manual/ch08.html#vboxmanage-controlvm" target="_blank" rel="noopener">文档点我</a><br><code>VBoxManage list vms</code>  列出当前的所有虚拟机<br><code>VBoxManage controlvm</code> 可以用来修改正在运行的虚拟机状态<br>  <code>存在参数语法： natpf&lt;1-N&gt; [&lt;name&gt;],tcp|udp,[&lt;hostip&gt;],&lt;hostport&gt;,[&lt;guestip&gt;], &lt;guestport&gt;</code><br>譬如<code>VBoxManage controlvm "vbox-test" natpf1 "mynat1,tcp,,9090,,9090"</code> 这代表把vbox-test这个虚拟机的tcp端口（IP不限制）转发到 宿主机的9090端口。执行完成后我们就可以使用 宿主机IP:9090端口访问<br><code>VBoxManage controlvm "vbox-test" natpf1 delete mynat1</code> 删掉规则，这样外部就不能访问了</p>
<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="http-server-gave-HTTP-response-to-HTTPS-client"><a href="#http-server-gave-HTTP-response-to-HTTPS-client" class="headerlink" title="http: server gave HTTP response to HTTPS client"></a>http: server gave HTTP response to HTTPS client</h2><p>因为docker为了安全，需要https 。但是我们可以让其不需要。<br>如果我们在主机里，那么要修改的是<code>/etc/docker/daemon.json</code>。在machine里也是一样的，那么要在/etc/docker下面 手动创建daemon.json文件（默认是木有的），添加如下内容</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line">    "insecure-registries":["192.168.99.1:5000"]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>修改完成需要重启虚拟机主机 <code>docker-machine restart 虚拟机名称</code>。</p>
<div style="width: 61%;margin: left"><img src="/2019/11/28/Docker-Machine/error_https.png" class=""></div>
## This computer doesn't have VT-X/AMD-v enabled. Enabling it in the BIOS is mandatory
如果是在VMware中的Linux，需要在关机状态的虚拟机进行配置: 虚拟机&gt;设置&gt;处理器中勾选虚拟化 Intel VT-x/EPT 或 AMD-V/RVI(V)<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker+Nginx负载均衡</title>
    <url>/2019/11/25/Docker-Nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
    <content><![CDATA[<p>使用手工commit的方式创建了一个基于CentOS的Nginx容器，并且可以通过外部访问到。入手docker compose——Docker容器编排的工具，可以配置并启动多个容器，适合复杂业务场景。本篇是铺垫nginx负载均衡的步骤记录。</p>
<a id="more"></a>

<h1 id="手工搭建CentOS-Nginx容器"><a href="#手工搭建CentOS-Nginx容器" class="headerlink" title="手工搭建CentOS+Nginx容器"></a>手工搭建CentOS+Nginx容器</h1><p><code>docker pull centos</code><br>在centos镜像基础上创建一个临时容器tmp，执行命令 <code>docker run -it --privileged --name tmp centos /usr/sbin/init</code>后如下图。保持不动，新开窗口进行后续操作。</p>
<div style="width: 61%;margin: left"><img src="/2019/11/25/Docker-Nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/run_desc.png" class=""></div>

<p>进入容器 <code>docker exec -it tmp /bin/bash</code><br>升级包 <code>rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm</code><br>默认安装 <code>yum install nginx -y</code><br><span style="font-size: 13px; color: #777;"> 安装完成之后，nginx配置文件默认路径为 /etc/nginx/nginx.conf ，是全局配置文件。</span><br>启动nginx <code>systemctl start nginx</code><br>设置开机自启动 <code>systemctl enable nginx</code> 启动成功我们可以使用 <code>curl http://localhost</code> 验证，正常的话，我们会看到Welcome to nginx之类的HTML源码。<br>接下来我们要把容器作为镜像保存起来，使用commit命令。<br>利用dockerfile里面的格式去创建新镜像 <code>docker commit -c 'CMD ["/usr/sbin/init"] ' -c "EXPOSE 80" tmp centos:nginx</code><br>基于这个镜像创建新容器，因为docker非持久化，把配置文件映射到本地主机。使用cp命令。<br><code>docker cp tmp:/etc/nginx/nginx.conf /home/xugz/nginx/conf/</code><br>此时可以停止并删除临时容器tmp。<br>启动Nginx镜像 指定端口9090，nginx.conf文件同步 <code>docker run --name mynginx --privileged -p 9090:80 -v /home/xugz/nginx/conf/nginx.conf:/etc/nginx/nginx.conf -d centos:nginx</code>。启动成功后，使用虚拟机IP:9090在本地浏览器可以访问。</p>
<p><a href="https://docs.docker.com/engine/reference/commandline/cp/" target="_blank" rel="noopener">cp命令参考地址</a><br><a href="https://docs.docker.com/engine/reference/commandline/commit/#description" target="_blank" rel="noopener">commit命令参考地址</a></p>
<h1 id="模拟创建多个web网站"><a href="#模拟创建多个web网站" class="headerlink" title="模拟创建多个web网站"></a>模拟创建多个web网站</h1><p>本地新建文件/home/xugz/nginx/web1/index.html和/home/xugz/nginx/web2/index.html。两个HTML页面内容不一致。<br>基于本地已有镜像centos:httpd启动两个容器</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">docker run --name web1 -d -p 8080:80 --privileged -v /home/xugz/nginx/web1/:/var/www/html/ centos:httpd</span><br><span class="line">docker run --name web1 -d -p 8081:80 --privileged -v /home/xugz/nginx/web1/:/var/www/html/ centos:httpd</span><br></pre></td></tr></tbody></table></figure>
<p>要停止删除也要执行两条语句 <code>docker stop web1 &amp;&amp; docker rm web1</code> 和 <code>docker stop web2 &amp;&amp; docker rm web2</code><br>很明显，这样很麻烦，我们可以用compose来进行统一管理。</p>
<h1 id="compose"><a href="#compose" class="headerlink" title="compose"></a>compose</h1><p><strong>下载安装</strong><br>根据官方文档引导，首先下载Docker Compose的当前稳定版本<br><code>sudo curl -L "https://github.com/docker/compose/releases/download/1.24.1/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose</code><br><span style="font-size: 13px; color: #777;"> 如果根本下载不动，也可以更换下载地址，使用命令<br> <code>sudo curl -L "https://get.daocloud.io/docker/compose/releases/download/1.24.1/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose</code></span><br>完成后授予文件可执行权限 <code>sudo chmod +x /usr/local/bin/docker-compose</code><br>使用 <code>docker-compose --version</code> 查看版本</p>
<p><strong>启动</strong><br>为项目创建一个目录，这里我们基于的是原来创建的镜像</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">mkdir composetest</span><br><span class="line">cd composetest</span><br></pre></td></tr></tbody></table></figure>
<p>创建docker-compose.yml 文件,拷贝如下内容</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">services:  # 任务</span><br><span class="line">  web1:  # 自定义</span><br><span class="line">    container_name: web1 # 容器名称</span><br><span class="line">    image: "centos:httpd"  # 这个容器基于的镜像</span><br><span class="line">    ports: </span><br><span class="line">      - "8080:80"   </span><br><span class="line">    privileged: true  #给容器加特权</span><br><span class="line">    volumes: </span><br><span class="line">      - "/home/xugz/nginx/web1/:/var/www/html/"  #映射文件</span><br><span class="line">  web2: </span><br><span class="line">    container_name: web2</span><br><span class="line">    image: "centos:httpd"</span><br><span class="line">    ports: </span><br><span class="line">      - "8081:80"</span><br><span class="line">    privileged: true</span><br><span class="line">    volumes: </span><br><span class="line">      - "/home/xugz/nginx/web2/:/var/www/html/"</span><br><span class="line">version: "3"</span><br></pre></td></tr></tbody></table></figure>
<p>保存退出，在文件所在目录执行<code>docker-compose up -d</code>启动。<br>停止容器使用命令 <code>docker-compose stop web1</code> 删除容器使用命令 <code>docker-compose rm</code><br>当然我们也可以连带Nginx一起启动操作，只需要在docker-compose.yml文件中services增加如下内容</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">nginx: </span><br><span class="line">    container_name: mynginx</span><br><span class="line">    image: "centos:nginx"</span><br><span class="line">    ports: </span><br><span class="line">      - "9090:80"</span><br><span class="line">    privileged: true</span><br><span class="line">    volumes: </span><br><span class="line">      - "/home/xugz/nginx/conf/nginx.conf:/etc/nginx/nginx.conf"</span><br></pre></td></tr></tbody></table></figure>
<p><a href="http://www.bejson.com/validators/yaml/" target="_blank" rel="noopener">yaml在线检查工具</a><br><a href="https://docs.docker.com/compose/" target="_blank" rel="noopener">compose官方参考文档</a></p>
<h1 id="network"><a href="#network" class="headerlink" title="network"></a>network</h1><p>网络列表 <code>docker network ls</code><br>查看详细信息 <code>docker network inspect &lt;network name&gt;</code><br>容器之前可以使用IP进行互通，实验如图</p>
<div style="width: 80%;margin: left"><img src="/2019/11/25/Docker-Nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/network_before.png" class=""></div>

<h2 id="手动配置"><a href="#手动配置" class="headerlink" title="手动配置"></a>手动配置</h2><p>现在我们新建网络 mynginx 然后让上文中涉及的三个容器都加入我们新建的网络里<br>停止原有三个容器 使用命令 <code>docker-compose stop</code><br>创建网络 指定子网为192.168.0.0 <code>docker network create -d bridge --subnet=192.168.0.0/16 mynginx</code><br>在docker-compose.yml文件中新增如下内容</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">version: "3"</span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    ……</span><br><span class="line">    networks:</span><br><span class="line">      - "mynginx-net" # 和networks中网络名称一致</span><br><span class="line">networks:</span><br><span class="line">  mynginx-net: # 可自定义</span><br><span class="line">    external:</span><br><span class="line">      name: "mynginx"</span><br></pre></td></tr></tbody></table></figure>
<p>启动三个容器 使用命令<code>docker-compose start</code>就可以了。也可以进入容器验证查看</p>
<p><a href="http://tool.chinaz.com/Tools/subnetmask" target="_blank" rel="noopener">子网掩码的计算地址</a><br><a href="https://docs.docker.com/engine/reference/commandline/network/#usage" target="_blank" rel="noopener">network官方参考文档</a><br><a href="https://docs.docker.com/compose/compose-file/#network-configuration-reference" target="_blank" rel="noopener">网络配置参考(version 3)</a></p>
<h2 id="compose-up-时自动创建网络"><a href="#compose-up-时自动创建网络" class="headerlink" title="compose up 时自动创建网络"></a>compose up 时自动创建网络</h2><p><a href="https://docs.docker.com/compose/compose-file/#ipv4_address-ipv6_address" target="_blank" rel="noopener">参考文档</a><br>修改docker-compose.yml文件，示例如下</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">version: "3"</span><br><span class="line">services:</span><br><span class="line">  app: </span><br><span class="line">    image: centos:nginx </span><br><span class="line">    container_name: mynginx</span><br><span class="line">    networks:		 </span><br><span class="line">      mynginx-net:	 </span><br><span class="line">        ipv4_address: 192.158.0.2 </span><br><span class="line"></span><br><span class="line">networks: </span><br><span class="line">  mynginx-net: </span><br><span class="line">    driver: bridge</span><br><span class="line">    ipam: </span><br><span class="line">      config:</span><br><span class="line">       - subnet: 192.158.0.0/24</span><br></pre></td></tr></tbody></table></figure>
<p>保存后使用命令<code>docker-compose up -d</code> 启动，会自动生成名称为 mycompose_mynginx-net 的网络。</p>
<h2 id="env-file"><a href="#env-file" class="headerlink" title="env_file"></a>env_file</h2><p>如果设置比较复杂，那么我们可以通过env_file来完成变量的引用<br>在docker-compose.yml文件同目录内新建 .env 文件，里面输入变量，格式为 <code>xugz=192.158.0.7</code>。在docker-compose.yml文件中直接使用 ${xugz}引用即可。</p>
<p><a href="https://docs.docker.com/compose/environment-variables/#the-env-file" target="_blank" rel="noopener">env_file参数参考文档</a></p>
<h1 id="简单的Nginx负载均衡设置"><a href="#简单的Nginx负载均衡设置" class="headerlink" title="简单的Nginx负载均衡设置"></a>简单的Nginx负载均衡设置</h1><p>修改本地nginx配置文件，当然你要确保你本地的文件已经和docker容器中的实时同步。<br>注释掉 <code>include /etc/nginx/conf.d/*.conf;</code> 这行，删除原来关于server配置，增加如下内容</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">upstream mydocker {</span><br><span class="line">         server 192.158.0.7;  # web1 的ip地址 可以通过 docker network inspect mycompose_mynginx-net 查看到</span><br><span class="line">         server 192.158.0.3;  # web2 的ip地址</span><br><span class="line">     }</span><br><span class="line">  server {</span><br><span class="line">    listen       80;  # 默认80端口</span><br><span class="line">    server_name  mydocker;</span><br><span class="line">    location / {      # 访问根目录 默认跳转到http://mydocker，就是我们配置的 upstream mydocker</span><br><span class="line">         proxy_set_header Host $host;</span><br><span class="line">         proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">         proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">         proxy_buffering off;</span><br><span class="line">         proxy_pass http://mydocker;     </span><br><span class="line">    }</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>
<p>保存退出后回到docker-compose.yml文件所在目录，使用 <code>docker-compose restart nginx</code> 重启Nginx。访问 <a href="http://192.168.2.156:9090/" target="_blank" rel="noopener">http://192.168.2.156:9090/</a> 会轮流跳转到web1或web2。</p>
<h1 id="容器健康检查机制"><a href="#容器健康检查机制" class="headerlink" title="容器健康检查机制"></a>容器健康检查机制</h1><p>参数如下：<br>–health-cmd: 检查的命令<br>–health-interval：两次健康检查的间隔<br>–health-timeout：健康检查命令运行超时时间，超过代表失败<br>–health-retries：当连续失败指定次数后，则将容器状态视为 unhealthy<br>–health-start-period:容器启动的初始化时间，此时健康检查失效不会计入次数</p>
<p>运行web1容器同时进行检查80端口是否正常，每三秒检查一次，当连续失败3次后提示，健康检查命令超5秒也代表失败。示例命令如下</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">docker run  --name web1 -d -p 8080:80 --privileged -v /home/xugz/nginx/web1/:/var/www/html/ \</span><br><span class="line">--health-cmd="curl --silent --fail http://localhost:80/ || exit 1" --health-interval=3s --health-retries=3 \</span><br><span class="line">--health-timeout=5s \</span><br><span class="line"> centos:httpd</span><br></pre></td></tr></tbody></table></figure>
<span style="font-size: 13px; color: #777;">
参数说明 ： <br>
 \ 换行使用  <br>
 --silent --fail 出现错误的时候不进行输出 <br>
 exit 1 非正常退出  <br>
 || 表示 左边执行为false才会执行右边 &amp;&amp; 为左边执行为true才会执行右边 <br>
</span> 
<div style="width: 80%;margin: left"><img src="/2019/11/25/Docker-Nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/health_run.png" class="" title="容器健康检查机制手动执行"><img src="/2019/11/25/Docker-Nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/health_un.png" class="" title="不健康容器示例"></div>

<p>此时，可以使用 <code>docker inspect web1</code> 命令检查容器<br>只看Health部分使用命令 <code>docker inspect --format='' web1</code></p>
<p><strong>使用Compose进行健康检查</strong><br>docker-compose.yml文件对应容器中添加如下示例配置即可</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">healthcheck:</span><br><span class="line">  test: ["CMD", "curl", "-f", "http://localhost:80"]</span><br><span class="line">  interval: 3s</span><br><span class="line">  timeout: 10s</span><br><span class="line">  retries: 3</span><br></pre></td></tr></tbody></table></figure>

<p><a href="https://docs.docker.com/compose/compose-file/#healthcheck" target="_blank" rel="noopener">healthcheck参考文档</a></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>docker基础及常见问题</title>
    <url>/2019/11/21/Docker-%E5%9F%BA%E7%A1%80%E5%8F%8A%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>我们常说的Docker是指Docker引擎(Engine),主要包含<br>1、Docker Daemon — docker守护进程(Server)<br>2、Docker REST API — 和docker daemon交互的REST API (用python或Go程序调用API和Daemon交互)<br>3、Docker CLI —  命令行应用 （我们执行docker run 等命令，用来和Daemon交互）</p>
<p>Docker服务端提供了一系列REST API（Docker Remote API)，当我们敲入docker命令时实际上是通过API和Docker服务端进行交互。官方提供了三种链接方式：<br>a. unix:///var/run/docker/sock（默认连接方式）<br>b. tcp://host:port<br>c. fd://socketfd<br>本篇整理了docker常用命令及遇到的问题。</p>
<a id="more"></a>

<h1 id="centOS7下安装docker"><a href="#centOS7下安装docker" class="headerlink" title="centOS7下安装docker"></a>centOS7下安装docker</h1><p>安装基本依赖 <code>sudo yum install -y yum-utils device-mapper-persistent-data lvm2</code><br>设置即将安装的是稳定版仓库 <code>sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</code><br>(该步骤可不选)edge月更新仓库 <code>sudo yum-config-manager --enable docker-ce-edge</code><br>安装之前可以查看所有仓库中所有docker版本 <code>yum list docker-ce --showduplicates | sort -r</code><br>默认安装使用命令 <code>yum install docker-ce -y</code><br>安装完成启动 <code>systemctl start docker</code> 并设置开机自启动 <code>systemctl enable docker</code><br>docker安装时默认创建了docker用户组，将普通用户加入docker用户组就可以不使用sudo来操作docker。使用命令 <code>sudo usermod -aG docker xugz</code>加入，需要重新登录或者执行 <code>newgrp docker</code> 改变当前用户的有效群组才能生效。<br>到这里没有异常的话，使用 <code>docker version</code> 验证安装是否成功</p>
<div style="width: 70%;margin: left"><img src="/2019/11/21/Docker-%E5%9F%BA%E7%A1%80%E5%8F%8A%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/docker_v.png" class=""></div>

<p>安装过程同时可以参照<a href="https://yq.aliyun.com/articles/110806?spm=a2c1q.8351553.0.0.11b720beQRyGTx" target="_blank" rel="noopener">阿里云的帮助文档</a></p>
<h1 id="centOS8安装docker"><a href="#centOS8安装docker" class="headerlink" title="centOS8安装docker"></a>centOS8安装docker</h1><p><strong>卸载旧版本</strong> 较旧的 Docker 版本称为 docker 或 docker-engine 。如果已安装这些程序，请卸载它们以及相关的依赖项<br><strong>安装步骤</strong><br>下载docker-ce的repo <code>curl https://download.docker.com/linux/centos/docker-ce.repo -o /etc/yum.repos.d/docker-ce.repo</code><br>安装依赖（这是相比centos7的关键步骤） <code>yum install https://download.docker.com/linux/fedora/30/x86_64/stable/Packages/containerd.io-1.2.6-3.3.fc30.x86_64.rpm</code><br>安装docker-ce  <code>yum install docker-ce</code><br>启动docker<code>systemctl start docker</code><br>启动成功，使用<code>systemctl status docker</code> 查看docker启动状态或者使用<code>docker version</code>验证是否安装成功。</p>
<h1 id="配置镜像加速器"><a href="#配置镜像加速器" class="headerlink" title="配置镜像加速器"></a>配置镜像加速器</h1><p>这里我用的是阿里云的镜像，配置加速器<a href="https://cr.console.aliyun.com/cn-shenzhen/instances/mirrors" target="_blank" rel="noopener">官方</a>已经给到参考步骤了，如下图</p>
<div style="width: 68%;margin: left"><img src="/2019/11/21/Docker-%E5%9F%BA%E7%A1%80%E5%8F%8A%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/mirrors.png" class=""></div>

<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><p>检查docker版本 <code>docker --version</code> or <code>docker info</code><br>拉取镜像 <code>docker pull  &lt;images name&gt;</code><br>运行镜像 <code>docker run -i -t --name &lt;new container name&gt; &lt;images name&gt;</code></p>
<div style="font-size: 13px; margin-left: 0.5em; color: #777;  margin-top: -10px">
参数说明：<br>
 -d: 后台运行 ；<br>
 -p: 映射端口 ；<br>
 --name :  譬如 --name xxxooo: 为容器指定一个名称； <br>
 -i: 打开stdin，用于和容器进行交互，通常与 -t 同时使用；<br>
 -t: 为容器创建虚拟终端，我们就可以登录终端了通常与 -i 同时使用。 

<p>提示：使用ctrl+d 可退出当前终端。ctrl+p+q 退出容器但不关闭</p>
</div>

<p>列出容器 <code>docker ps</code><br>查看到当前所有容器  <code>docker ps -a</code><br>再次启动运行容器  先通过 <code>docker ps -a</code> 获得容器ID ，使用 <code>docker start &lt;container ID&gt;</code> 启动容器，使用 <code>docker attach &lt;container ID &gt;</code> 进入运行容器。当然也可以使用组合命令 <code>docker start &lt;contianer ID &gt;  -a -i</code><br><span style="font-size: 13px; color: #777;">  -a 打开容器的输出流 -i 打开容器的输入流。注意，退出后容器也会自动停止。</span><br>在运行中的容器中执行命令进行交互式操作 <code>docker exec  -i -t &lt;container Name or container ID &gt;  &lt;cmd&gt;</code><br><span style="font-size: 13px; color: #777;"> docker exec -i -t myos1 /bin/bash </span><br>停止所有的container <code>docker stop $(docker ps -a -q)</code><br>删除所有容器 <code>docker rm $(docker ps -a -q)</code><br>删除所有镜像 <code>docker rmi $(docker images -q)</code></p>
<p>具体命令格式规范参考<a href="https://docs.docker.com/engine/reference/commandline/docker/" target="_blank" rel="noopener">官方文档</a></p>
<h1 id="利用Dockerfile创建自定义镜像"><a href="#利用Dockerfile创建自定义镜像" class="headerlink" title="利用Dockerfile创建自定义镜像"></a>利用Dockerfile创建自定义镜像</h1><p>Dockerfile是由一系列命令和参数构成的脚本，这些命令应用于基础镜像并最终创建一个新的镜像。<br>譬如我要用到apache，希望直接构建出一个环境容器。我们创建一个空文件夹 build，在该目录下创建一个叫做Dockerfile(注意大小写)的文件，插入内容如下:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">FROM centos:latest</span><br><span class="line">RUN yum -y install httpd  </span><br><span class="line">RUN  systemctl enable httpd.service </span><br><span class="line">CMD /usr/sbin/init # 如果这里不加cmd 的话，运行命令需要改写成 docker run --privileged -d -p 8080:80 --name myhttpd centos:httpd /usr/sbin/init</span><br><span class="line">EXPOSE 80 # 暴露80端口</span><br></pre></td></tr></tbody></table></figure>
<p>保存退出。<br>命令 <code>docker build</code> 用于读取Dockerfile创建镜像。使用命令 <code>docker build -t centos:httpd .</code>创建<br><span style="font-size: 13px; color: #777;">  -t 指定镜像名称</span><br>创建完成，使用命令  <code>docker run --privileged -d -p 8080:80 --name myhttpd centos:httpd</code>  运行。</p>
<p>参考文档 <a href="https://docs.docker.com/engine/reference/builder/#usage" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/builder/#usage</a></p>
<p><strong>容器和主机间的数据共享</strong><br>利用<code>docker run -v</code><br>使用命令 <code>docker run --privileged -d -p 8080:80 --name  myhttpd -v /home/xugz/myweb:/var/www/html centos:httpd</code><br>在容器中设置了一个挂载点/var/www/html(即apache的默认的网站目录) ，并将主机上的 /home/xugz/myweb目录中的映射到/var/www/html下。<br>这时我们容器中操作该目录或在主机中操作，两者均是实时同步的</p>
<h1 id="配置远程访问"><a href="#配置远程访问" class="headerlink" title="配置远程访问"></a>配置远程访问</h1><p>我们发现docker默认连接方式为unix:///var/run/docker/sock。编辑docker文件修改服务启动运行方法，增加TCP连接配置，保存后重启Docker。再次查看发现已配置成功。具体命令如下</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">ps -ef | grep docker</span><br><span class="line">sudo vim /usr/lib/systemd/system/docker.service</span><br><span class="line"># 将原来`ExecStart=/usr/bin/dockerd`改成`ExecStart=/usr/bin/dockerd -H tcp://0.0.0.0:2375 -H unix://var/run/docker.sock`</span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br><span class="line">ps -ef | grep docker</span><br></pre></td></tr></tbody></table></figure>

<h1 id="Docker管理工具portainer"><a href="#Docker管理工具portainer" class="headerlink" title="Docker管理工具portainer"></a>Docker管理工具portainer</h1><p>Docker API必须通过TCP公开，确保已经开放TCP连接2375端口<br>拉取镜像 <code>docker pull portainer/portainer</code><br>运行容器 <code>docker run -d -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock -v /opt/portainer:/data --name mydocker portainer/portainer</code><br>运行成功后，浏览器输入虚拟机IP+9000即可进入对应可视化界面。初次进入portainer会让你先创建用户，密码不能少于八位。而后配置将Portainer连接到要管理的Docker环境。</p>
<div style="width: 68%;margin: left"><img src="/2019/11/21/Docker-%E5%9F%BA%E7%A1%80%E5%8F%8A%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/portainer_enter.png" class=""></div>

<p>如果在此时报错: <em>Get <a href="http://192.168.2.156:2375/_ping" target="_blank" rel="noopener">http://192.168.2.156:2375/_ping</a>: dial tcp 192.168.2.156:2375: connect: no route to host</em> 。关闭防火墙即可解决。</p>
<p>github地址：<a href="https://github.com/portainer/portainer" target="_blank" rel="noopener">https://github.com/portainer/portainer</a><br>portainer官网地址: <a href="https://portainer.readthedocs.io/en/latest/deployment.html" target="_blank" rel="noopener">https://portainer.readthedocs.io/en/latest/deployment.html</a></p>
<h1 id="使用portainer创建MySQL容器"><a href="#使用portainer创建MySQL容器" class="headerlink" title="使用portainer创建MySQL容器"></a>使用portainer创建MySQL容器</h1><p>在搭建好的可视化界面中，找到App Templates选择需要的镜像，填写必要配置后点击部署。这里我安装的是MySQL。需要注意的是，创建完成后自动帮我们启动这个镜像，MySQL官方提醒使用命令<code>docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag</code> 进行运行需要注意。记录密码 <code>docker run --name mysql -p 3307:3306 -e MYSQL_ROOT_PASSWORD=123123 -d mysql</code>。之后就可以使用本地进行来连接了。当然我们也可以使用命令行<code>docker exec -it mysql bash</code> 进入docker的MySQL容器。</p>
<div style="width: 68%;margin: left"><img src="/2019/11/21/Docker-%E5%9F%BA%E7%A1%80%E5%8F%8A%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/docker_mysql.png" class=""></div>

<p>MySQL官方镜像文档: <a href="https://hub.docker.com/_/mysql/" target="_blank" rel="noopener">https://hub.docker.com/_/mysql/</a></p>
<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="普通用户运行docker命令不需要使用sudo"><a href="#普通用户运行docker命令不需要使用sudo" class="headerlink" title="普通用户运行docker命令不需要使用sudo"></a>普通用户运行docker命令不需要使用sudo</h2><p>使用root账号，修改文件 <code>/etc/sudoers</code>，找到 Allow root to run any commands anywhere 位置增加普通用户。如图</p>
<div style="width: 30%;margin: left"><img src="/2019/11/21/Docker-%E5%9F%BA%E7%A1%80%E5%8F%8A%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/sudoer_add.png" class=""></div>
在Linux系统中运行没有sudo密码的特定命令
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[xugz@xugz yum.repos.d]$ docker images</span><br><span class="line">Got permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get http://%2Fvar%2Frun%2Fdocker.sock/v1.40/images/json: dial unix /var/run/docker.sock: connect: permission denied</span><br><span class="line">[xugz@xugz yum.repos.d]$ sudo docker images</span><br><span class="line">[sudo] password for xugz:</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">[xugz@xugz yum.repos.d]$ id xugz</span><br><span class="line">uid=1000(xugz) gid=1000(xugz) groups=1000(xugz),0(root)</span><br><span class="line">[xugz@xugz yum.repos.d]$ sudo usermod -aG docker $(whoami)</span><br><span class="line">[xugz@xugz yum.repos.d]$ id xugz</span><br><span class="line">uid=1000(xugz) gid=1000(xugz) groups=1000(xugz),984(docker),0(root)</span><br></pre></td></tr></tbody></table></figure>
注销并再次登录或者使用命令 `newgrp - docker` 改变当前用户的有效群组，完成后可以使用 `docker version` 命令检查安装的Docker版本了。

<h2 id="docker-安装完成后测试hello-world出现问题（Unable-to-find-image-‘hello-world-latest’-locally）"><a href="#docker-安装完成后测试hello-world出现问题（Unable-to-find-image-‘hello-world-latest’-locally）" class="headerlink" title="docker 安装完成后测试hello-world出现问题（Unable to find image ‘hello-world:latest’ locally）"></a>docker 安装完成后测试hello-world出现问题（Unable to find image ‘hello-world:latest’ locally）</h2><p>安装docker之后，测试hello-world镜像，终端卡在<code>Unable to find image 'hello-world:latest' locally</code>位置<br>docker在本地没有找到hello-world镜像，也没有从docker仓库中拉取镜像，出项这个问题的原因：是因为docker服务器再国外，我们在国内无法正常拉取镜像，所以就需要我们设置国内的镜像加速器。我这里用的是阿里云，当然其他的也可以，大家可以自己选择。Docker 官方和国内很多云服务商都提供了国内加速器服务，例如： Docker官方提供的中国镜像库<a href="https://registry.docker-cn.com" target="_blank" rel="noopener">https://registry.docker-cn.com</a>。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'</span><br><span class="line">{</span><br><span class="line">  "registry-mirrors": ["https://v2xlbv24.mirror.aliyuncs.com"]</span><br><span class="line">}</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></tbody></table></figure>
<p>参考本篇<a href="https://xlline.github.io/2019/11/21/docker%E5%9F%BA%E7%A1%80%E5%8F%8A%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/#%E9%85%8D%E7%BD%AE%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F%E5%99%A8">配置镜像加速器</a></p>
<h2 id="IPv4-forwarding-is-disabled-Networking-will-not-work"><a href="#IPv4-forwarding-is-disabled-Networking-will-not-work" class="headerlink" title="IPv4 forwarding is disabled. Networking will not work."></a>IPv4 forwarding is disabled. Networking will not work.</h2><p>解决办法：<br><code>sudo vi /etc/sysctl.conf</code>   (Linux内核参数配置文件，可在运行时修改某些内核参数，使之永久生效)<br>加入<code>net.ipv4.ip_forward=1</code><br>保存并退出后  执行<code>sudo systemctl restart network</code>。并且需要确保8080端口已放行 <code>sudo iptables -A INPUT -p tcp -m tcp --dport 8080 -j ACCEPT</code></p>
<h2 id="Failed-to-get-D-Bus-connection-Operation-not-permitted。"><a href="#Failed-to-get-D-Bus-connection-Operation-not-permitted。" class="headerlink" title="Failed to get D-Bus connection: Operation not permitted。"></a>Failed to get D-Bus connection: Operation not permitted。</h2><p>使用命令<code>docker run -d -p 8080:80 --name myhttpd centos:httpd</code> 运行后<br>报错 <em>Failed to get D-Bus connection: Operation not permitted</em>。<br>使用 <code>docker run --privileged -d -p 8080:80 --name myhttpd centos:httpd</code> 运行解决。<br><span style="font-size: 13px; color: #777;"> –privileged 参数，给容器加特权,否则交互式方式进入容器无法操作一些譬如修改内核、修改系统参数、甚至启动服务等</span></p>
<p>参考<br><a href="https://docs.docker.com/engine/reference/commandline/run/#capture-container-id-cidfile" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/run/#capture-container-id-cidfile</a><br><a href="https://github.com/moby/moby/issues/7459" target="_blank" rel="noopener">https://github.com/moby/moby/issues/7459</a><br><a href="https://developers.redhat.com/blog/2014/05/05/running-systemd-within-docker-container/" target="_blank" rel="noopener">https://developers.redhat.com/blog/2014/05/05/running-systemd-within-docker-container/</a></p>
<h2 id="使用Dockerfile成功启动Apache但浏览器拒绝访问"><a href="#使用Dockerfile成功启动Apache但浏览器拒绝访问" class="headerlink" title="使用Dockerfile成功启动Apache但浏览器拒绝访问"></a>使用Dockerfile成功启动Apache但浏览器拒绝访问</h2><p>如果是防火墙的问题，出现的报错提示应该是无法连接之类的，一般出现404  403那说明能连上。<br>因为默认的容器里可能没有设置默认主页配置，所以先将apache的默认主页index.html或index.htm 在浏览器输全尝试。<br>若还不行，进入容器，<code>curl http://localhost/index.html</code>尝试，确保浏览器地址没有输错。<br>若还不行，进入apache配置文件 /etc/httpd/conf/httpd.conf 找到默认目录DocumentRoot然后查看 这个目录是否有，且对应文件是否存在。<br>我这里的问题是，安装的这个apache镜像没有默认主页，新建就可以了……</p>
<h2 id="启动容器时报错Error-response-from-daemon-driver-failed-programming-external-connectivity-on-endpoint-mysql"><a href="#启动容器时报错Error-response-from-daemon-driver-failed-programming-external-connectivity-on-endpoint-mysql" class="headerlink" title="启动容器时报错Error response from daemon: driver failed programming external connectivity on endpoint mysql"></a>启动容器时报错Error response from daemon: driver failed programming external connectivity on endpoint mysql</h2><p>docker服务启动时定义的自定义链DOCKER由于某种原因被清掉，重启docker服务及可重新生成自定义链DOCKER。使用命令<code>systemctl restart docker</code>在重新启动容器即可。如图</p>
<div style="width: 68%;margin: left"><img src="/2019/11/21/Docker-%E5%9F%BA%E7%A1%80%E5%8F%8A%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/docker_run_error.png" class=""></div>

<h2 id="docker-log-报错-SELinux-Could-not-open-policy-file-lt-etc-selinux-targeted-policy-policy-31-No-such-file-or-directory"><a href="#docker-log-报错-SELinux-Could-not-open-policy-file-lt-etc-selinux-targeted-policy-policy-31-No-such-file-or-directory" class="headerlink" title="docker log 报错 SELinux:  Could not open policy file <= /etc/selinux/targeted/policy/policy.31:  No such file or directory"></a>docker log <container>报错 SELinux:  Could not open policy file &lt;= /etc/selinux/targeted/policy/policy.31:  No such file or directory</container></h2><p>因为使用centos镜像的问题，需要处理SELinux。实际开发中使用镜像alpine，这里就先放过这个问题，以后再表。</p>
<h1 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h1><p><a href="https://yq.aliyun.com/articles/110806?spm=a2c1q.8351553.0.0.11b720beQRyGTx" target="_blank" rel="noopener">阿里云docker安装帮助文档</a><br><a href="https://docs.docker.com/engine/reference/commandline/docker/" target="_blank" rel="noopener">官方文档基本命令参考地址</a><br><a href="https://cr.console.aliyun.com/cn-shenzhen/instances/mirrors" target="_blank" rel="noopener">配置镜像加速器阿里云文档</a><br><a href="https://github.com/portainer/portainer" target="_blank" rel="noopener">管理工具portainer仓库地址</a><br><a href="https://portainer.readthedocs.io/en/latest/deployment.html" target="_blank" rel="noopener">管理工具portainer官网地址</a></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL之联合索引最左原则</title>
    <url>/2019/11/20/MySQL-%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E6%9C%80%E5%B7%A6%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<p>MySQL可以创建复合索引，一个索引最多可以包含16列。联合索引参与条件规则的字段需要放在前面，即需要满足最左匹配原则。举例来说，如果你有一个三列的索引(col1, col2, col3)，走索引的条件顺序为(col1)，(col1, col2)以及 (col1, col2, col3)。<br>使用EXPLAIN关键字可以模拟优化器执行SQL查询语句，指标TYPE结果值好坏依次是: system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL。</p>
<a id="more"></a>

<p>假设存在测试表，增加联合索引 <code>idx_last_first_name</code> (<code>last_name</code>,<code>first_name</code>)</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">CREATE TABLE `employees` (</span><br><span class="line">  `emp_no` int(11) NOT NULL COMMENT '员工号',</span><br><span class="line">  `birth_date` date NOT NULL COMMENT '出生年月',</span><br><span class="line">  `first_name` varchar(14) NOT NULL COMMENT '名',</span><br><span class="line">  `last_name` varchar(16) NOT NULL COMMENT '姓',</span><br><span class="line">  `gender` enum('M','F') NOT NULL COMMENT '性别',</span><br><span class="line">  `hire_date` date NOT NULL COMMENT '雇佣时间',</span><br><span class="line">  `ids` char(18) DEFAULT NULL COMMENT '身份证号',</span><br><span class="line">  PRIMARY KEY (`emp_no`),</span><br><span class="line">  KEY `idx_last_first_name` (`last_name`,`first_name`)</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>
<p>下面SQL是遵循了最左匹配原则的语句</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">SELECT * FROM employees WHERE last_name='Jones';</span><br></pre></td></tr></tbody></table></figure>
<div style="width: 70%;margin: left"><img src="/2019/11/20/MySQL-%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E6%9C%80%E5%B7%A6%E5%8E%9F%E5%88%99/result_sus_1.png" class=""></div>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">SELECT * FROM employees WHERE last_name='Jones' ORDER BY last_name,first_name desc;</span><br></pre></td></tr></tbody></table></figure>
<div style="width: 70%;margin: left"><img src="/2019/11/20/MySQL-%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E6%9C%80%E5%B7%A6%E5%8E%9F%E5%88%99/result_sus_2.png" class=""></div>

<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">SELECT * FROM employees WHERE last_name='Jones' AND first_name='John';</span><br></pre></td></tr></tbody></table></figure>
<div style="width: 70%;margin: left"><img src="/2019/11/20/MySQL-%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E6%9C%80%E5%B7%A6%E5%8E%9F%E5%88%99/result_sus_3.png" class=""></div>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">SELECT * FROM employees  WHERE last_name='Jones'  AND (first_name='John' OR first_name='Jon');</span><br></pre></td></tr></tbody></table></figure>
<div style="width: 70%;margin: left"><img src="/2019/11/20/MySQL-%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E6%9C%80%E5%B7%A6%E5%8E%9F%E5%88%99/result_sus_4.png" class=""></div>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">SELECT * FROM employees  WHERE last_name='Jones'  AND first_name &gt;='M' AND first_name &lt; 'N';</span><br></pre></td></tr></tbody></table></figure>
<div style="width: 70%;margin: left"><img src="/2019/11/20/MySQL-%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E6%9C%80%E5%B7%A6%E5%8E%9F%E5%88%99/result_sus_5.png" class=""></div>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">SELECT * FROM employees WHERE last_name ='M' ORDER BY first_name,last_name desc;</span><br></pre></td></tr></tbody></table></figure>
<div style="width: 70%;margin: left"><img src="/2019/11/20/MySQL-%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E6%9C%80%E5%B7%A6%E5%8E%9F%E5%88%99/result_sus_6.png" class=""></div>


<p>不走索引的语句类型有 </p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">SELECT * FROM employees WHERE first_name='John';</span><br></pre></td></tr></tbody></table></figure>
<div style="width: 70%;margin: left"><img src="/2019/11/20/MySQL-%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E6%9C%80%E5%B7%A6%E5%8E%9F%E5%88%99/result_error_1.png" class=""></div>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">SELECT * FROM employees WHERE last_name='Jones' OR first_name='John';</span><br></pre></td></tr></tbody></table></figure>
<div style="width: 70%;margin: left"><img src="/2019/11/20/MySQL-%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E6%9C%80%E5%B7%A6%E5%8E%9F%E5%88%99/result_error_2.png" class=""></div>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">SELECT * FROM employees WHERE last_name='Jones' ORDER BY first_name,last_name desc;</span><br></pre></td></tr></tbody></table></figure>
<div style="width: 70%;margin: left"><img src="/2019/11/20/MySQL-%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E6%9C%80%E5%B7%A6%E5%8E%9F%E5%88%99/result_error_3.png" class=""></div>


<p>注意，排序时是否走索引受MySQL版本的影响，在MySQL8.0后，在排序查询中字段顺序不受影响。如图</p>
<div style="width: 70%;margin: left"><img src="/2019/11/20/MySQL-%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E6%9C%80%E5%B7%A6%E5%8E%9F%E5%88%99/order_1.png" class=""></div>

<p>但是在MySQL5.7及以下版本中，排序查询受字段顺序影响。</p>
<p>参考文档</p>
<ol>
<li>MySQL联合索引 <a href="https://dev.mysql.com/doc/refman/5.7/en/multiple-column-indexes.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/multiple-column-indexes.html</a></li>
<li>EXPLAIN输出格式 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/explain-output.html</a></li>
<li>Visual Explain图 <a href="https://dev.mysql.com/doc/workbench/en/wb-performance-explain.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/workbench/en/wb-performance-explain.html</a></li>
<li>各个引擎支持的索引类型 <a href="https://dev.mysql.com/doc/refman/5.7/en/create-index.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/create-index.html</a></li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL8.0之caching_sha2_password</title>
    <url>/2019/11/15/MySQL-8.0%E4%B9%8Bcaching_sha2_password/</url>
    <content><![CDATA[<p>本地MySQL8.0.18安装完成在命令行中可以正常连接访问，使用Navicat测试连接报错<em>Authentication plugin ‘caching_sha2_password’ cannot be loaded</em>。导致异常的原因是MySQL不同版本使用的密码加密规则不一致。在MySQL8之前的版本使用的密码加密规则是mysql_native_password，但是在MySQL8则是caching_sha2_password。</p>
<a id="more"></a>
<p>解决方案：<br>一、指定加密规则为mysql_native_password<br>使用语句修改用户加密方式<code>ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'root';</code>  后重置密码<code>alter user user() identified by 'qwe123';</code><br>创建了一个新用户并指定，在命令行中执行语句<code>CREATE USER  'your username'@'%' IDENTIFIED WITH mysql_native_password BY 'your password';</code>，完成后使用新用户账号密码连接Navicat。<br>二、将默认密码规则设置为mysql_native_password，刷新权限并重置root密码<br>如仍无法使用, 应在my.cnf中设置 <code>default_authentication_plugin = mysql_native_password</code>完成后并执行<code>flush privileges;</code></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>Navicat</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu速学笔记</title>
    <url>/2019/11/08/Ubuntu/</url>
    <content><![CDATA[<p>为了学习docker来回顾Linux基础，本篇是基于Ubuntu操作系统18.04.3版本安装部署遇到问题或有用知识点的汇总整理。</p>
<h1 id="ifconfig命令找不到"><a href="#ifconfig命令找不到" class="headerlink" title="ifconfig命令找不到"></a>ifconfig命令找不到</h1><p>问题描述： 在Vmware安装完成Ubuntu后，输入ifconfig提示：<em>Command ‘ifconfig’ not found, but can be installed with: sudo apt install net-tools</em>。当然官方提醒我们可以使用<code>sudo apt install net-tools</code>安装net-tools，然而并不如预想。</p>
<div style="width: 70%;margin: left"><img src="/2019/11/08/Ubuntu/ifconfig_error.png" class="" title="ifconfig命令不存在"></div>
<a id="more"></a>

<p>解决方案： 执行语句 <code>sudo apt-get update &amp;&amp; sudo apt-get install net-tools</code><br>再输入ifconfig就正常啦。(apt-get用于自动从互联网的软件仓库中搜索、安装、升级或卸载软件。我们需要定期执行<code>apt-get update</code>，让我们缓存包在系统中的软件列表源是最新的)</p>
<div style="width: 70%;margin: left"> <img src="/2019/11/08/Ubuntu/ifconfig_sess.png" class=""></div>

<p>如果在过程中提示 <em>E: Could not get lock /var/lib/apt/lists/lock - open (11: Resource temporarily unavailable)</em>， 不用担心，这是因为上一次安装时异常退出导致锁残留，可直接删除掉这个锁文件，使用命令<code>sudo rm /var/lib/apt/lists/lock</code>。</p>
<div style="width: 70%;margin: left"><img src="/2019/11/08/Ubuntu/ifconfig_lock.png" class=""></div>

<h1 id="编译安装PHP7-3-11"><a href="#编译安装PHP7-3-11" class="headerlink" title="编译安装PHP7.3.11"></a>编译安装PHP7.3.11</h1><ol>
<li>官网 <a href="http://php.net/downloads.php" target="_blank" rel="noopener">http://php.net/downloads.php</a> 下载安装包到本地或者使用wget <code>wget http://cn2.php.net/distributions/php-7.3.11.tar.gz</code></li>
<li>安装依赖包 libxml2-dev和 gcc<br>a. 如果遇到错误：<em>error:xml2-config not found.Please check your libxml2 installation.</em> ，说明依赖包libxml2不存在，需要安装使用命令<code>sudo apt-get update &amp;&amp; sudo apt-get install libxml2-dev -y</code>。<br> b. 如果安装libxml2过程又提示<em>Unable to fetch some archives, maybe run apt-get update or try with –fix-missing?</em>，可执行<code>apt-get install libxml2-dev -y --fix-missing</code>解决。多次尝试无效时，保证当前网络连接正常的基础上，执行<code>sudo apt-get clean</code>再进行后续操作。<br> c. 如果又报错<em>configure: error: no acceptable C compiler found in $PATH</em>，是因为你本地没有可执行编译的源文件，需要执行<code>sudo apt-get update &amp;&amp; sudo apt-get install gcc -y</code>解决。</li>
<li>执行预编译，使用<code>./configure --prefix=/usr/local/php</code>(这个后面最好加上<code>--with-config-file-path=/usr/local/php/conf</code>，代表指定php.ini路径，否则后面需要自己去设置) 代表我要装到/usr/local/php里，配置文件放到conf里  </li>
<li>安装，执行完成之后最后一定要执行<code>make</code>，这一步是真正的编译。然后还要执行<code>sudo make install</code>，这一步是拷贝到你的目标文件夹，否则/usr/local/php是不会有的。  </li>
<li>验证，没有Hello world感觉不完整是不是。写个简单的PHP页面<div style="width: 60%;margin: left"><img src="/2019/11/08/Ubuntu/php_ver.png" class=""></div>

</li>
</ol>
<h1 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h1><p>基于用户级的环境变量设置 在home目录下的隐藏文件 .bashrc，输入<code>export name=xugz</code>设置个名字，使用<code>source .bashrc</code>执行。比如说我现在安装了Nodejs，但是只能在node安装目录下进行操作，如何处理呢？可以通过修改环境变量实现。在.bashrc文件中追加<code>export PATH=$PATH:/home/xugz/tool/node-v12.13.0-linux-x64/bin</code>后保存退出，使用<code>source .bashrc</code>执行就可以在任何文件目录下执行node操作了。<br>全局环境变量在<code>/etc/profile</code>文件下</p>
<h1 id="Mysql8-0-18源码安装"><a href="#Mysql8-0-18源码安装" class="headerlink" title="Mysql8.0.18源码安装"></a>Mysql8.0.18源码安装</h1><ol>
<li><p>官网下载源码 源码包分为带boost版和不带boost版的，我这里直接下面自带boost版的。 社区版  Compressed TAR Archive, Includes Boost Headers。浏览器下载或者使用wget:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">wget https://dev.mysql.com/get/Downloads/MySQL-8.0/mysql-boost-8.0.18.tar.gz</span><br><span class="line">tar xzv -f mysql-boost-8.0.18.tar.gz</span><br><span class="line">cd mysql-8.0.18/</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>安装依赖编译工具<br><code>sudo apt install cmake build-essential bison libssl-dev pkg-config git gcc g++ libncurses5 libncurses5-dev -y</code><br><a href="https://dev.mysql.com/doc/refman/8.0/en/source-installation.html" target="_blank" rel="noopener">详细依赖列表参考点我</a></p>
</li>
<li><p>编译执行 <code>cmake . -DCMAKE_INSTALL_PREFIX=/usr/local/mysql -DSYSCONFDIR=/etc -DMYSQL_DATADIR=/usr/local/mysql/data -DWITH_BOOST=boost  -DFORCE_INSOURCE_BUILD=1</code> （<a href="https://dev.mysql.com/doc/refman/8.0/en/source-configuration-options.html" target="_blank" rel="noopener">cmake的完整选项列表点我</a>）。运行成功，会显示</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">-- Configuring done</span><br><span class="line">-- Generating done</span><br><span class="line">-- Build files have been written to: /home/xugz/Downloads/mysql-8.0.18</span><br></pre></td></tr></tbody></table></figure>
<p>如果没有报错，执行<code>make</code>编译，然后开始漫长的等待，等待……编译完成后执行 <code>make install</code> 安装</p>
</li>
<li><p>新建 /usr/local/mysql文件, 修改归属用户权限<code>chown xugz:xugz mysql</code></p>
</li>
<li><p>初始化配置<br>详细参考 <a href="https://dev.mysql.com/doc/refman/8.0/en/installing-source-distribution.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/8.0/en/installing-source-distribution.html</a><br>mysqld是最终需要运行的可执行程序，不过我们一般使用mysqld_safe这个脚本来执行。进入安装目录 <code>cd /usr/local/mysql</code>，进入bin目录我们执行<code>mysqld --verbose --help</code>生成所有mysqld选项和可配置变量的列表</p>
<div style="width: 60%;margin: left"><img src="/2019/11/08/Ubuntu/mysql_cnf.png" class="" title="mysql查找配置文件的顺序"></div>

<p>如上图所示，MySQL先去寻找/etc/mysql/my.cnf文件，如果没有再去寻找 /etc/my.cnf，还没有再去寻找~/.my.cnf。我们只需要三选一创建文件，这里我选择大众常用的 /etc/my.cnf。执行<code>sudo vi /etc/my.cnf</code>添加以下内容</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[client]</span><br><span class="line">port = 3306</span><br><span class="line">socket = /usr/local/mysql/data/mysql.sock</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">port  = 3306</span><br><span class="line">socket = /usr/local/mysql/data/mysql.sock</span><br><span class="line">basedir = /usr/local/mysql</span><br><span class="line">datadir = /usr/local/mysql/data</span><br></pre></td></tr></tbody></table></figure>
<p>检查安装目录是否存在data文件夹，这个文件夹用来存放数据库文件的，没有的话需要手动创建，并修改当前用户所有权限。<br>回到bin目录初始化数据库，使用命令<br><code>./mysqld --initialize --user=xugz --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data/</code><br>这一步会随机生成的root账号初始密码，记录备用 kacIL6Vxs*dX</p>
</li>
<li><p>启动&amp;连接<br>使用命令<code>/usr/local/mysql/bin/mysqld_safe</code> 启动，然后新开命令窗口执行<code>ps -ef | grep mysql</code> 验证<br>在/usr/local/mysql/bin目录下，使用<code>./mysql -u root -p</code>登陆，密码为刚才生成的随机字串。临时密码不可用，键入命令会提示修改。使用命令<code>alter user user() identified by 'qwe123';</code>退出后MySQL链接重进就可以正常操作了。</p>
</li>
<li><p>关闭数据库连接<br>使用命令 <code>./mysqladmin -u root -pqwe123 shutdown</code></p>
</li>
</ol>
<h1 id="Memcached安装"><a href="#Memcached安装" class="headerlink" title="Memcached安装"></a>Memcached安装</h1><ol>
<li><p>安装包下载 <a href="http://memcached.org/downloads" target="_blank" rel="noopener">官网地址</a> 或者使用wget。官网已经给我们详细说明</p>
<div style="width: 55%;margin: left"><img src="/2019/11/08/Ubuntu/memcache_install.png" class=""></div>
</li>
<li><p>安装依赖 <code>sudo apt-get install libevent-dev -y</code> 灵活点根据官网提示修改</p>
</li>
<li><p>配置安装<br>进入memcache下载目录使用命令 <code>./configure --prefix=/usr/local/memcached</code> 完成后执行<code>make</code>，之后执行<code>make install</code>。这时我们就可以在/usr/local/memcached中看到bin目录了</p>
</li>
<li><p>启动</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">/usr/local/memcached/bin/memcached -d -m 512 -u xugz -l 127.0.0.1 -p 11211 -c 1024 -P /usr/local/memcached/memcached.pid</span><br><span class="line"></span><br><span class="line"> 备注：</span><br><span class="line"> -d 以守护进程 </span><br><span class="line"> -m 代表分配的内存（单位M）</span><br><span class="line"> -l 连接的IP地址。默认只有本机可以连。多个IP用,连接</span><br><span class="line"> -c 最大并发连接数</span><br><span class="line"> -P pid文件</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>连接<br><code>telnet 127.0.0.1 11211</code>进入。使用<code>set keyName flags 过期时间（秒） bytes(值的长度)</code>换行，键入值。使用<code>get keyName</code>获取</p>
</li>
</ol>
<h1 id="Navicat安装"><a href="#Navicat安装" class="headerlink" title="Navicat安装"></a>Navicat安装</h1><p>下载安装包 <a href="https://www.navicat.com/en/download/direct-download?product=navicat_mysql_en_x64.tar.gz&amp;location=1" target="_blank" rel="noopener">官网地址</a>完成后解压。进入解压后的目录运行<code>./start_navicat</code>即可<br>破解方案：<br>执行start_navicat时，会在用户主目录下生成一个名为.navicat的隐藏文件夹。<br><code>cd /home/xugz/.navicat/</code><br>此文件夹下有一个system.reg文件。把此文件删除后，下次启动navicat 会重新生成此文件，规定试用期会按新的时间开始计算。</p>
<h1 id="编译安装PHP下面的memcahed拓展"><a href="#编译安装PHP下面的memcahed拓展" class="headerlink" title="编译安装PHP下面的memcahed拓展"></a>编译安装PHP下面的memcahed拓展</h1><ol>
<li>安装基本依赖 <code>sudo apt-get update &amp;&amp; sudo apt-get install autoconf igbinary msgpack zlib1g-dev -y</code></li>
<li>安装依赖包 libmemcached。进入<a href="https://launchpad.net/libmemcached/+download" target="_blank" rel="noopener">官网下载地址</a>下载完成后解压进入解压目录执行 <code>./configure &amp;&amp; make &amp;&amp; make install</code>和memcached </li>
<li>下载拓展包<br><code>git clone https://github.com/php-memcached-dev/php-memcached.git</code></li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Linux</category>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker学习笔记</title>
    <url>/2019/11/06/Docker%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="CentOS8安装Docker"><a href="#CentOS8安装Docker" class="headerlink" title="CentOS8安装Docker"></a>CentOS8安装Docker</h1><p><strong>卸载旧版本</strong><br>较旧的 Docker 版本称为 docker 或 docker-engine 。如果已安装这些程序，请卸载它们以及相关的依赖项</p>
<p><strong>安装步骤</strong></p>
<ol>
<li>下载docker-ce的repo<br><code>curl https://download.docker.com/linux/centos/docker-ce.repo -o /etc/yum.repos.d/docker-ce.repo</code></li>
<li>安装依赖（这是相比centos7的关键步骤）<br><code>yum install https://download.docker.com/linux/fedora/30/x86_64/stable/Packages/containerd.io-1.2.6-3.3.fc30.x86_64.rpm</code></li>
<li>安装docker-ce<br><code>yum install docker-ce</code></li>
<li>启动docker<br><code>systemctl start docker</code><br>启动成功，使用<code>systemctl status docker</code> 查看docker启动状态或者使用<code>docker version</code>验证是否安装成功。<a id="more"></a></li>
</ol>
<p><strong>普通用户运行docker命令不需要使用sudo</strong><br>在Linux系统中运行没有sudo密码的特定命令</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[xugz@xugz yum.repos.d]$ docker images</span><br><span class="line">Got permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get http://%2Fvar%2Frun%2Fdocker.sock/v1.40/images/json: dial unix /var/run/docker.sock: connect: permission denied</span><br><span class="line">[xugz@xugz yum.repos.d]$ sudo docker images</span><br><span class="line">[sudo] password for xugz:</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">[xugz@xugz yum.repos.d]$ id xugz</span><br><span class="line">uid=1000(xugz) gid=1000(xugz) groups=1000(xugz),0(root)</span><br><span class="line">[xugz@xugz yum.repos.d]$ sudo usermod -aG docker $(whoami)</span><br><span class="line">[xugz@xugz yum.repos.d]$ id xugz</span><br><span class="line">uid=1000(xugz) gid=1000(xugz) groups=1000(xugz),984(docker),0(root)</span><br></pre></td></tr></tbody></table></figure>
<p>注销并再次登录以使用没有sudo的Docker，可以使用docker version命令检查安装的Docker版本了。</p>
<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="docker-安装完成后测试hello-world出现问题（Unable-to-find-image-‘hello-world-latest’-locally）"><a href="#docker-安装完成后测试hello-world出现问题（Unable-to-find-image-‘hello-world-latest’-locally）" class="headerlink" title="docker 安装完成后测试hello-world出现问题（Unable to find image ‘hello-world:latest’ locally）"></a>docker 安装完成后测试hello-world出现问题（Unable to find image ‘hello-world:latest’ locally）</h2><p>安装docker之后，测试hello-world镜像，终端卡在<code>Unable to find image 'hello-world:latest' locally</code>位置<br>docker在本地没有找到hello-world镜像，也没有从docker仓库中拉取镜像，出项这个问题的原因：是因为docker服务器再国外，我们在国内无法正常拉取镜像，所以就需要我们设置国内的镜像加速器。（我这里用的是阿里云，当然其他的也可以，大家可以自己选择。Docker 官方和国内很多云服务商都提供了国内加速器服务，例如： Docker官方提供的中国镜像库：<a href="https://registry.docker-cn.com" target="_blank" rel="noopener">https://registry.docker-cn.com</a>）。使用 systemd 的系统的同学，需要新增配置文件<code>/etc/docker/daemon.json</code>，添加以下内容保存退出</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">{"registry-mirrors": ["https://alzgoonw.mirror.aliyuncs.com"]}</span><br></pre></td></tr></tbody></table></figure>
<p>之后重新启动服务</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></tbody></table></figure>
<p>重启之后，就可以正常拉取helloworld镜像了。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>不要重复使用PHP的number_format函数</title>
    <url>/2019/11/04/PHP-number_format%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>  和其他朋友聊起来，说是他们公司临近双十一做了一套秒杀系统，价值三千多的商品，被三块钱卖出去了。这种情况大概率是金额精度操作或者格式化有误之类的问题。果不其然，最后发现是重复使用number_format函数造成金额截取。这坑没有必要跳进去，现在写下来加深下记忆力，希望自己不会犯类似错误。<br>  <a id="more"></a><br>  number_format() 函数通过千位分组来格式化数字。<br>  Tips:该函数支持一个、两个或<strong>四个</strong>参数。</p>
<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><p> <em>number_format(number,decimals,decimalpoint,separator)</em></p>
<table>
<thead>
<tr>
<th align="center"><strong>参数</strong></th>
<th align="center"><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">number</td>
<td align="center">必需。要格式化的数字。如果未设置其他参数，则数字会被格式化为不带小数点且以逗号（,）作为千位分隔符。</td>
</tr>
<tr>
<td align="center">decimals</td>
<td align="center">可选。规定多少个小数。如果设置了该参数，则使用点号（.）作为小数点来格式化数字</td>
</tr>
<tr>
<td align="center">decimalpoint</td>
<td align="center">可选。规定用作小数点的字符串。</td>
</tr>
<tr>
<td align="center">separator</td>
<td align="center">可选。规定用作千位分隔符的字符串。仅使用该参数的第一个字符。比如 “xxx” 仅输出 “x”。<br><strong>注释</strong>：如果设置了该参数，那么所有其他参数都是必需的。</td>
</tr>
</tbody></table>
<p><strong>技术细节</strong></p>
<table>
<thead>
<tr>
<th align="center"><strong>参数</strong></th>
<th align="center"><strong>备注</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">返回值:</td>
<td align="center">返回已格式化的数字。</td>
</tr>
<tr>
<td align="center">PHP 版本：</td>
<td align="center">4+</td>
</tr>
<tr>
<td align="center">更新日志：</td>
<td align="center">自 PHP 5.4 起，该函数在参数 decimalpoint 和 separator 中支持多字节。<br>在更老的版本中，只使用每个分隔符的第一个字节。</td>
</tr>
</tbody></table>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$num = 4999.59;</span><br><span class="line">echo  number_format($num)."\n";</span><br><span class="line">// 这里结果正确，四舍五入取整，输出结果为：5,000</span><br><span class="line">$formattedNum = number_format($num, 2);</span><br><span class="line">echo $formattedNum."\n";</span><br><span class="line">// 这里结果正确，保留两位小数，输出结果为：4,999.59</span><br><span class="line">echo number_format($num,2,'.',',')."\n";</span><br><span class="line">// 这里结果正确，保留两位小数，输出结果为：4,999.59</span><br><span class="line">echo number_format($formattedNum)."\n";</span><br><span class="line">// 这里有报错提醒（PHP Notice:  A non well formed numeric value encountered in /usercode/file.php on），输出结果为：4</span><br><span class="line"></span><br><span class="line">// 假设以 $formattedNum 进行加减后再来一遍format就不会有报错，但是金额错的就更离谱了，假设运费六元 不考虑精度问题直接加减进行测试，如下</span><br><span class="line">$fee = 6; </span><br><span class="line">$totalAmount = $formattedNum + $fee;</span><br><span class="line">echo number_format($totalAmount)."\n";</span><br></pre></td></tr></tbody></table></figure>

<p>从上面的栗子可以明显看出来，重复使用number_format会导致数字异常，需要留意。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title>SSH秘钥操作</title>
    <url>/2019/10/31/SSH%E7%A7%98%E9%92%A5%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>SSH 为 Secure Shell 的缩写，由 IETF 的网络小组（Network Working Group）所制定；SSH 为建立在应用层基础上的安全协议。SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH最初是UNIX系统上的一个程序，后来又迅速扩展到其他操作平台。SSH在正确使用时可弥补网络中的漏洞。SSH客户端适用于多种平台。几乎所有UNIX平台—包括HP-UX、Linux、AIX、Solaris、Digital UNIX、Irix，以及其他平台，都可运行SSH。</p>
<a id="more"></a>
<h1 id="验证方式"><a href="#验证方式" class="headerlink" title="验证方式"></a>验证方式</h1><p>从客户端来看，SSH提供两种级别的安全验证。  </p>
<h2 id="第一种级别"><a href="#第一种级别" class="headerlink" title="第一种级别"></a>第一种级别</h2><p>基于口令的安全验证<br>只要你知道自己帐号和口令，就可以登录到远程主机。所有传输的数据都会被加密，但是不能保证你正在连接的服务器就是你想连接的服务器。可能会有别的服务器在冒充真正的服务器，也就是受到“中间人”这种方式的攻击。</p>
<img src="/2019/10/31/SSH%E7%A7%98%E9%92%A5%E6%93%8D%E4%BD%9C/passwd.png" class="" title="基于口令的安全验证图解">

<h2 id="第二种级别"><a href="#第二种级别" class="headerlink" title="第二种级别"></a>第二种级别</h2><p>基于密钥的安全验证<br>依靠密钥，为本地创建，公钥要放到需要访问的服务器上。使用SSH连接到服务器，客户端向服务器发出请求，请求用你的密钥进行安全验证。服务器收到请求后在你的目录下寻找属于你的公共密钥，找到后和你发过来的进行比较。如果密钥一致，服务器用你的公钥加密随机字符串给到客户端。客户端使用私钥解密得到随机字符串后MD5加密给到服务端，服务端拿随机字符串进行同样操作后验证两个字符是否一致的过程。</p>
<img src="/2019/10/31/SSH%E7%A7%98%E9%92%A5%E6%93%8D%E4%BD%9C/rsa.png" class="" title="基于密钥的安全验证图解">
<h3 id="SSH密钥操作"><a href="#SSH密钥操作" class="headerlink" title="SSH密钥操作"></a>SSH密钥操作</h3><ol>
<li><p>客户端生成密钥对<br><code>ssh-keygen -t rsa</code><br>Tips:一路回车就好~</p>
</li>
<li><p>客户端进入.SSH目录<br><code>cd C:\Users\Administrator\.ssh</code></p>
</li>
<li><p>客户端把公钥拷贝到linux下/root/.ssh目录下<br><code>scp id_rsa.pub root@192.168.2.1:/root/.ssh</code><br>Tips: 保证目标服务器存在/root/.ssh目录哦</p>
</li>
<li><p>目标服务器中把公钥改名<br><code>mv id_rsa.pub authorized_keys</code></p>
</li>
<li><p>客户端无口令测试-命令操作<br><code>ssh root@192.168.2.1</code></p>
</li>
<li><p>客户端无口令测试-文件传输<br><code>scp index.php root@192.168.2.1:/root/</code>  </p>
</li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>SSH</category>
      </categories>
      <tags>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title>linux中rc.local设置开机自启没有生效</title>
    <url>/2019/10/29/Linux-rc.local%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E6%9C%AA%E7%94%9F%E6%95%88/</url>
    <content><![CDATA[<p>在<code>/etc/rc.d/rc.local</code>中追加了执行命令但重启未生效，在网上找到解决方案：</p>
<ol>
<li>查看指定文件相关数据<br>使用<code>ll /etc/rc.d/rc.local</code><br>在第一个栏位文件的属性。Linux的文件基本上分为三个属性：可读（r），可写（w），可执行（x）。发现/etc/rc.d/rc.local没有可执行权限</li>
<li>使用chmod命令修改<br>在<code>/etc/rc.d/rc.local</code>有这样一段话<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"># Please note that you must run 'chmod +x /etc/rc.d/rc.local' to ensure</span><br><span class="line"># that this script will be executed during boot.</span><br></pre></td></tr></tbody></table></figure>
执行<code>chome +x  /etc/rc.d/rc.local</code>命令后，重启发现命令可以执行了。但前提要保证执行命令正确可执行才行。</li>
</ol>
<a id="more"></a>

<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>rsync+sersync实现数据实时同步</title>
    <url>/2019/10/29/rsync+sersync/</url>
    <content><![CDATA[<p>sersync是基于inotify+rsync的大量文件的多服务器自动同步程序<br>使用 Linux 2.6 内核的 inotify 监控 Linux 文件系统事件，被监听目录下如果有文件发生修改，sersync 将通过内核自动捕获到事件，并将该文件利用 rsync 同步到多台远程服务器。sersync 仅仅同步发生增、删、改事件的单个文件或目录，不像rsync镜像同步那样需要比对双方服务器整个目录下数千万的文件，并且支持多线程同步，因此效率非常高</p>
<p>rsync 采用c/s模式，监听端口为 873</p>
<a id="more"></a>
<h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><p><strong>下载sersync</strong>  </p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">谷歌项目地址：(https://code.google.com/archive/p/sersync/)  </span><br><span class="line">64位下载地址：(https://storage.googleapis.com/google-code-archive-downloads/v2/code.google.com/sersync/sersync2.5.4_64bit_binary_stable_final.tar.gz)  </span><br><span class="line">32位下载地址：(https://storage.googleapis.com/google-code-archive-downloads/v2/code.google.com/sersync/sersync2.5_32bit_binary_stable_final.tar.gz)</span><br></pre></td></tr></tbody></table></figure>
<p>上不去google的可以使用百度网盘我的备份包，这里只提供64位版本的：<br>链接：<a href="https://pan.baidu.com/s/1j3H7KBv4y3_DzOWb-rwpMQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1j3H7KBv4y3_DzOWb-rwpMQ</a><br>提取码：<code>0g8a</code> </p>
<p>注： 压缩包里面有两个文件confxml.xml和sersync2。前者是sersync配置文件，后者是sersync主程序。</p>
<p><strong>确认当前系统关闭selinux及防火墙，或将873端口加入iptables白名单</strong><br>注意： 该步骤需要在备份源服务器和目标服务器上都要操作</p>
<ol>
<li>关闭SELINUX  <figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[root@rsync ~]# vim /etc/selinux/config #编辑防火墙配置文件</span><br><span class="line">#SELINUX=enforcing #注释掉</span><br><span class="line">#SELINUXTYPE=targeted #注释掉</span><br><span class="line">SELINUX=disabled #增加</span><br><span class="line">:wq! #保存，退出</span><br><span class="line">[root@rsync ~]# setenforce 0 #立即生效</span><br></pre></td></tr></tbody></table></figure></li>
<li>开启防火墙tcp 873端口  <figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[root@rsync ~]# vim /etc/sysconfig/iptables #编辑防火墙配置文件</span><br><span class="line">-A RH-Firewall-1-INPUT -m state --state NEW -m tcp -p tcp --dport 873 -j ACCEPT</span><br><span class="line">:wq! #保存退出</span><br><span class="line">[root@rsync ~]# /etc/init.d/iptables restart #最后重启防火墙使配置生效</span><br></pre></td></tr></tbody></table></figure></li>
<li>开放873端口 比如阿里云服务器 要到后台设置哦</li>
</ol>
<h1 id="需求说明"><a href="#需求说明" class="headerlink" title="需求说明"></a>需求说明</h1><p>我这里有两台centos8的主机，IP分别是192.168.2.98和192.168.2.248。<br>我在192.168.2.98安装sersync，主动推送数据到192.168.2.248上。<br>也就是说 192.168.2.98作为数据备份源，192.168.2.248作为目标机器。</p>
<h1 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h1><h2 id="目标机器配置"><a href="#目标机器配置" class="headerlink" title="目标机器配置"></a>目标机器配置</h2><ol>
<li><p>安装rsync<br><code>yum install rsync</code> </p>
</li>
<li><p>创建rsync配置文件<br><code>vi /etc/rsyncd.conf</code></p>
<p> 增加以下内容</p>
 <figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">uid = root #这里是系统用户 需要有备份目标文件夹操作权限 这个注释后续需要删除</span><br><span class="line">gid = root</span><br><span class="line">use chroot = yes</span><br><span class="line">hosts allow=*</span><br><span class="line">max connections = 5</span><br><span class="line">port = 873</span><br><span class="line">timeout = 900</span><br><span class="line">pid file = /var/run/rsyncd.pid</span><br><span class="line">lock file = /var/run/rsync.lock</span><br><span class="line">log file = /var/log/rsyncd.log</span><br><span class="line">motd file = /etc/rsyncd.motd</span><br><span class="line">[backup]</span><br><span class="line">path = /var/www/backup</span><br><span class="line">comment = Hi</span><br><span class="line">read only = false</span><br><span class="line">list =yes</span><br><span class="line">auth users = rsyncuser</span><br><span class="line">secrets file =/etc/rsync.passwd</span><br></pre></td></tr></tbody></table></figure>
<p> 编辑完成保存退出<br> 具体配置注释见下图</p>
 
</li>
<li><p>在secrets file指定的用户密码文件<br>vim /etc/rsync.passwd　　内容格式：用户名：密码,可以设置多个，每行一个用户名:密码<br>执行<code>echo "rsyncuser:password" &gt;&gt; /etc/rsync.passwd</code><br>把内容追加到rsync.passwd末尾<br>然后，更改文件的读写权限为600<br><code>chmod 600 /etc/rsync.passwd</code></p>
</li>
<li><p>启动rsync<br>配置完成可使用<code>netstat -antup |grep 873</code> 查看是否有端口873在运行没有的话启动<br><code>/usr/bin/rsync --daemon</code> # 以守护进程方式<br><code>/usr/bin/rsync --daemon --config=/etc/rsyncd.conf</code>  # 加载配置文件rsyncd.conf启动rsync服务</p>
</li>
</ol>
<p>注： 可使用 kill -9 <pid> 杀掉进程.(进程ID 可以通过 ps aux | grep rsync 方法得到)</pid></p>
<ol start="5">
<li><p>配置rsync开机自启动<br>直接追加 <code>echo "/usr/bin/rsync --daemon --config=/etc/rsyncd.conf" &gt;&gt; /etc/rc.d/rc.local</code></p>
</li>
<li><p>实时监控<br>进入你要备份的目标路径 键入<code>watch ls -l</code>可实现实时监控。</p>
</li>
</ol>
<h2 id="数据备份源机器配置"><a href="#数据备份源机器配置" class="headerlink" title="数据备份源机器配置"></a>数据备份源机器配置</h2><ol>
<li><p>安装rsync </p>
 <figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[root@rsync ~]# whereis rsync   #查看系统是否已安装rsync,出现下面的提示，说明已经安装</span><br><span class="line">rsync: /usr/bin/rsync /usr/share/man/man1/rsync.1.gz</span><br><span class="line">yum install rsync #如果默认没有rsync，运行此命令进行安装rsync</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>下载sersync到本地解压</p>
 <figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"># 我这里将sersync放在了/usr/local/sersync/目录下</span><br><span class="line"> cd /usr/local/</span><br><span class="line"> wget https://storage.googleapis.com/google-code-archive-downloads/v2/code.google.com/sersync/sersync2.5.4_64bit_binary_stable_final.tar.gz</span><br><span class="line"> tar xzf sersync2.5.4_64bit_binary_stable_final.tar.gz</span><br><span class="line"> rm -rf sersync2.5.4_64bit_binary_stable_final.tar.gz</span><br><span class="line"> mv GNU-Linux-x86/ sersync</span><br><span class="line"> cd sersync</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>创建认证密码文件<br>密码需和目标服务器配置的一致，且不需要用户名．将该文件的权限也更改为600<br><code>echo "password" &gt;&gt; /etc/rsync.passwd</code><br><code>chmod 600 /etc/rsync.passwd</code></p>
</li>
<li><p>修改confxml.xml文件</p>
 <figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">......</span><br><span class="line">&lt;sersync&gt;</span><br><span class="line">24 &lt;localpath watch="监控目录路径"&gt;</span><br><span class="line">25 &lt;remote ip="rsync目标服务端IP地址" name="模块名"/&gt;</span><br><span class="line">......</span><br><span class="line">&lt;rsync&gt;</span><br><span class="line">30 &lt;commonParams params="-az"/&gt;</span><br><span class="line">31 &lt;auth start="true" users="rsync客户端用户名" passwordfile="rsync客户端密码文件"/&gt;</span><br><span class="line">......</span><br><span class="line">36 &lt;failLog path="指定Sersync日志文件路径" timeToExecute="60"/&gt;......</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>修改权限 <code>chmod +x sersync2</code></p>
</li>
<li><p>读取指定路径配置文件启动sersync <code>/usr/local/serync/serync2 -d -r -o /usr/local/sersync/confxml.xml</code><br>耐心等待执行完成后进行后续操作。</p>
<p> -n 启用线程数量<br> -d daemon方式启动<br> -o 指定配置文件<br> sersync整体同步一次 在sersync目录下运行 <code>./sersync2 -r</code><br> 开启实时同步命令 <code>./sersync2 -d</code>。 一般先运行完整体同步后，再进行该命令操作</p>
</li>
<li><p>设置开机启动<br><code>echo "/usr/local/sersync/sersync2 -r -d -o /usr/local/sersync/confxml.xml" &gt;&gt; /etc/rc.d/rc.local</code><br>执行完成可以测试。</p>
</li>
<li><p>添加脚本监控sersync是否正常运行</p>
<ol>
<li><p>编辑脚本<code>vi /usr/local/check_sersync.sh</code>，添加以下代码</p>
<pre><code>#!/bin/bash
sersync="/usr/local/serync/serync2"
confxml="/usr/local/sersync/confxml.xml"
status=$(ps aux |grep 'sersync2'|grep -v 'grep' |wc -l)
if [ $status -eq 0 ];
then
$sersync -d -r -o $confxml &amp;
else 
exit 0;
fi</code></pre></li>
<li><p>测试脚本<br><code>sh /usr/local/check_sersync.sh</code></p>
</li>
<li><p>赋予脚本执行权限<br><code>chmod +x /usr/local/check_sersync.sh</code></p>
</li>
<li><p>定义计划任务实现定时备份<br>echo ‘*/5 * * * * sh /usr/local/check_sersync.sh &amp;’ &gt;&gt; /var/spool/cron/root</p>
</li>
</ol>
</li>
</ol>
<h1 id="rsync参数说明"><a href="#rsync参数说明" class="headerlink" title="rsync参数说明"></a>rsync参数说明</h1><div style="width:80%;margin:left"></div>

<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p> <a href="https://blog.whsir.com/post-1097.html" target="_blank" rel="noopener">https://blog.whsir.com/post-1097.html</a><br><a href="https://blog.csdn.net/chrisjingu/article/details/78317907" target="_blank" rel="noopener">https://blog.csdn.net/chrisjingu/article/details/78317907</a><br><a href="https://www.jianshu.com/p/31a67de3f669" target="_blank" rel="noopener">https://www.jianshu.com/p/31a67de3f669</a></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Linux</category>
        <category>rsync</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>rsync</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟机ping不通主机，但是主机可以ping通虚拟机</title>
    <url>/2019/10/28/ping_error/</url>
    <content><![CDATA[<p>在Windows10系统安装了虚拟机，设置的主机与虚拟机的连接方式是桥接，安装好后，发现虚拟机ping不通主机，但是主机可以ping通虚拟机。<br>上网查看资料，发现是因为Windows10防火墙阻止，防火墙没有打开ICMPv4-in这个规则。<br>那怎么打开呢？<br> <a id="more"></a></p>
<h1 id="修改防火墙规则"><a href="#修改防火墙规则" class="headerlink" title="修改防火墙规则"></a>修改防火墙规则</h1><p>设置 &gt; 网络和Internet &gt; Windows防火墙 &gt; 高级设置 &gt; 入站规则中找到配置文件类型为“公用”的“文件和打印共享（回显请求 – ICMPv4-In）”规则，设置为启用规则。<br>这样虚拟机就可以ping通主机了。  </p>
<h1 id="更改适配器选项"><a href="#更改适配器选项" class="headerlink" title="更改适配器选项"></a>更改适配器选项</h1><p>如果确保安装无误且防火墙已关闭却还没解决问题,可能是这个原因，我们一般都是自动获取ip地址和网关，设置为手动就可以了。<br>步骤如下：<br>打开cmd查看你的IP地址，ipconfig，记住IP地址和默认网关。</p>
<p>设置  &gt; 网络和Internet &gt; 更改适配器选项 &gt; 选择主机连接的网络右键属性 &gt; Internet 协议4（TCP/IPv4）属性 中选择使用下面的DNS服务器地址进行自定义，填入IP地址 默认网关和子网掩码再试。</p>
<p>防火墙是虚拟机ping不通本机ip的主要原因，但是如果开启了入站规则没管用那就是其他问题了，我的把自动获取改为手动就好了，之前设置的入站规则也管用了，现在防火墙也都开着。</p>
<p>本文参考文章： <a href="https://blog.csdn.net/hskw444273663/article/details/81301470" target="_blank" rel="noopener">链接</a></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>VMware</tag>
      </tags>
  </entry>
  <entry>
    <title>实现Hexo博客多地更新和配置博客源文件</title>
    <url>/2019/10/25/Hexo-deploy/</url>
    <content><![CDATA[<p>使用Hexo部署上传GitHub后我们发现，博客源文件没有上传，处于安全考虑在<code>.gitinore</code>文件中配置忽略了。仅仅将public文件夹内的文件通过<code>hexo d</code>上传到GitHub去了，其他的文件则留在本地目录下。<br>为解决多台电脑需要更新博客和博客部署文件隔离的问题，这里将使用github存放网站静态文件，coding私有仓库存放博客源文件来处理。</p>
<a id="more"></a>

<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>确保已经使用hexo在GitHub搭建好了自己的个人博客，步骤参见 <a href="https://xlline.github.io/2019/06/19/Hexo+GitHub/">使用Hexo+GitHub搭建个人博客教程</a></p>
<h1 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h1><ol>
<li>注册/登录Coding，<a href="https://coding.net/" target="_blank" rel="noopener">点此进入</a></li>
<li>新建项目 新建代码仓库</li>
<li>配置SSH公钥 路径：头像 &gt; 个人账户设置 &gt; SSH公钥 &gt; 新增公钥 <!-- 本地公钥路径 C:\Users\Administrator\.ssh\id_rsa.pub --></li>
<li>新建代码仓库 git clone到本地</li>
<li>将本地博客代码copy过来 修改<code>.gitinore</code>文件如下<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">.DS_Store</span><br><span class="line">Thumbs.db</span><br><span class="line">db.json</span><br><span class="line">*.log</span><br><span class="line">node_modules/</span><br><span class="line">public/</span><br><span class="line">.deploy*/</span><br></pre></td></tr></tbody></table></figure></li>
<li>将themes目录以内中的主题的.git目录删除（如果有），因为一个git仓库中不能包含另一个git仓库，提交主题文件夹会失败。<!-- 删除了themes目录中的.git不就不能git pull更新主题了吗，很简单，需要更新主题时在另一个地方git clone下来该主题的最新版本，然后将内容拷到当前主题目录即可。 --></li>
<li>使用git提交变动到Coding仓库。<br>完成后就可以在当前目录进行正常博客更新与维护了。此时我们的静态文件会在执行<code>hexo d</code>时被上传到GitHub，不要忘记使用git命令上传到coding对应仓库。</li>
</ol>
<h1 id="当存在新电脑"><a href="#当存在新电脑" class="headerlink" title="当存在新电脑"></a>当存在新电脑</h1><ol>
<li>将新电脑生成的SSH KEY分别添加到GitHub和Coding中</li>
<li>在新电脑上将Coding中存放Hexo源码的仓库clone到本地</li>
<li>执行<code>npm install</code></li>
<li>可以进行博客文章的编辑和新增了。完成后使用git提交源文件变动到Coding，使用<code>hexo g &amp;&amp; hexo d</code>更新静态文件到GitHub。</li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客添加图片不显示问题</title>
    <url>/2019/10/25/Hexo-addpic/</url>
    <content><![CDATA[<p>本想在自己文章中加入图片进行详细说明，奈何这图片偏要与我玩躲猫猫死活不出来，在网上看了几篇博客之后才得以解决，浪费了一些不必要的时间。所以在这里记录一下，希望以后遇到这问题可以快速解决。 <span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f6b4.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f6b4.png?v8">🚴</span></p>
<a id="more"></a>
<ol>
<li><p>安装插件<br>在博客文件所在位置，右键-&gt;打开git bash后键入</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">npm install hexo-asset-image --save</span><br></pre></td></tr></tbody></table></figure>
<p>安装完成后，使用命令<code>hexo new 'test'</code>新建文章时，会在test.md同目录(_post)下生成同名文件夹，该文件夹可用于存放对应文章的图片等相关信息<br>当然，你也可以手动创建与新建文章同名的文件夹。</p>
</li>
<li><p>修改配置文件<br>把站点配置文件_config.yml的 <code>post_asset_folder</code>设置为 <code>true</code><br>在blog（hexo）目录下执行 <code>npm install hexo-asset-image --save</code></p>
</li>
<li><p>引入图片格式<br>使用markdown的格式引入图片：<code>![你想要输入的替代文字](存放图片的文件夹名称/图片名.jpg)</code></p>
</li>
</ol>
<p>提示：通过常规的 markdown 语法和相对路径来引用图片和其它资源可能会导致它们在存档页或者主页上显示不正确。如果你也恰好遇到该问题，可以使用下方标签解决：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">{% asset_img example.jpg This is an example image %}</span><br></pre></td></tr></tbody></table></figure>

<ol start="4">
<li><p>执行<code>hexo g -d</code> 生成页面并部署后查看图片是否正常显示</p>
</li>
<li><p>如果以上步骤都确认执行完成但图片还是很有个性，千呼万唤不出来。那么到<code>/node_modules/hexo-asset-image/index.js</code>文件更换为如下内容：</p>
</li>
</ol>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">'use strict';</span><br><span class="line">var cheerio = require('cheerio');</span><br><span class="line"></span><br><span class="line">// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string</span><br><span class="line">function getPosition(str, m, i) {</span><br><span class="line">  return str.split(m, i).join(m).length;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">var version = String(hexo.version).split('.');</span><br><span class="line">hexo.extend.filter.register('after_post_render', function(data){</span><br><span class="line">  var config = hexo.config;</span><br><span class="line">  if(config.post_asset_folder){</span><br><span class="line">    	var link = data.permalink;</span><br><span class="line">	if(version.length &gt; 0 &amp;&amp; Number(version[0]) == 3)</span><br><span class="line">	   var beginPos = getPosition(link, '/', 1) + 1;</span><br><span class="line">	else</span><br><span class="line">	   var beginPos = getPosition(link, '/', 3) + 1;</span><br><span class="line">	// In hexo 3.1.1, the permalink of "about" page is like ".../about/index.html".</span><br><span class="line">	var endPos = link.lastIndexOf('/') + 1;</span><br><span class="line">    link = link.substring(beginPos, endPos);</span><br><span class="line">    var toprocess = ['excerpt', 'more', 'content'];</span><br><span class="line">    for(var i = 0; i &lt; toprocess.length; i++){</span><br><span class="line">      var key = toprocess[i];</span><br><span class="line"> </span><br><span class="line">      var $ = cheerio.load(data[key], {</span><br><span class="line">        ignoreWhitespace: false,</span><br><span class="line">        xmlMode: false,</span><br><span class="line">        lowerCaseTags: false,</span><br><span class="line">        decodeEntities: false</span><br><span class="line">      });</span><br><span class="line"></span><br><span class="line">      $('img').each(function(){</span><br><span class="line">		if ($(this).attr('src')){</span><br><span class="line">			// For windows style path, we replace '\' to '/'.</span><br><span class="line">			var src = $(this).attr('src').replace('\\', '/');</span><br><span class="line">			if(!/http[s]*.*|\/\/.*/.test(src) &amp;&amp;</span><br><span class="line">			   !/^\s*\//.test(src)) {</span><br><span class="line">			  // For "about" page, the first part of "src" can't be removed.</span><br><span class="line">			  // In addition, to support multi-level local directory.</span><br><span class="line">			  var linkArray = link.split('/').filter(function(elem){</span><br><span class="line">				return elem != '';</span><br><span class="line">			  });</span><br><span class="line">			  var srcArray = src.split('/').filter(function(elem){</span><br><span class="line">				return elem != '' &amp;&amp; elem != '.';</span><br><span class="line">			  });</span><br><span class="line">			  if(srcArray.length &gt; 1)</span><br><span class="line">				srcArray.shift();</span><br><span class="line">			  src = srcArray.join('/');</span><br><span class="line">			  $(this).attr('src', config.root + link + src);</span><br><span class="line">			  console.info&amp;&amp;console.info("update link as:--&gt;"+config.root + link + src);</span><br><span class="line">			}</span><br><span class="line">		}else{</span><br><span class="line">			console.info&amp;&amp;console.info("no src attr, skipped...");</span><br><span class="line">			console.info&amp;&amp;console.info($(this));</span><br><span class="line">		}</span><br><span class="line">      });</span><br><span class="line">      data[key] = $.html();</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>





<p>自测以上方法可以解决我的问题，希望对你有帮助。  </p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Git bash Error:Could not fork child process:There are no available terminals (-1)</title>
    <url>/2019/10/25/Gitbash_error/</url>
    <content><![CDATA[<p>使用Git bash未正常退出后，再次打开出现 <code>Git bash Error: Could not fork child process: There are no available terminals (-1)</code>报错。<br>可以使用 tasklist命令 找到git-bash.exe和node.exe对应进程号后，使用taskkill结束进程即可。</p>
<a id="more"></a>
<ol>
<li><p>win+r调出运行键入<code>cmd</code>后回车打开，使用<code>tasklist</code>查看本机进程。查询得到的字段有： 映像名称，PID(进程ID)，会话名，会话#，内存使用。如下图：</p>
<img src="/2019/10/25/Gitbash_error/tasklist_ret.jpg" class="" title="tasklist运行结果">
<p>如图 smss.exe 的进程ID为 520(你看随便找个进程都是爱你的数字)，咳咳</p>
</li>
<li><p>找到git-bash.exe对应的进程号，比如我的是 12184，然后使用命令 <code>taskkill /pid 12184 -t -f</code> 终止ID为12184的进程。</p>
<img src="/2019/10/25/Gitbash_error/taskkill_ret.png" class="" title="taskkill命令运行结果"></li>
<li><p>找到node.exe对应的进程号，比如我的是 868，然后使用命令 <code>taskkill /pid 868 -t -f</code> 终止ID为868的进程。</p>
</li>
</ol>
<p>终止后，即可打开git bash终端再次尝试。自测可以解决问题，希望对你有帮助。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>taskkill</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux基础</title>
    <url>/2019/10/23/Linux-base/</url>
    <content><![CDATA[<p>最近在云之梦网站学习Linux基础，发现有好多基础命令见面不相识……此篇作为学习笔记，利用零碎的时间终于完成课程学习，该篇添加常用命令以方便后续翻阅参考。</p>
<a id="more"></a>
<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="操作系统分类"><a href="#操作系统分类" class="headerlink" title="操作系统分类"></a>操作系统分类</h2><ol>
<li>客户端操作系统<br> windows 7,8,10等</li>
<li>服务器端操作系统<ol>
<li>windows server 2019</li>
<li>linux操作系统<ol>
<li>centos</li>
<li>redhat enterprise linux rhel</li>
<li>ubuntu</li>
<li>debian</li>
<li>suse</li>
<li>opensuse</li>
<li>freebsd</li>
<li>aliyun linux</li>
<li>coreos</li>
</ol>
</li>
<li>unix操作系统<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2>Linux查看版本当前操作系统内核信息<br><code>uname -a</code><br>Linux查看当前操作系统版本信息<br><code>cat /proc/version</code><br>Linux查看版本当前操作系统发行版信息<br><code>cat /etc/redhat-release</code><br>查看centOS版本<br><code>cat /etc/centos-release</code><br>查看内存 <code>free</code> or <code>free -m</code> or <code>free -g</code><br>查看硬盘 <code>df</code> or <code>df -T</code> or <code>df -h</code><br>查看系统正在登录的用户 <code>who</code><br>查看系统最后一重要操作 <code>last</code><br>查看进程实时消耗的cpu和内存 <code>top</code><br>查看系统1分钟、5分钟和15分钟平均负载 <code>uptime</code><br>查看服务进程 <code>ps -ef</code> or <code>pstree</code> == <code>!ps</code><br>查看服务端口 <code>netstat -tunpl</code><br>杀掉进程 <code>kill -9 pid</code> or <code>pkill pname</code></li>
</ol>
</li>
</ol>
<h1 id="系统启动流程"><a href="#系统启动流程" class="headerlink" title="系统启动流程"></a>系统启动流程</h1><ol>
<li>BIOS加电自检</li>
<li>把MBR加载到内存</li>
<li>加载grub</li>
<li>Kernel自身初始化</li>
<li>启动第一个程序systemd</li>
<li>检查默认运行级别<h2 id="Linux运行级别"><a href="#Linux运行级别" class="headerlink" title="Linux运行级别"></a>Linux运行级别</h2><pre><code>0 shutdown.target(关机)  
1 emergency.target(紧急救援模式)   
2 rescue.target(救援模式)  
3 multi-user.target(多用户模式|字符系统模式)  
4 无  
5 graphical.target(桌面系统)  
6 无(重启) </code></pre><h2 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h2> 查看运行级别  <code>runlevel</code><h3 id="init命令"><a href="#init命令" class="headerlink" title="init命令"></a>init命令</h3><pre><code>`init 0` // 关机   
`init 3` // 到达字符界面  
`init 5` // 到达图形界面  
`init 6` // 重启  </code></pre><h3 id="systemd服务管理"><a href="#systemd服务管理" class="headerlink" title="systemd服务管理"></a>systemd服务管理</h3> 利用systemctl 进行服务控制。    <pre><code>1. 查看默认级别    
`systemctl get-default`  
 Tips: 或者使用`cd /etc/systemd/system`后`ll`查看`default.target`字段  
2. 设置默认级别  
  `systemctl set-default multi-user.target`
3. 查看指定服务状态
`systemctl status sshd.service`
4. 启动服务指定服务
`systemctl start sshd.service`
5. 重启服务指定服务
`systemctl restart sshd.service`
6. 关闭服务指定服务
`systemctl stop sshd.service`
7. 重载服务指定服务
`systemctl reload sshd.service`
8. 开机启动指定服务
`systemctl enable sshd.service`
9. 开机关闭指定服务
`systemctl disable sshd.serivce`
9. 查看指定服务是否开机启动
`systemctl is-enabled sshd.service`
10. 查看指定服务是否启动
`systemctl is-active sshd.serivce`
11. 临时切换选择分配运行级别
 `systemctl isolate multi-user.target` # 临时切换选择分配运行级别至字符系统模式
`systemctl isolate graphical.target`   # 临时切换选择分配运行级别至桌面系统模式
12. 列出所有target
`systemctl list-units --type=target --all`
13. 查看系统中所有服务的启动状态
`systemctl list-unit-files`</code></pre></li>
<li>启动相应级别下的所有程序服务</li>
<li>加载/etc/rc.d/rc.local脚本<br>直接在/etc/rc.d/rc.local文件中追加即可，例如 <code>systemctl start sshd.service</code><br>Tips：在CentOS8版本改文件需要手动增加执行权限，使用命令<code>chmod +x /etc/rc.d/rc.local</code>  </li>
<li>systemd执行multi-user.target下的getty.target及登录服务</li>
<li>systemd执行graphical需要的服务</li>
</ol>
<h1 id="Root用户破解流程"><a href="#Root用户破解流程" class="headerlink" title="Root用户破解流程"></a>Root用户破解流程</h1><ol>
<li>开机后页面 按e进入LINUX内核编辑模式</li>
<li>在quiet后加入 rd.break</li>
<li>按ctrl+x进入swtch_root模式</li>
<li>使用命令 <code>mount -o remount,rw /sysroot</code> 重新挂载根分区</li>
<li>使用命令 <code>chroot /sysroot</code> 切换根分区</li>
<li>使用命令 <code>passwd root</code> 修改root的密码，必须是8位以上复杂密码 当前设置的是 xUGZ1030</li>
<li>使用命令 <code>touch /.autorelabel</code> 让selinux在重启后更新label 不执行该句新设置密码不会保存 等到进度条加载完成后可退出 验证新密码是否有效</li>
<li>使用命令 <code>exit</code> 退出</li>
<li>使用命令 <code>reboot</code> 重启系统</li>
<li>最后用root和新密码登录即可</li>
</ol>
<h1 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h1><p>Selinux防火墙: 文件级防火墙</p>
<ol>
<li>使用命令 <code>sestatus</code> 查看selinux防火墙状态</li>
<li>关闭防火墙<br>使用命令 <code>vi /etc/selinux/config</code> 进入selinux配置文件 将SELINUX状态改成关闭  使用命令 <code>SELINUX=disabled</code></li>
<li>使用命令 <code>init 6</code> 重启</li>
</ol>
<p>firewalld防火墙: 网络级防火墙</p>
<ol>
<li>使用命令 <code>systemctl status firewalld</code> 查看 firewalld防火墙状态</li>
<li>使用命令 <code>systemctl stop firewalld</code> 关闭 该命令只能暂时关闭 开机关闭需要另设</li>
<li>使用命令  <code>systemctl disable firewalld</code> 设置开机关闭</li>
</ol>
<p>iptables防火墙: 网络级防火墙 常用</p>
<ol>
<li>使用命令 <code>iptables -L -n</code> 查看规则</li>
<li>使用命令 <code>iptables -F</code> 清空规则</li>
<li>使用命令 <code>service iptables save</code> 保存规则 （如果不能保存 查询是否已安装iptables-service包）</li>
</ol>
<h1 id="主机名管理"><a href="#主机名管理" class="headerlink" title="主机名管理"></a>主机名管理</h1><ol>
<li>查看主机名(localhost)<br><code>hostname</code></li>
<li>查看主机名与系统详情<br><code>hostnamectl status</code></li>
<li>临时修改<br><code>hostname yzmedu</code></li>
<li>永久修改<br> 1) 直接修改文件<br> vi /etc/hostname<br> 2) hostnamectl方法<br> <code>hostnamectl set-hostname</code><br> 3) 重启生效<br> <code>init 6</code></li>
</ol>
<h1 id="网络管理"><a href="#网络管理" class="headerlink" title="网络管理"></a>网络管理</h1><h2 id="直接修改文件"><a href="#直接修改文件" class="headerlink" title="直接修改文件"></a>直接修改文件</h2><p><code>vi /etc/sysconfig/network-scripts/ifcfg-ens32</code>  </p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">BOOTPROTO=dhcp | static</span><br><span class="line">ONBOOT=yes | no</span><br><span class="line">IPADDR=192.168.239.200</span><br><span class="line">NETMASK=255.255.255.0</span><br><span class="line">GATEWAY=192.168.239.2</span><br><span class="line">DNS1=114.114.114.114</span><br><span class="line">DNS2=8.8.8.8</span><br></pre></td></tr></tbody></table></figure>
<p>修改完成成功重启<code>systemctl restart network</code>即可。<a href="https://blog.csdn.net/zyq_2014/article/details/79692181" target="_blank" rel="noopener">参考博客</a><br>Tips: 使用<code>ifconfig</code>查看IP地址，使用<code>route -n</code>查看路由网关，使用<code>cat /etc/resolv.conf</code>查看DNS，使用<code>cat /etc/sysconfig/network-scripts/ifcfg-ens32</code>查看配置文件。</p>
<h2 id="使用nmcli配置"><a href="#使用nmcli配置" class="headerlink" title="使用nmcli配置"></a>使用nmcli配置</h2><p>使用nmcli命令要确保系统中已经安装NetworkManager，默认是自动启动的。使用<code>systemctl status NetworkManager</code>检查确认。CentOS8中network已经淘汰掉了，不建议使用。</p>
<ol>
<li>查看网络设备状态<br><code>nmcli device status</code>  </li>
<li>查看ens32网卡的相关信息<br><code>nmcli device show ens32</code></li>
<li>设置静态ip地址<br><code>nmcli connection modify ens32 ipv4.addresses '192.168.1.100'</code></li>
<li>设置DNS<br><code>nmcli connection modify ens32 ipv4.dns '114.114.114.114'</code></li>
<li>设置网关<br><code>nmcli connection modify ens32 ipv4.gateway '192.168.1.1'</code></li>
<li>设置IP地址为手动指定<br><code>nmcli connection modify ens32 ipv4.method manual</code></li>
<li>设置IP地址为dhcp自动获取<br><code>nmcli connection modify ens32 ipv4.method auto</code></li>
<li>设置开机自动连接<br><code>nmcli connection modify ens32 connection.autoconnect yes</code></li>
<li>重新加载ifcfg-ens32配置文件<br><code>nmcli connection reload</code></li>
<li>不重启系统让网卡生效的方法<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">nmcli connection up ens32</span><br><span class="line">nmcli device connect ens32</span><br><span class="line">nmcli device reapply ens32</span><br></pre></td></tr></tbody></table></figure>

</li>
</ol>
<h1 id="系统目录结构"><a href="#系统目录结构" class="headerlink" title="系统目录结构"></a>系统目录结构</h1><div style="width: 50%;margin: left"><img src="/2019/10/23/Linux-base/dir_tree.png" class="" title="系统目录结构树"></div>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">/bin   存放二进制可执行文件(ls,cat,mkdir等)，存放系统命令</span><br><span class="line">/boot  核心系统启动文件，存放用于系统引导时使用的各种文件</span><br><span class="line">/dev   存放硬件设备，使用里面设备需要挂载,糖炒栗子：mount /dev/cdrom /media/</span><br><span class="line">/etc   存放系统程序管理和配置文件</span><br><span class="line">/home  存放除了root用户之外的所有用户文件的根目录，比如用户user的主目录就是/home/user，可以用~user表示</span><br><span class="line">/lib   存放跟文件系统中的程序运行所需要的共享库及内核模块。共享库又叫动态链接共享库，作用类似windows里的.dll文件，存放了根文件系统程序运行所需的共享文件。</span><br><span class="line">/media 空目录，不可删，用于挂在光盘使用</span><br><span class="line">/mnt   空测试目录，系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统</span><br><span class="line">/opt   空测试目录，额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把tomcat等都安装到这里。</span><br><span class="line">/proc  虚拟文件系统目录，是系统内存的映射。存放cpu、内存和硬盘等设备信息，可直接访问这个目录来获取系统信息。</span><br><span class="line">/root  超级用户（root）的主目录</span><br><span class="line">/run   程序进程PID </span><br><span class="line">/sbin  存放二进制可执行文件，只有root才能访问。这里存放的是系统管理员使用的系统级别的管理命令和程序。如ifconfig等</span><br><span class="line">/srv   自己的程序或源代码的放置目录</span><br><span class="line">/sys   内核信息文件</span><br><span class="line">/tmp   用于存放各种临时文件，是公用的临时文件存储点</span><br><span class="line">/usr   非系统程序用于存放系统应用程序，比较重要的目录/usr/local 本地系统管理员软件安装目录（安装系统级的应用）。这是最庞大的目录，要用到的应用程序和文件几乎都在这个目录。</span><br><span class="line">/var   用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统或程序日志等）</span><br></pre></td></tr></tbody></table></figure>

<h1 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h1><ol>
<li>历史命令查看用 <code>history</code>， 使用<code>history -c</code>清除历史命令</li>
<li>强制中断正在执行的操作 ctrl+c</li>
<li>清空当前屏幕 <code>clear</code>或ctrl+l</li>
<li>记录最近两次使用的目录 <code>cd -</code></li>
</ol>
<h1 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h1><ol>
<li>新建修改和删除<br>创建文件 <code>touch file1</code><br>批量创建文件 <code>touch file{1..9}</code><br>编辑文件 <code>vi file2</code><br>修改文件名 mv file1 file2<br>删除文件 <code>rm -rf file</code></li>
<li>查看文件内容<br>全文查看文件内容 <code>cat file4</code><br>分页查看文件内容 <code>more file4</code><br>跟踪文件数据 <code>tail -f file1</code><br>查看文件前十行数据<code>head file1</code> or <code>head -10 file1</code><br>查看文件后十行数据 <code>tail flle1</code> or <code>tail -10 file1</code></li>
<li>复制和文件<br>复制文件<code>cp file1 file2</code><br>移动文件<code>mv file1 file2</code></li>
<li>查找文件<br>查找文件名为file1的文件 <code>find / -name file1</code><br>快速查找文件名为file1的文件 <code>updatedb;locate file1</code><br>查找file1文件中linux字符  <code>cat file1 | grep linux</code> or <code>grep 'linux' file1</code><br>查找file1文件中linux字符 忽略大小写 <code>grep -i 'linux' file1</code></li>
</ol>
<h1 id="Vi编辑器"><a href="#Vi编辑器" class="headerlink" title="Vi编辑器"></a>Vi编辑器</h1><p>Vi是Unix及Linux系统下标准的编辑器，由美国加州大学伯克利分校开发。学会它后，你将在Linux的世界里畅行无阻。基本上vi可以分为三种状态，分别是命令模式、插入模式，和底行模式。</p>
<h2 id="Vi编辑器的模式"><a href="#Vi编辑器的模式" class="headerlink" title="Vi编辑器的模式"></a>Vi编辑器的模式</h2><ol>
<li>命令模式 command</li>
<li>输入模式 insert</li>
<li>末行模式 :末行命令</li>
<li>视图模式 visual</li>
</ol>
<h2 id="常用模式切换"><a href="#常用模式切换" class="headerlink" title="常用模式切换"></a>常用模式切换</h2><div style="width: 44%;margin: left"><img src="/2019/10/23/Linux-base/vi_model.png" class="" title="简单的模式切换"></div>

<p>命令模式 =&gt; 输入模式<br>输入模式 =&gt; 命令模式 按下<code>esc</code><br>命令模式 =&gt; 末行模式 使用 <code>shift+:</code>输入<code>x</code>保存退出<br>末行模式 =&gt; 命令模式 按下<code>esc</code><br>命令模式 =&gt; 视图模式 使用<code>v</code><br> 按<code>v</code>键再按上下左右进行视图选中，进行快速缩进</p>
<h3 id="命令模式常用命令"><a href="#命令模式常用命令" class="headerlink" title="命令模式常用命令"></a>命令模式常用命令</h3><p> 上<code>k</code>下<code>j</code>左<code>h</code>右<code>l</code>撤销用<code>u</code>恢复用ctrl+<code>r</code>(撤销多了恢复，两个配合使用)<br> 复制当前行 <code>yy</code> 复制多行 <code>nyy</code>, 比如<code>3yy</code>为复制三行<br> 粘贴到下一行 <code>p</code>, 粘贴到下一行n次 <code>np</code>.  粘贴到上一行 <code>P</code>, 粘贴到上一行n次 <code>nP</code></p>
<p> 单字符替换用<code>r</code> , 按过<code>r</code>后直接输入需要替换的字符即可<br> 查找用 <code>/</code>, 查找下一个结果用 <code>n</code></p>
<p> 到最后一行首用<code>G</code>, 到指定行首用<code>nG</code> , 比如<code>3G</code>为到第三行行首<br> 从当前行删除到最后一行 <code>dG</code>(当前行也会删除哦), 从当前行删除到第n行 <code>dnG</code><br> 删除一个单词用 <code>dw</code>n<br> 删除并剪切一行用<code>dd</code><br> 从当前字符删除到行首用 <code>d^</code> , 从当前字符删除到行末用 <code>d$</code><br> 删除单个字符使用<code>x</code>, 删除指定个数的字符用 <code>nx</code>, 比如<code>3x</code>为删除当前光标所在位置的后三个字符</p>
<p> 按<code>v</code>键再按上下左右进行视图选中，进行快速缩进</p>
<h3 id="输入模式常用命令"><a href="#输入模式常用命令" class="headerlink" title="输入模式常用命令"></a>输入模式常用命令</h3><p> 使用<code>i</code>在光标当前所在字符的前面输入<br> 使用<code>a</code>在光标当前所在字符的后面输入<br> 使用<code>I</code>在光标所在当前行的前面开始输入<br> 使用<code>A</code>在光标所在当前行的后面开始输入</p>
<p> 使用<code>s</code>删除光标所在的当前字符并输入<br> 使用<code>o</code>在当前字符所在行下方另起一行输入<br> 使用<code>S</code>删除光标所在当前行并输入<br> 使用<code>O</code>在当前字符所在行上方另起一行输入</p>
<h3 id="末行模式常用模式"><a href="#末行模式常用模式" class="headerlink" title="末行模式常用模式"></a>末行模式常用模式</h3><p> 不保存退出 <code>q</code> 强制不保存退出 <code>q!</code> 保存退出 <code>wq</code> 保存不退出 <code>w</code><br> 把一篇文章中的所有hello全部替换成world(%第一行到最后的意思) <code>:%s/hello/world/g</code><br> 把第1行到第10行的hello替换成world <code>:1,10s/hello/world/g</code><br> 把每行中首个hello换成world <code>:%s/hello/world/</code></p>
<h1 id="目录管理"><a href="#目录管理" class="headerlink" title="目录管理"></a>目录管理</h1><p>创建目录 <code>mkdir dir1</code><br>递归创建多级目录 <code>mkdir -p dir1/dir2/dir3</code><br>删除目录 <code>rm -rf dir1</code><br>修改目录名称 <code>mv dir1 dir2</code><br>复制多级结构目录<code>cp -r div1 div2</code><br>查看目录 <code>tree dir1</code></p>
<h1 id="用户和组"><a href="#用户和组" class="headerlink" title="用户和组"></a>用户和组</h1><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><p>查看用户 <code>id root</code><br>创建用户 <code>useradd user1</code><br>设置密码 <code>passwd user1</code>回车后会有提示键入密码， shell中设置密码 <code>echo "123" | passwd --stdin user1</code><br>与用户有关的文件  </p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">/etc/passwd 用户信息</span><br><span class="line">/etc/group 用户组信息</span><br><span class="line">/etc/shadow 用户密码</span><br><span class="line">/home/user1 用户家目录</span><br></pre></td></tr></tbody></table></figure>
<p>删除用户 <code>userdel -r user1</code></p>
<h2 id="组管理"><a href="#组管理" class="headerlink" title="组管理"></a>组管理</h2><p>把user1加入root组 <code>gpasswd -a user1 root</code><br>把user1从root组删除 <code>gpasswd -d user1 root</code></p>
<h1 id="GZ、Bz2和Zip压缩包"><a href="#GZ、Bz2和Zip压缩包" class="headerlink" title="GZ、Bz2和Zip压缩包"></a>GZ、Bz2和Zip压缩包</h1><h2 id="Gz压缩包管理"><a href="#Gz压缩包管理" class="headerlink" title="Gz压缩包管理"></a>Gz压缩包管理</h2><p>制作gz压缩包 <code>tar czf mydir1.tar.gz mydir1</code><br>解压gz压缩包 <code>tar xzf mydir1.tar.gz</code><br>查看gz压缩包 <code>tar tf mydir1.tar.gz</code></p>
<h2 id="Bz2压缩包管理"><a href="#Bz2压缩包管理" class="headerlink" title="Bz2压缩包管理"></a>Bz2压缩包管理</h2><p>制作bz2压缩包 <code>tar cjf mydir1.tar.bz2 mydir1</code><br>解压bz2压缩包 <code>tar xjf mydir1.tar.bz2</code><br>查看bz2压缩包 <code>tar tf mydir1.tar.bz2</code></p>
<h2 id="Zip压缩包管理"><a href="#Zip压缩包管理" class="headerlink" title="Zip压缩包管理"></a>Zip压缩包管理</h2><p>制作zip压缩包 <code>zip -r mydir1.zip mydir1</code><br>zip压缩包解压 <code>unzip mydir1.zip</code><br>查看zip压缩包 <code>unzip -l mydir1.zip</code></p>
<h1 id="光盘管理"><a href="#光盘管理" class="headerlink" title="光盘管理"></a>光盘管理</h1><p>在linux系统中，可以使用mount命令挂载光盘镜像文件、移动硬盘、U盘以及Windows网络共享和UNIX NFS网络共享。<br>挂载光盘 <code>mount /dev/cdrom /media/</code><br>查看挂载情况 <code>df</code> <code>df -h</code> <code>df -Th</code><br>卸载光盘 <code>umount /media</code><br>开机挂载 <code>vi /etc/fstab</code>后追加<code>/dev/cdrom  /media   iso9660  defaults  0 0</code><br>开机挂载测试 <code>mount -a</code>成功后重启即可</p>
<h1 id="RPM包管理"><a href="#RPM包管理" class="headerlink" title="RPM包管理"></a>RPM包管理</h1><p>RPM：redhat package management英文缩写，只适用于Redhat和Centos系统。</p>
<p>安装RPM包 <code>rpm -ivh psmisc-23.1-3.el8.x86_64</code><br>查看RPM包 <code>rpm -qa</code> or <code>rpm -qa | grep psmisc-23.1</code> or 使用<code>rpm -qa |  wc -l</code>查看安装个数<br>查看RPM包安装的文件 <code>rpm -ql psmisc-23.1</code> or <code>rpm -ql psmisc-23.1 | grep pstree</code><br>反查文件是否是由RPM包安装的 <code>rpm -qf /usr/bin/pstree</code><br>删除RPM安装程序 <code>rpm -e psmisc-23.1</code></p>
<h1 id="yum命令"><a href="#yum命令" class="headerlink" title="yum命令"></a>yum命令</h1><p>yum（ Yellow dog Updater, Modified）是一个在Fedora和RedHat以及SUSE中的Shell前端软件包管理器。<br>YUM仓库的前提是做准备光盘 检查光盘是否正常挂载 使用命令 <code>df</code><br><code>mount /dev/cdrom /media</code>  使用该命令挂载光盘<br>下面为配置yum流程</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">cd /etc/yum.repos.d/</span><br><span class="line">mv CentOS-Media.repo /mnt</span><br><span class="line">rm -rf *</span><br><span class="line">mv /mnt/CentOS-Media.repo ./</span><br></pre></td></tr></tbody></table></figure>
<p><code>vi CentOS-Media.repo</code> 进行配置文件编辑 下面对应配置需要对照</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[c8-media-BaseOS]</span><br><span class="line">baseurl=file:///media/BaseOS</span><br><span class="line">gpgcheck=0</span><br><span class="line">enabled=1</span><br><span class="line"></span><br><span class="line">[c8-media-AppStream]</span><br><span class="line">baseurl=file:///media/AppStream</span><br><span class="line">gpgcheck=0</span><br><span class="line">enabled=1</span><br></pre></td></tr></tbody></table></figure>
<p>查看yum可控制的软件包<br><code>yum list | wc -l</code> 或者 <code>yum list | grep iptables</code>  </p>
<p>yum安装rpm软件包<br> <code>yum -y install iptables-service</code></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">yum check-update  // 列出所有可更新的软件清单</span><br><span class="line">yum update // 更新所有软件</span><br><span class="line">yum install &lt;package_name&gt; // 仅安装指定的软件</span><br><span class="line">yum update &lt;package_name&gt;  // 仅更新指定的软件</span><br><span class="line">yum list        // 列出所有可安裝的软件清单</span><br><span class="line">yum remove &lt;package_name&gt; // 删除软件包</span><br><span class="line">yum search &lt;keyword&gt;    // 查找软件包</span><br><span class="line"></span><br><span class="line">yum clean packages // 清除缓存目录下的软件包</span><br><span class="line">yum clean headers // 清除缓存目录下的 headers</span><br><span class="line">yum clean oldheaders // 清除缓存目录下旧的 headers</span><br></pre></td></tr></tbody></table></figure>

<h1 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h1><p>查看文件权限 <code>ls -l fileName</code> or <code>ll</code><br>查看单个目录本身的权限 <code>ll -d dirName</code><br>权限类型 <code>r 读(4) w 写(2) x 执行(1) - 无权限(0)</code><br>权限详情</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">三段式</span><br><span class="line">drwxr-xr-x 2 root root 6 Oct 16 19:14 dir</span><br><span class="line">1.目录</span><br><span class="line">2.root对dir的权限:rwx:读+写+执行</span><br><span class="line">3.rootGroup对dir的权限:rx:读+执行</span><br><span class="line">4.other用户对dir的权限:rx:读+执行</span><br><span class="line"></span><br><span class="line">-rw-r--r-- 1 root root 0 Oct 16 19:14 file</span><br><span class="line">1.文件</span><br><span class="line">2.root对file的权限:rw:读+写</span><br><span class="line">3.root组对file的权限:r:读</span><br><span class="line">4.other对file的权限:r:读</span><br></pre></td></tr></tbody></table></figure>
<h2 id="umask权限掩码"><a href="#umask权限掩码" class="headerlink" title="umask权限掩码"></a>umask权限掩码</h2><p>默认权限: 文件:666，目录777<br>文件: 644(默认权限:666-权限掩码:022)<br>目录: 755(默认权限:777-权限掩码:022)</p>
<h2 id="Chomd命令"><a href="#Chomd命令" class="headerlink" title="Chomd命令"></a>Chomd命令</h2><p>数字式 <code>chmod 755 /mnt</code><br>英文参数式 <code>chmod a+x file</code> 等价于 <code>chmod u+x,g+x,o+x linux.sh</code>  # a=u+g+o </p>
<h2 id="ACL命令"><a href="#ACL命令" class="headerlink" title="ACL命令"></a>ACL命令</h2><p>查看权限 <code>getfacl test.sh</code><br>设置权限 <code>setfacl -m u:user1:rwx test.sh</code><br>设置acl的默认权限 <code>setfacl -m d:u:user1:rwx test.sh</code> or <code>setfacl -m default:u:user1:rwx test.sh</code><br>删除/test上的所有acl权限 <code>setfacl -b test.sh</code><br>删除user1在/test上的权限 <code>setfacl -x u:user1 test.sh</code></p>
<h2 id="Sudo命令"><a href="#Sudo命令" class="headerlink" title="Sudo命令"></a>Sudo命令</h2><p>使用 root 用户修改文件<code>/etc/sudoers</code>添加可写权限后编辑，在root ALL=(ALL) ALL下一行加入以下内容：<code>你的账号ALL=(ALL)ALL</code> 保存退出。<br>分配用户对命令的权限</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">visudo</span><br><span class="line">xugz localhost=/usr/sbin/useradd // 完成后，指定用户 xugz 就可添加用户</span><br></pre></td></tr></tbody></table></figure>

<h1 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h1><h2 id="命令技巧"><a href="#命令技巧" class="headerlink" title="命令技巧"></a>命令技巧</h2><p>使用 <code>tab</code> 快速补全<br>调出历史命令中第1001号命令 <code>!1001</code><br>调出最后一次执行的以s开头的命令<code>!s</code><br>管道 <code>|</code> </p>
<h2 id="帮助技巧"><a href="#帮助技巧" class="headerlink" title="帮助技巧"></a>帮助技巧</h2><p><code>ls --help</code><br><code>systemctl -h</code><br><code>man ls</code></p>
<h2 id="shell编程概述"><a href="#shell编程概述" class="headerlink" title="shell编程概述"></a>shell编程概述</h2><h3 id="别名管理"><a href="#别名管理" class="headerlink" title="别名管理"></a>别名管理</h3><p>查看别名 <code>alias</code><br>新建别名 <code>alias myif='nmcli device show ens32'</code><br>删除别名 <code>unalias myif</code></p>
<h3 id="日期管理-date"><a href="#日期管理-date" class="headerlink" title="日期管理-date"></a>日期管理-date</h3><p><code>date '+%Y-%m-%d %H:%M:%S'</code><br>Y 年 m 月 d 日 H 时 M 分 S 秒</p>
<h3 id="Bash重定向"><a href="#Bash重定向" class="headerlink" title="Bash重定向"></a>Bash重定向</h3><p>正确输出 <code>&gt;</code><br>正确追加输出 <code>&gt;&gt;</code><br>错误输出 <code>2&gt;</code><br>错误追加输出 <code>2&gt;&gt;</code><br>正确和错误输出 <code>&amp;&gt;</code><br>正确和错误追加输出 <code>&amp;&gt;&gt;</code><br>正确或错误立即销毁 <code>&amp;&gt;/dev/null</code></p>
<h3 id="Shell编程-基础操作"><a href="#Shell编程-基础操作" class="headerlink" title="Shell编程-基础操作"></a>Shell编程-基础操作</h3><p>变量定义 <code>name='user1'</code><br>输出变量 <code>echo $name</code> or <code>echo "my name is ${name}"</code></p>
<h3 id="Shell编程-文件测试"><a href="#Shell编程-文件测试" class="headerlink" title="Shell编程-文件测试"></a>Shell编程-文件测试</h3><p><code>-d</code>：测试是否为目录（Directory）<br><code>-e</code>：测试目录或文件是否存在（Exist）<br><code>-f</code>：测试是否为文件（File）<br><code>-L</code>：测试是否为符号连接（Link）文件</p>
<h3 id="Shell编程-字符串测试"><a href="#Shell编程-字符串测试" class="headerlink" title="Shell编程-字符串测试"></a>Shell编程-字符串测试</h3><p><code>=</code>： 字符串内容相同<br><code>!=</code>：字符串内容不同<br><code>-z</code>: 字符串为空</p>
<h3 id="Shell编程-数学测试"><a href="#Shell编程-数学测试" class="headerlink" title="Shell编程-数学测试"></a>Shell编程-数学测试</h3><p><code>-eq</code>：等于（Equal）<br><code>-ne</code>：不等于（Not Equal）<br><code>-gt</code>：大于（Greater Than）<br><code>-lt</code>：小于（Lesser Than）<br><code>-ge</code>：大于或等于（Greater or Equal）<br><code>-le</code>：小于或等于（Lesser or Equal）</p>
<h3 id="Shell编程-逻辑测试"><a href="#Shell编程-逻辑测试" class="headerlink" title="Shell编程-逻辑测试"></a>Shell编程-逻辑测试</h3><p><code>&amp;&amp;</code>：逻辑与<br><code>||</code>：逻辑或<br><code>!</code>： 逻辑否</p>
<h3 id="Shell编程-用户交互"><a href="#Shell编程-用户交互" class="headerlink" title="Shell编程-用户交互"></a>Shell编程-用户交互</h3><p>read -p ‘please input your name: ‘ name<br>echo $name</p>
<h3 id="Shell编程实例"><a href="#Shell编程实例" class="headerlink" title="Shell编程实例"></a>Shell编程实例</h3><p><strong>光盘挂载</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">if [ ! -e /media/BaseOS ]</span><br><span class="line">then</span><br><span class="line">	mount /dev/cdrom /media &amp;&gt; /dev/null</span><br><span class="line">	echo 'cdrom is ok'</span><br><span class="line">else</span><br><span class="line">	echo 'cdrom is ok'</span><br><span class="line">fi</span><br></pre></td></tr></tbody></table></figure>

<p><strong>创建用户</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">read -p 'please input your name:' name</span><br><span class="line">if [ ! -z $name ]</span><br><span class="line">then</span><br><span class="line">	read -p 'please input your pass:' pass</span><br><span class="line">	if [ ! -z $pass ]</span><br><span class="line">	then</span><br><span class="line">		useradd $name</span><br><span class="line">		echo $pass | passwd --stdin $name &amp;&gt; /dev/null</span><br><span class="line">		echo "your name is ${name}，your pass is ${pass}，create is ok"</span><br><span class="line">	else</span><br><span class="line">		echo 'pass is empty'</span><br><span class="line">	fi</span><br><span class="line">else</span><br><span class="line">	echo 'name is empty'</span><br><span class="line">fi</span><br></pre></td></tr></tbody></table></figure>
<p><strong>内存判断</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">mem=`free -m |grep 'Mem'|awk '{print $4}'` # 执行`里的代码</span><br><span class="line"></span><br><span class="line">if [ $mem -lt 400 ]</span><br><span class="line">then</span><br><span class="line">	echo "mem is no,now is ${mem}"</span><br><span class="line">else</span><br><span class="line">	echo "mem is yes,now is ${mem}"</span><br><span class="line">fi</span><br></pre></td></tr></tbody></table></figure>

<p><strong>循环输出</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">for name in `cat /etc/passwd | awk -F: '{print $1}'`</span><br><span class="line">do</span><br><span class="line">	echo $name</span><br><span class="line">	sleep 1</span><br><span class="line">done</span><br></pre></td></tr></tbody></table></figure>

<h1 id="crontab任务计划"><a href="#crontab任务计划" class="headerlink" title="crontab任务计划"></a>crontab任务计划</h1><p>cron是一个可以用来根据时间、日期、月份和星期的组合来调度对周期性任务执行的守护进程，利用cron所提供的功能，可以将需要周期性重复执行的任务设置为cron任务，并且设置为在主机较空闲的时间自动完成。</p>
<p>查看Crontab服务状态 <code>systemctl status crond</code><br>任务计划格式 <code>(分) *(时) *(日) *(月) *(周) 周期执行的程序</code><br>查看cron任务计划 <code>crontab -l</code><br>编辑cron任务计划 <code>crontab -e</code><br>删除所有cron任务计划 <code>crontab -r</code></p>
<p>每年1月2日晚上22:30执行time.sh脚本  <code>30 22 2 1 * time.sh</code><br>每周六晚上22:30执行time.sh脚本 <code>30 22 * * 6 time.sh</code><br>每周的周一、周三和周五晚上22:30执行time.sh脚本  <code>30 22 * * 1,3,5 time.sh</code><br>每周的周一到周五晚上22:30执行time.sh脚本 <code>30 22 * * 1-5 time.sh</code><br>每分钟执行一次time.sh脚本  <code>* * * * * time.sh</code><br>每五分钟执行一次time.sh脚本  <code>*/5 * * * * time.sh</code><br>每天晚上00点执行time.sh脚本  <code>00 00 * * * time.sh</code></p>
<p> 该命令详见 <a href="https://xlline.github.io/2019/10/23/linux_crontab/#more">点我，我是链接地址</a></p>
<h1 id="top命令"><a href="#top命令" class="headerlink" title="top命令"></a>top命令</h1><p>top命令用于实时显示 process 的动态</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">top     // 显示进程信息</span><br><span class="line">top -c  // 显示完整命令</span><br><span class="line">top -b  // 以批处理模式显示程序信息</span><br><span class="line">top -s  // 以累积模式显示程序信息</span><br><span class="line">top -p &lt;pid&gt; // 显示指定的进程信息</span><br><span class="line">top -n 10  // 显示更新十次后退出</span><br></pre></td></tr></tbody></table></figure>

<h1 id="Cockpit-Web系统监控"><a href="#Cockpit-Web系统监控" class="headerlink" title="Cockpit Web系统监控"></a>Cockpit Web系统监控</h1><p>初始化 <code>systemctl enable --now cockpit.socket</code><br>开启cockpit服务 <code>systemctl start cockpit.service</code><br>查看cockpit状态 <code>systemctl status cockpit.service</code></p>
<h1 id="自定义服务脚本流程"><a href="#自定义服务脚本流程" class="headerlink" title="自定义服务脚本流程"></a>自定义服务脚本流程</h1><p>需求：自定义startMyApp脚本，使用systemd服务管理放入开机自启动。用于练手systemcrl命令 </p>
<ol>
<li>创建文件 <code>vi /mnt/startMyApp.sh</code> # 路径可自指定  <figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">i=0</span><br><span class="line">while true</span><br><span class="line">do</span><br><span class="line">    echo $i&gt;&gt;/mnt/MyApp.txt</span><br><span class="line">    ((i++))</span><br><span class="line">    sleep 1</span><br><span class="line">done</span><br></pre></td></tr></tbody></table></figure></li>
<li>给脚本设置执行权限<code>chmod a+x startMyApp.sh</code></li>
<li>自定义myapp服务脚本<code>vi /etc/systemd/system/myapp.service</code><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[Unit] # 服务单元</span><br><span class="line">Description=myapp service  </span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">WorkingDirectory=/mnt # 工作目录</span><br><span class="line">ExecStart=/mnt/startMyApp.sh</span><br><span class="line">ExecStop=/bin/kill -s TERM $MAINPID  </span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target # 设置开机启动放到哪个运行级别</span><br></pre></td></tr></tbody></table></figure></li>
<li>重载所有修改过的配置文件,扫描新的或有变动的单元<br><code>systemctl daemon-reload</code></li>
<li>把myapp服务加入开机启动<br><code>systemctl enable myapp.service</code></li>
<li>启动myapp服务后程序执行<br><code>systemctl start myapp.service</code></li>
<li>关闭myapp服务<br><code>systemctl stop myapp.service</code></li>
</ol>
<p>Tips: 查看myapp服务状态使用<code>systemctl status myapp.service</code></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux的crontab命令</title>
    <url>/2019/10/23/Linux-crontab/</url>
    <content><![CDATA[<p>Linux下的任务调度分为两类：系统任务调度和用户任务调度。<br>系统任务调度：系统周期性所要执行的工作，比如写缓存数据到硬盘、日志清理等。在/etc目录下有一个crontab文件，这个就是系统任务调度的配置文件。<br>用户任务调度：用户定期要执行的工作，比如用户数据备份、定时邮件提醒等。用户可以使用 crontab 工具来定制自己的计划任务。  </p>
<a id="more"></a>
<p>所有用户定义的crontab文件都被保存在/var/spool/cron目录中。其文件名与用户名一致，使用者权限文件如下：<br><code>/etc/cron.deny</code>     该文件中所列用户不允许使用crontab命令<br><code>/etc/cron.allow</code>   该文件中所列用户允许使用crontab命令<br><code>/var/spool/cron/</code>   所有用户crontab文件存放的目录,以用户名命名  </p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">分 时 日 月 星期 命令</span><br><span class="line"># .---------------- minute (0 - 59)</span><br><span class="line"># |  .------------- hour (0 - 23)</span><br><span class="line"># |  |  .---------- day of month (1 - 31)</span><br><span class="line"># |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...</span><br><span class="line"># |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat</span><br><span class="line"># |  |  |  |  |</span><br><span class="line"># *  *  *  *  * user-name  command to be executed</span><br></pre></td></tr></tbody></table></figure>

<p>在以上各个字段中，还可以使用以下特殊字符：<br>星号（*）：代表所有可能的值，例如month字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。<br>逗号（,）：可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9”<br>中杠（-）：可以用整数之间的中杠表示一个整数范围，例如“2-6”表示“2,3,4,5,6”<br>正斜线（/）：可以用正斜线指定时间的间隔频率，例如“0-23/2”表示每两小时执行一次。同时正斜线可以和星号一起使用，例如*/10，如果用在minute字段，表示每十分钟执行一次。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">/sbin/service crond start    // 启动服务   或者使用  service crond start 命令 手动启动crontab服务</span><br><span class="line">/sbin/service crond stop     // 关闭服务</span><br><span class="line">/sbin/service crond restart  // 重启服务</span><br><span class="line">/sbin/service crond reload   // 重新载入配置</span><br><span class="line"></span><br><span class="line">chkconfig –level 35 crond on // 加入开机自动启动</span><br><span class="line">service crond status // 查看crontab服务状态</span><br></pre></td></tr></tbody></table></figure>

<p>crontab (选项 例如:-e)(参数 crontab文件)<br>-e：编辑该用户的计时器设置；<br>-l：列出该用户的计时器设置；<br>-r：删除该用户的计时器设置；<br>-u&lt;用户名称&gt;：指定要设定计时器的用户名称。    </p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>crontab</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Hexo+GitHub搭建个人博客教程</title>
    <url>/2019/06/19/Hexo+GitHub/</url>
    <content><![CDATA[<p>开始搭建自己的小站吧。简单记录，方便后续翻阅。<br>从无到有的流程还是比较详细的，按步骤从头到尾跟着执行可以避免大部分问题。本次搭站 <a href="https://zhuanlan.zhihu.com/p/60578464" target="_blank" rel="noopener">参考文章</a> 人家写的已经很详细了，这里进行备份基础补充和常见问题的汇总。</p>
<a id="more"></a>
<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>Hexo 基于 Node.js，搭建过程中还需要使用 npm（Node.js 已带） 和 git，因此先搭建本地操作环境，安装 Node.js 和 Git。<br>Node.js<a href="https://nodejs.org/zh-cn" target="_blank" rel="noopener">下载地址</a><br>Git<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">下载地址</a><br>下载 Node.js 和 Git 程序并安装，一路点 “下一步” 按默认配置完成安装。<br>安装完成后，Win+R 输入 cmd 并打开，依次输入 node -v、npm -v 和 git –version 并回车，出现程序版本号即可。</p>
<h1 id="连接-Github"><a href="#连接-Github" class="headerlink" title="连接 Github"></a>连接 Github</h1><p>使用邮箱注册 <a href="https://github.com/" target="_blank" rel="noopener">GitHub</a> 账户，选择免费账户，并完成邮件验证。<br>右键 -&gt; Git Bash Here，设置用户名和邮箱：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">git config --global user.name "GitHub 用户名"</span><br><span class="line">git config --global user.email "GitHub 邮箱"</span><br></pre></td></tr></tbody></table></figure>
<ol>
<li>创建SSH密钥：输入 <code>ssh-keygen -t rsa -C "GitHub 邮箱"</code>，然后一路回车。</li>
<li>添加密匙：进入 [C:\Users\用户名.ssh] 目录（要勾选显示“隐藏的项目”），用记事本打开公钥 id_rsa.pub 文件并复制里面的内容。<br>登陆 GitHub ，进入 Settings 页面，选择左边栏的 SSH and GPG keys，点击 New SSH key。<br>Title 随便取个名字，粘贴复制的 id_rsa.pub 内容到 Key 中，点击 Add SSH key 完成添加。</li>
<li>验证连接： 打开 Git Bash，输入 <code>ssh -T git@github.com</code> 出现 <code>“Are you sure……”，</code>输入<code>yes</code> 回车确认。<br>显示 “Hi xxx! You’ve successfully……” 即连接成功。</li>
</ol>
<h1 id="创建-Github-Pages-仓库"><a href="#创建-Github-Pages-仓库" class="headerlink" title="创建 Github Pages 仓库"></a>创建 Github Pages 仓库</h1><p>GitHub 主页右上角加号 -&gt; New repository：</p>
<ul>
<li>Repository name 中输入 <code>用户名.github.io</code></li>
<li>勾选 “Initialize this repository with a README”</li>
<li>Description 选填</li>
</ul>
<p>填好后点击 Create repository 创建。创建后默认自动启用 HTTPS，博客地址为：<code>https://用户名.github.io</code><br>Tips：最好这里的用户名和仓库名称一样哦，会避免很多麻烦。  </p>
<h1 id="本地安装-Hexo-博客程序"><a href="#本地安装-Hexo-博客程序" class="headerlink" title="本地安装 Hexo 博客程序"></a>本地安装 Hexo 博客程序</h1><p>使用 npm 一键安装 Hexo 博客程序：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></tbody></table></figure>
<p>Mac 用户需要管理员权限（sudo），运行这条命令：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">sudo npm install -g hexo-cli</span><br></pre></td></tr></tbody></table></figure>
<p>等待安装，出现hexo版本号即为安装成功，安装成功后初始化并安装所需组件：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">hexo init      # 初始化</span><br><span class="line">npm install    # 安装组件</span><br></pre></td></tr></tbody></table></figure>
<p>完成后依次输入下面命令，启动本地服务器进行预览：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">hexo g   # 生成页面</span><br><span class="line">hexo s   # 启动预览</span><br></pre></td></tr></tbody></table></figure>
<p>访问 <code>http://localhost:4000</code>，出现 Hexo 默认页面，本地博客安装成功！</p>
<p>Tips：如果出现页面加载不出来，可能是端口被占用了。Ctrl+C 关闭服务器，运行 <code>hexo server -p 5000</code> 更改端口号后重试。</p>
<p>Hexo 博客文件夹目录结构如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">├── _config.yml   ## 用于存放网站的配置信息，你可以在此配置大部分的参数</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds     ## 存放模板的文件夹，当新建文章时，Hexo会根据scaffold来建立文件</span><br><span class="line">├── source        ## source是资源文件夹，用于存放用户资源</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes       ## themes是主题文件夹，存放博客主题，Hexo 会根据主题来生成静态页面</span><br></pre></td></tr></tbody></table></figure>


<h1 id="部署-Hexo-到-GitHub-Pages"><a href="#部署-Hexo-到-GitHub-Pages" class="headerlink" title="部署 Hexo 到 GitHub Pages"></a>部署 Hexo 到 GitHub Pages</h1><p>本地博客测试成功后，就是上传到 GitHub 进行部署，使其能够在网络上访问。<br>首先安装 hexo-deployer-git：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></tbody></table></figure>
<p>然后修改 <em>_config.yml</em> 文件末尾的 Deployment 部分，修改成如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:用户名/用户名.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></tbody></table></figure>
<p>完成后运行 <code>hexo d</code> 将网站上传部署到 GitHub Pages。</p>
<p>完成！这时访问我们的 GitHub 域名 <code>https://用户名.github.io</code> 就可以看到 Hexo 网站了。  </p>
<h1 id="绑定域名（可选）"><a href="#绑定域名（可选）" class="headerlink" title="绑定域名（可选）"></a>绑定域名（可选）</h1><p>博客搭建完成使用的是 GitHub 的子域名（<code>用户名.http://github.io</code>），我们可以为 Hexo 博客绑定自己的域名替换 GitHub 域名，更加个性化和专业，也利于 SEO。</p>
<ol>
<li><p>域名注册和解析教程：Namesilo <a href="https://zhuanlan.zhihu.com/p/33921436" target="_blank" rel="noopener">域名购买及使用教程</a><br>按上面教程注册并解析域名，在 DNS 设置部分，删除自带的记录，然后添加 CNAME 记录将 www 域名解析指向 用户名.github.io。</p>
</li>
<li><p>绑定域名到 Hexo 博客<br>进入本地博客文件夹的 source 目录，打开记事本，里面输入自己的域名，如<a href="http://www.example.com，保存名称为" target="_blank" rel="noopener">http://www.example.com，保存名称为</a> “CNAME”，格式为 “所有文件”（无 .txt 后缀）。</p>
</li>
</ol>
<p>清除缓存等文件并重新发布网站：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">hexo clean   # 清除缓存文件等</span><br><span class="line">hexo g       # 生成页面</span><br><span class="line">hexo s       # 启动预览</span><br></pre></td></tr></tbody></table></figure>
<p>现在就可以使用自己的域名访问 Hexo 博客了。</p>
<ol start="3">
<li>开启 HTTPS<br>配置自己的域名后，需要我们手动开启 HTTPS。打开博客所在 GitHub 仓库，Settings -&gt; 下拉找到 GitHub Pages -&gt; 勾选 Enforce HTTPS。<br>HTTPS 证书部署成功需要一定时间，等大概几分钟再访问域名，就可以看到域名前面的小绿锁了，HTTPS 配置完成！  </li>
</ol>
<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><p>进入博客所在目录，右键打开 Git Bash Here </p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">hexo new "name"       # 新建文章</span><br><span class="line">hexo new page "name"  # 新建页面</span><br><span class="line">hexo g                # 生成页面</span><br><span class="line">hexo d                # 部署</span><br><span class="line">hexo g -d             # 生成页面并部署</span><br><span class="line">hexo s                # 本地预览</span><br><span class="line">hexo clean            # 清除缓存和已生成的静态文件</span><br><span class="line">hexo help             # 帮助</span><br></pre></td></tr></tbody></table></figure>
<hr>
<p>也可以不使用命令自己创建 .md 文件，只需在文件开头手动加入如下格式 Front-matter 即可，写完后运行 <code>hexo g</code> 和 <code>hexo d</code> 发布。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello World # 标题</span><br><span class="line">date: 2000/01/01 hh:mm:ss # 时间</span><br><span class="line">categories: # 分类</span><br><span class="line">- Diary</span><br><span class="line">tags: # 标签</span><br><span class="line">- PS3</span><br><span class="line">- Games</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">这里需要补充文章的正文，加油哦</span><br></pre></td></tr></tbody></table></figure>


<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><ol>
<li><p>更换主题<br>在 Themes | Hexo 选择一个喜欢的主题，比如 NexT，进入网站目录打开 Git Bash Here 下载主题：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">git clone https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></tbody></table></figure>
<p>然后修改 <em>_config.yml</em> 中的 theme 为新主题名称 next，发布。（有的主题需要将 <em>_config.yml</em> 替换为主题自带的，参考主题说明。）</p>
</li>
<li><p>Hexo 设置显示文章摘要，首页不显示全文<br>Hexo 主页文章列表默认会显示文章全文，浏览时很不方便，可以在文章中插入 <code>&lt;!--more--&gt;</code> 进行分段。<br>该代码前面的内容会作为摘要显示，而后面的内容会替换为 “Read More” 隐藏起来。</p>
</li>
<li><p>设置网站图标<br>进入 themes/主题 文件夹，打开 <em>_config.yml</em> 配置文件，找到 favicon 修改，一般格式为：<code>favicon: 图标地址</code>。（不同主题可能略有差别）</p>
</li>
<li><p>修改并部署后没有效果<br>使用 <code>hexo clean</code> 清理后重新部署。</p>
</li>
<li><p>开启 HTTPS 后访问网站显示连接不安全<br>证书还未部署生效，等待一会儿，清除浏览器缓存再试。</p>
</li>
<li><p>Mac 安装 Hexo 报错无法安装<br>Mac 用户需要管理员权限运行，使用 <code>sudo npm install -g hexo-cli</code> 命令安装。</p>
</li>
<li><p>npm 下载速度慢，甚至完全没反应<br>使用 npm 安装程序等待很久也没反应，或者下载速度很慢，可以更换 npm 源为国内 npm 镜像。<br>临时更换方法：在 npm 安装命令后面加上：<code>--registry https://registry.npm.taobao.org</code></p>
</li>
<li><p>站点首页不显示文章全文<br>打开主题配置文件 _config.yml 文件，找到如下</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"> # Automatically Excerpt. Not recommend.</span><br><span class="line"># Please use &lt;!-- more --&gt; in the post to control excerpt accurately.</span><br><span class="line">auto_excerpt:</span><br><span class="line">  enable: false</span><br><span class="line">  length: 150</span><br></pre></td></tr></tbody></table></figure>
<p>把这里的false改为true就可以了在首页启动显示文章预览了，length是显示预览的长度。</p>
</li>
</ol>
<p>我们也可以通过在文章使用<code>&lt;!-- more --&gt;</code>标志来精确控制文章的摘要预览，比如这篇文章就是在这个段落的末尾添加了该标志，所以本文在首页的预览就会显示到这个段落为止。</p>
<p>本篇就这样吧，拜拜喽。<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/2728.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/2728.png?v8">✨</span><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/2728.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/2728.png?v8">✨</span>  </p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo添加emoji表情</title>
    <url>/2019/06/19/Hexo-addemjo/</url>
    <content><![CDATA[<p>废话不多说，直接动手干吧。 具体表情参考 <a href="https://github.com/caiyongji/emoji-list" target="_blank" rel="noopener">GFM 表情列表</a> <span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f61c.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f61c.png?v8">😜</span> </p>
<a id="more"></a>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">npm install hexo-filter-github-emojis --save</span><br><span class="line">npm un hexo-renderer-stylus --save</span><br><span class="line">npm i hexo-renderer-stylus-plus --save</span><br></pre></td></tr></tbody></table></figure>

<h1 id="打开-站点配置文件，添加以下内容"><a href="#打开-站点配置文件，添加以下内容" class="headerlink" title="打开 站点配置文件，添加以下内容"></a>打开 站点配置文件，添加以下内容</h1><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">githubEmojis:</span><br><span class="line">  enable: true</span><br><span class="line">  className: github-emoji</span><br><span class="line">  unicode: false</span><br><span class="line">  styles:</span><br><span class="line">  localEmojis:</span><br></pre></td></tr></tbody></table></figure>

<h1 id="解决渲染错误问题"><a href="#解决渲染错误问题" class="headerlink" title="解决渲染错误问题"></a>解决渲染错误问题</h1><ul>
<li>修改 <code>themes/next/layout/_partials/head.swig</code>, 解决渲染错误问题，渲染 emoji 表情时会被自动加上 a 标签<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;script type="text/javascript" id="hexo.configurations"&gt;</span><br><span class="line">  var NexT = window.NexT || {};</span><br><span class="line">  var CONFIG = {</span><br><span class="line">    root: '{{ theme.root }}',</span><br><span class="line">    scheme: '{{ theme.scheme }}',</span><br><span class="line">    sidebar: {{ theme.sidebar | json_encode }},</span><br><span class="line">    fancybox: {{ theme.fancybox }},</span><br><span class="line">    tabs: {{ theme.tabs.enable }},</span><br><span class="line">    motion: {{ theme.use_motion }},</span><br><span class="line">    duoshuo: {</span><br><span class="line">      userId: '{{ theme.duoshuo_info.user_id | default() }}',</span><br><span class="line">      author: '{{ theme.duoshuo_info.admin_nickname | default(__('author'))}}'</span><br><span class="line">    },</span><br><span class="line">    algolia: {</span><br><span class="line">      applicationID: '{{ theme.algolia.applicationID }}',</span><br><span class="line">      apiKey: '{{ theme.algolia.apiKey }}',</span><br><span class="line">      indexName: '{{ theme.algolia.indexName }}',</span><br><span class="line">      hits: {{ theme.algolia_search.hits | json_encode }},</span><br><span class="line">      labels: {{ theme.algolia_search.labels | json_encode }}</span><br><span class="line">    },</span><br><span class="line">    *{# ↓ 在这里修改，其他未动 ↓ #}</span><br><span class="line">    {# 添加 emojis 参数 #}</span><br><span class="line">    emojis: {</span><br><span class="line">      className: '{{ config.githubEmojis.className | default('github-emoji') }}'</span><br><span class="line">    }*</span><br><span class="line">  };</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure></li>
<li>修改 <code>themes/next/source/js/src/utils.js</code><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 注意看 CONFIG.emojis.className 那一行，其他未动</span><br><span class="line">$('.content img')</span><br><span class="line">  .not('[hidden]')</span><br><span class="line">  .not('.group-picture img, .post-gallery img, *img.' + CONFIG.emojis.className*)</span><br><span class="line">  .each(function () {</span><br><span class="line">  ……</span><br></pre></td></tr></tbody></table></figure>

</li>
</ul>
<h1 id="自定义emoji-样式"><a href="#自定义emoji-样式" class="headerlink" title="自定义emoji 样式"></a>自定义emoji 样式</h1><p>在 <code>站点配置文件</code> 中，我们配置：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">githubEmojis:</span><br><span class="line">  enable: true</span><br><span class="line">  className: github-emoji</span><br><span class="line">  unicode: false</span><br><span class="line">  styles:</span><br><span class="line">  localEmojis:</span><br></pre></td></tr></tbody></table></figure>
<p>在 <code>themes/next/source/css/_variables/base.styl</code> 中使用 hexo-site-config 方法获取 <code>站点配置文件</code> 中的值，我们添加</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// Github emojis class name</span><br><span class="line">// --------------------------------------------------</span><br><span class="line">get_emoji_class() {</span><br><span class="line">  emoji_class = hexo-site-config('githubEmojis.className')</span><br><span class="line">  return emoji_class ? emoji_class : 'github-emoji'</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">$github-emojis-class-name   = get_emoji_class()</span><br></pre></td></tr></tbody></table></figure>
<p>最后在自定义样式文件 <code>themes/next/source/css/_custom/custom.styl</code> 中添加：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">img.{$github-emojis-class-name} {</span><br><span class="line">  display: inline;</span><br><span class="line">  height: 1.7em;</span><br><span class="line">  width: 1.7em;</span><br><span class="line">  vertical-align: -0.4em;</span><br><span class="line">  border: none !important;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>到这里就可以啦。<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f340.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f340.png?v8">🍀</span>  </p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>修改Hexo博客NexT主题文章页面宽度</title>
    <url>/2019/06/19/Hexo-postwidth/</url>
    <content><![CDATA[<p>网上方法很多，我简单记录一种，手动修改样式，宽度自适应。</p>
<a id="more"></a>
<p><code>\themes\next\source/css/_schemes/Picses/_layout.styl</code>文件末尾添加如下代码即可</p>
<pre><code>// 以下为新增代码！！修改post宽度
header{ width: 80% !important; }
header.post-header {
  width: auto !important;
}
.container .main-inner { width: 80%; }
.content-wrap { width: calc(100% - 260px); }

.header {
  +tablet() {
    width: auto !important;
  }
  +mobile() {
    width: auto !important;
  }
}

.container .main-inner {
  +tablet() {
    width: auto !important;
  }
  +mobile() {
    width: auto !important;
  }
}

.content-wrap {
  +tablet() {
    width: 100% !important;
  }
  +mobile() {
    width: 100% !important;
  }
}</code></pre><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo NexT主题添加字数统计阅读时长</title>
    <url>/2019/06/19/Hexo-addwordcount/</url>
    <content><![CDATA[<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>NexT 主题默认已经集成了文章【字数统计】、【阅读时长】统计功能，如果我们需要使用，只需要在主题配置文件 <code>_config.yml</code> 中打开 wordcount 统计功能即可。<a id="more"></a>如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"># Post wordcount display settings</span><br><span class="line"># Dependencies: https://github.com/willin/hexo-wordcount</span><br><span class="line">post_wordcount:</span><br><span class="line">  item_text: true</span><br><span class="line">  wordcount: true         # 单篇 字数统计</span><br><span class="line">  min2read: true          # 单篇 阅读时长</span><br><span class="line">  totalcount: false       # 网站 字数统计</span><br><span class="line">  separated_meta: true</span><br></pre></td></tr></tbody></table></figure>

<h1 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h1><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">npm i --save hexo-wordcount</span><br><span class="line"># Node 版本7.6.0之前,请安装 2.x 版本 (Node.js v7.6.0 and previous)</span><br><span class="line">npm install hexo-wordcount@2 --save</span><br></pre></td></tr></tbody></table></figure>

<h1 id="post-添加"><a href="#post-添加" class="headerlink" title="post 添加"></a>post 添加</h1><p>如果还是不行，建议简单强暴添加，方法如下<br>打开<code>hexo\themes\hexo-theme-next\layout\_macro\post.swig</code> 文件，在文件类搜索关键词busuanzi，找到这段代码后</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">{% if not is_index and theme.busuanzi_count.enable and theme.busuanzi_count.post_views %}</span><br><span class="line">    &lt;span class="post-meta-divider"&gt;|&lt;/span&gt;</span><br><span class="line">    &lt;span class="post-meta-item-icon"</span><br><span class="line">    {% if not theme.post_meta.item_text %} title="{{ __('post.views') }}" {% endif %}&gt;</span><br><span class="line">    &lt;i class="fa fa-{{ theme.busuanzi_count.post_views_icon }}"&gt;&lt;/i&gt;</span><br><span class="line">    {% if theme.post_meta.item_text %} {{__('post.views') + __('symbol.colon') }} {% endif %}</span><br><span class="line">    &lt;span class="busuanzi-value" id="busuanzi_value_page_pv" &gt;&lt;/span&gt;</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">            </span><br><span class="line">{% endif %}</span><br></pre></td></tr></tbody></table></figure>
<p>在endif上面，即本文代码块那个空行处添加以下代码</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;span class="post-meta-divider"&gt;|&lt;/span&gt;</span><br><span class="line">&lt;span title="{{ __('post.wordcount') }}"&gt;&lt;span class="post-meta-item-icon"&gt;&lt;i class="fa fa-file-word-o"&gt;&lt;/i&gt;&lt;/span&gt;字数： {{ wordcount(post.content) }}&lt;/span&gt;</span><br></pre></td></tr></tbody></table></figure>


<h1 id="全站添加"><a href="#全站添加" class="headerlink" title="全站添加"></a>全站添加</h1><p>打开<code>hexo\themes\hexo-theme-next\layout\_partials\footer.swig</code> 文件，新增如下代码</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;div class="theme-info"&gt;</span><br><span class="line">  &lt;div class="powered-by"&gt;&lt;/div&gt;</span><br><span class="line">  &lt;span class="post-count"&gt;全站共 {{ totalcount(site) }} 字&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></tbody></table></figure>


<p>到这里就可以啦，快去试试吧。  </p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>网络工程师基础</title>
    <url>/2018/10/25/OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="OSI"><a href="#OSI" class="headerlink" title="OSI"></a>OSI</h1><p>OSI（开放系统互联(Open System Interconnection)），把网络通信的工作分为7层,分别是物理层,数据链路层,网络层,传输层,会话层,表示层和应用层。</p>
<a id="more"></a>  
<p>通俗理解如下：<br>物理层就是布线、光纤和其它电子设备，用来把两台网络通信设备连接在一起的东西。<br>数据链路层就是MAC地址、交换机或者网卡和驱动程序，主要任务是把数据帧转换成二进制位供一层处理。<br>网络层最主要的设备是路由器，主要作用是为了在数据外围针对IP地址路由的交换。<br>传输层作用是每台计算机每台应用程序与他人发生通讯，互联端口的协议。<br>会话层，两者之间的通讯过程就是一次会话过程。<br>表示层，规范编码问题。负责转换为适合于OSI系统内部使用的传送语法。即提供格式化的表示和转换数据服务。数据的压缩和解压缩， 加密和解密等工作。<br>应用层用于应用程序，确定进程之间通信的性质以满足用户需要以及提供网络与用户应用软件之间的接口服务如果你的程序需要一种具体格式的数据。  </p>
<img src="/2018/10/25/OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B/osi_desc.png" class="" title="OSI的七层模型">  


<h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><p>为数据端设备提供传送数据的通路，传输数据</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>网络通信</category>
      </categories>
      <tags>
        <tag>网络通信</tag>
        <tag>OSI</tag>
      </tags>
  </entry>
  <entry>
    <title>轻量级标记语言Markdown的语法（GFM）</title>
    <url>/2018/10/18/Markdown-GFM/</url>
    <content><![CDATA[<p>Hexo下使用的MarkDown是Github的GFM，整理汇总常用语法命令方便后续查找。此篇包含常用的语法，当然也一些偶尔会用到的，基本上可以满足日常使用。</p>
<a id="more"></a>
<h1 id="常用基础"><a href="#常用基础" class="headerlink" title="常用基础"></a>常用基础</h1><p><strong>字体相关</strong><br>斜体:用 <code>*</code> 或 <code>_</code> 包裹，紧贴被强调文本 </p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">*斜体文本*</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p><em>我这是测试斜体哦</em></p>
</blockquote>
<p>粗体:用 <code>**</code> 或 <code>__</code> 包裹，紧贴被强调文本 </p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">**粗体文本**</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p><strong>我这是测试粗体哦</strong></p>
</blockquote>
<p>删除线： 用 <code>~~</code> 包裹被删除文本</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">~~我这是测试删除文字哦~~</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p><del>我这是测试删除文字哦</del></p>
</blockquote>
<p><strong>段落</strong><br>文本行 : 即一行文字，markdown 中换行必须进行手动操作，自动换行将会变成一个空格<br>段　落 : 由数行文字成一段，markdown 中由空行划分段落。输入两个以上空格再回车，进行手动换行</p>
<p><strong>标题</strong><br>底线形式(Setext) : 标题下方插入任意数量的<code>=</code>(一级标题）或<code>-</code>（二级标题）<br>井号形式(atx) : 标题行首插入1至6个<code>#</code>加上空格，构成一至六级标题</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">一级标题</span><br><span class="line">=</span><br><span class="line">二级标题</span><br><span class="line">-------</span><br><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></tbody></table></figure>
<p><strong>引用区块</strong><br>段落行首插入 &gt; 。插入多个 &gt; 可在区块内实现多重嵌套</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&gt;aaa</span><br><span class="line">bbb</span><br><span class="line"></span><br><span class="line">&gt;aaa</span><br><span class="line">&gt;bbb</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>aaa<br>bbb</p>
</blockquote>
<blockquote>
<p>aaa<br>bbb</p>
</blockquote>
<p><strong>列表</strong><br>无序列表 : 行首插入 <code>*</code>、<code>+</code> 或 <code>-</code> ，加上一个空格 <code></code> 可生成无序列表项目，可通过制表符进行多重嵌套<br>有序列表 : <code>数字.</code> + <code></code>可生成相应编号列表项目，可通过制表符进行多重嵌套</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">* 项目一</span><br><span class="line">* 项目二</span><br><span class="line"></span><br><span class="line">+ 项目一</span><br><span class="line"> + 项目二</span><br><span class="line">  + 项目三</span><br><span class="line"></span><br><span class="line">- 项目一</span><br><span class="line">- 项目二</span><br><span class="line"></span><br><span class="line">1. 项目一</span><br><span class="line">2. 项目二</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>项目一</li>
<li>项目二</li>
</ul>
<ul>
<li>项目一<ul>
<li>项目二</li>
<li>项目三</li>
</ul>
</li>
</ul>
<ul>
<li>项目一</li>
<li>项目二</li>
</ul>
<ol>
<li>项目一</li>
<li>项目二</li>
</ol>
<p><strong>代码块</strong><br>原生 md使用一个制表符（4个空格）进行缩进即可生成代码区块<br>GFM采用围栏式代码区块，在代码上下一行使用三个反引号 ```， 并在第一行反引号后自定义代码语种，支持相应语种的代码高亮  </p>
<p><strong>行内代码</strong>：用 ` 包裹<br><code>hello world！</code></p>
<p><strong>链接</strong><br>行内式 : <code>[显示文本](链接 "标签")</code><br>参考式 : <code>[显示文本][唯一id]</code>，然后于文章任意处起一行 : <code>[唯一id]: 链接 "链接标题"</code><br>自动式 : <code>&lt;链接&gt;</code>, 必须标明通讯协议<br>标题锚 : <code>[显示文本](#某个标题)</code></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">有问题？有[必应](https://www.bing.com "bing.com")！  </span><br><span class="line">有问题？别[百度][1]！  </span><br><span class="line">可能的话，用 &lt;https://www.google.com&gt; 好一点。  </span><br><span class="line">[脚注](#脚注)其实也有点像标题锚的其实, 但更像 html 中的锚  </span><br><span class="line">...</span><br><span class="line">[1]: https://www.baidu.com</span><br></pre></td></tr></tbody></table></figure>


<p><strong>分割线</strong><br>在一行中使用3个及以上的 <code>*</code> 、<code>-</code> 或 <code>_</code> 可生成分割线， 符号之间允许有空格但不允许有任何字符，三个以上 <code>-</code> 推荐用 <code>- - -</code> 表示，防止产生与标题相同的歧义</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">第一段</span><br><span class="line">- - -</span><br><span class="line">第二段</span><br><span class="line">***</span><br><span class="line">第三段</span><br><span class="line">___</span><br><span class="line">第四段</span><br></pre></td></tr></tbody></table></figure>

<p><strong>图片</strong><br>使用 ! ，在图片链接之前添加就可以额<br>行内式:<code>![](图片链接 "图片标签")</code><br>参考式:<code>![][唯一id]</code>，然后于文章任意处起一行 : <code>[唯一id]: 图片链接 "图片标签"</code></p>
<h1 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h1><p><strong>emoji 表情</strong><br>如 :smile: 为 <code>:smile:</code> , :kissing: 为 <code>:kissing:</code>。具体表情参考 <a href="https://github.com/caiyongji/emoji-list" target="_blank" rel="noopener">GFM 表情列表</a> <span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f61c.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f61c.png?v8">😜</span> </p>
<p>如果不知道如何添加emoji表情，请 <a href="https://novnan.github.io/Hexo/emojis-for-hexo-next/" target="_blank" rel="noopener">参考文章</a></p>
<p><strong>不同的列表嵌套方法</strong><br>每缩进指定数量空格，嵌套一层列表，空格数量可以自行设定</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">* 项目一</span><br><span class="line">* 项目二</span><br><span class="line">    * part a</span><br><span class="line">    * part b</span><br><span class="line">    * part c</span><br><span class="line">        * chapter one</span><br><span class="line">        * chapter two</span><br><span class="line">* 项目三</span><br></pre></td></tr></tbody></table></figure>
<p><strong>表格</strong><br>表格为横行竖列，首行为标题，第二行指定表格内容布局，第三行开始为表格数据，示例如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">标题一 | 标题二 | 标题三</span><br><span class="line">- | :-: | -:</span><br><span class="line">a | 一 | 1</span><br><span class="line">b | 二 | 2</span><br><span class="line">c | 三 | 3.1 task1&lt;br/&gt;3.2 task2&lt;br/&gt;3.3 task3&lt;br/&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>解析：<br><code>|</code> 作为表格列的分割标志<br><code>:- | :-: | -:</code>作为表格标题与内容的分割标志，同时控制内容的布局，<code>:-</code> 表示左对齐，相应的后两个为居中和右对齐， <code>-</code> 数量不限，<code>-</code> 默认为左对齐</p>
<table>
<thead>
<tr>
<th>标题一</th>
<th align="center">标题二</th>
<th align="right">标题三</th>
</tr>
</thead>
<tbody><tr>
<td>a</td>
<td align="center">一</td>
<td align="right">1</td>
</tr>
<tr>
<td>b</td>
<td align="center">二</td>
<td align="right">2</td>
</tr>
<tr>
<td>c</td>
<td align="center">三</td>
<td align="right">3.1 task1<br>3.2 task2<br>3.3 task3<br></td>
</tr>
</tbody></table>
<p><strong>任务列表</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">- [x] Task 1</span><br><span class="line">- [ ] Task 2</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><input checked="" disabled="" type="checkbox"> Task 1</li>
<li><input disabled="" type="checkbox"> Task 2</li>
</ul>
<p>本篇结束了，拜拜喽。<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f490.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f490.png?v8">💐</span>  </p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
</search>
