{"meta":{"title":"手册集","subtitle":null,"description":"记录开发学习中遇到的问题和知识点，作为当时的思维梳理，同时方便后续翻阅。","author":"xugz","url":"https://xlline.github.io","root":"/"},"pages":[{"title":"关于我","date":"2019-10-24T07:13:08.000Z","updated":"2019-10-25T02:55:00.000Z","comments":true,"path":"about/index.html","permalink":"https://xlline.github.io/about/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"分类","date":"2019-10-24T07:26:14.000Z","updated":"2019-10-25T02:41:46.000Z","comments":true,"path":"categories/index.html","permalink":"https://xlline.github.io/categories/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"标签","date":"2019-10-24T07:26:08.000Z","updated":"2019-10-25T02:41:51.000Z","comments":true,"path":"tags/index.html","permalink":"https://xlline.github.io/tags/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"}],"posts":[{"title":"win10系统配置自动更新重启","slug":"windows_restart_fix","date":"2021-08-15T01:15:21.000Z","updated":"2021-09-19T02:30:22.304Z","comments":true,"path":"2021/08/15/windows_restart_fix/","link":"","permalink":"https://xlline.github.io/2021/08/15/windows_restart_fix/","excerpt":"重装系统后，工作机第二天总会自动重启。在事件查看器中，点击 Windows 日志-系统，筛选当前日志，在日志筛选器中选择事件来源为 eventlog，找到最近的 eventlog 日志信息。观察发现电脑会定时在凌晨三点钟左右自动更新重启。下面是解决该问题的方法。","text":"重装系统后，工作机第二天总会自动重启。在事件查看器中，点击 Windows 日志-系统，筛选当前日志，在日志筛选器中选择事件来源为 eventlog，找到最近的 eventlog 日志信息。观察发现电脑会定时在凌晨三点钟左右自动更新重启。下面是解决该问题的方法。 方法一windows + r 键入 gpedit.msc 唤起本地组策略编辑器打开 管理模板打开 windows 组件打开 windows 更新选择 配置自动更新 将其禁用 即可 方法二本机搜索 服务，打开 Windows 服务管理窗口找到 windows update 右键选择属性在 属性 常规TAB窗口中 找到 启动类型，把启动类型设置为 禁用需要注意，该配置变更在重启后生效 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Windows","slug":"Windows","permalink":"https://xlline.github.io/categories/Windows/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://xlline.github.io/tags/Windows/"}]},{"title":"nvm的安装和使用","slug":"nvm","date":"2020-07-05T04:17:29.000Z","updated":"2022-06-05T01:25:02.387Z","comments":true,"path":"2020/07/05/nvm/","link":"","permalink":"https://xlline.github.io/2020/07/05/nvm/","excerpt":"nvm是一个Node.js的版本管理工具，在指定路径安装多个 node 版本，通过 nvm 命令切换时，就会变更我们环境变量中 node 命令指定的实际执行的软件路径。当我们同时进行多个项目时，存在需求差异大，对依赖的 Node 版本也不一样，这种情况就可以通过 nvm 来切换 Node.js 版本。","text":"nvm是一个Node.js的版本管理工具，在指定路径安装多个 node 版本，通过 nvm 命令切换时，就会变更我们环境变量中 node 命令指定的实际执行的软件路径。当我们同时进行多个项目时，存在需求差异大，对依赖的 Node 版本也不一样，这种情况就可以通过 nvm 来切换 Node.js 版本。 nvm 对应GitHub地址 入口 安装（Windows）下载安装包，地址点我进入双击解压后的文件 nvm-setup.exe 会提示选择 nvm 的安装路径和 Node 各版本的安装路径。注意安装路径文件夹名不要出现 中文 和 空格。运行cmd， 键入nvm， 如果安装成功会显示nvm版本和命令列表。 安装（Liunx）下载安装nvm 123curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh | bash# 或者wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh | bash 写入必要配置 123456#编辑文件vim ~/.bashrc#写入配置export NVM_DIR=\"$HOME/.nvm\"[ -s \"$NVM_DIR/nvm.sh\" ] &amp;&amp; . \"$NVM_DIR/nvm.sh\" # This loads nvm 刷新配置source ~/.bashrc 判断nvm是否安装nvm -v 相关命令nvm list 同 nvm list installed 显示已安装的版本nvm list available 显示所有可以下载的版本nvm install 14.5.0 安装指定版本的Nodenvm install latest 安装最新版本Nodenvm use 14.5.0 使用14.5.0指定版本的Nodenvm uninstall 14.5.0 卸载指定版本的Nodenvm version 同 nvm v 显示nvm的版本nvm arch 显示Node节点是在 32 位还是 64 位模式下运行 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"num","slug":"num","permalink":"https://xlline.github.io/categories/num/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://xlline.github.io/tags/Git/"}]},{"title":"Windows PHP开发环境 WSL + VsCode","slug":"WSL_VsCode","date":"2020-06-12T06:05:21.000Z","updated":"2022-09-23T01:06:34.074Z","comments":true,"path":"2020/06/12/WSL_VsCode/","link":"","permalink":"https://xlline.github.io/2020/06/12/WSL_VsCode/","excerpt":"使用VsCode+WSL进行开发，下面是必要配置，以及部分常用VsCode插件推荐。","text":"使用VsCode+WSL进行开发，下面是必要配置，以及部分常用VsCode插件推荐。 Windows 环境设置 打开win10系统的开发者选项在“设置” &gt; “更新和安全” &gt; “开发人员选项” 中 打开开发人员模式。详细操作点我参考 打开win10系统的子系统设置“控制面板” &gt; “程序和功能” &gt; “启用或关闭Windows选项” 中找到 “适用于Linux的Windows子系统” 并勾选,然后 确定 选择 立即重新启动。 安装Ubuntu系统 在微软商店中搜索 Ubuntu 并安装 Ubuntu 18.04 版本 安装完成后，首先运行一次 Ubuntu，使其初始换完成，并输入自己的用户名和密码。 下载安装VsCodeVsCode 官网地址必要插件推荐 WSL链接相关插件 Remote - WSL 中文语言包 Chinese VsCode 主题包 vscode-icons Git相关 Git History 和 GitLens PHP相关 PHP Intelephense PHP Extension Pack PHP DocBlocker PHP Debug phpfmt - PHP formatter 前端相关 Vue插件 Vetur 其他 env文件的管理插件 DotENV 注意 子系统中的 hosts 文件每次重启后会通过 Windows 中的 hosts 重新生成。所以添加 hosts 配置时，需要在两个文件中都添加。 Windows WSL 中安装的 Nginx / PHP-FPM 超时问题子系统中的 nginx 需要关闭 PHP 的缓存配置 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"PHP","slug":"PHP","permalink":"https://xlline.github.io/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://xlline.github.io/tags/PHP/"},{"name":"VsCode","slug":"VsCode","permalink":"https://xlline.github.io/tags/VsCode/"}]},{"title":"Git的HTTP协议凭证存储","slug":"Redis-credential","date":"2020-05-22T10:27:53.000Z","updated":"2021-09-11T08:21:28.645Z","comments":true,"path":"2020/05/22/Redis-credential/","link":"","permalink":"https://xlline.github.io/2020/05/22/Redis-credential/","excerpt":"凭证存储为了解决Git使用HTTP协议访问远程仓库账号密码需要多次输入的问题。","text":"凭证存储为了解决Git使用HTTP协议访问远程仓库账号密码需要多次输入的问题。 解决这个问题，我们可以使用git-credential-store和git-credential-cache来管理密码，前者在文件（.gitconfig文件同目录下的.git-credentials中）中用明文存储密码，后者存在内存中。命令如下： 12345678// 默认15分钟 将账号密码存储在内存git config --global credential.helper cache// 设置一个小时内记住密码git config credential.helper 'cache --timeout=3600'// 密码存储到磁盘git config --global credential.helper store// 删除credential配置git config --system --unset credential.helper 也可以依赖第三方：Mac系统，Git默认提供osxkeychain辅助程序来管理你的密码，使用命令git config --global credential.helper osxkeychain实现。Windows系统，安装git-credential-winstore全称是Windows Credential Store for Git，可以将https方式的Git登陆用户名和密码保存在Windows自带的凭据管理系统中，比credential.helper方式更加安全。安装方式：1、下载后解压文件后复制git-credential-winstore.exe 文件到git安装目录的bin目录里面2、将 Git 添加到环境变量。打开环境变量（计算机右键 - &gt; 高级系统设置 -&gt; 环境变量 -&gt; 在系统变量里面找到path双击 ）3、将 Git 安装目录bin文件夹目录添加到步骤2打开的path的最后面，前面添加一个分号。4、双击 bin 目录下的 git-credential-winstore.exe 文件，有个浮层，一般点击是按钮。5、重启 git bash ，会有一个浮层让你输入用户名和密码。 如果安装的是GitGUI，则提供的是git-credential-manager。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Git","slug":"Git","permalink":"https://xlline.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://xlline.github.io/tags/Git/"},{"name":"credential","slug":"credential","permalink":"https://xlline.github.io/tags/credential/"}]},{"title":"Redis集群配置","slug":"Redis-config","date":"2020-05-16T06:17:53.000Z","updated":"2021-09-11T08:21:23.074Z","comments":true,"path":"2020/05/16/Redis-config/","link":"","permalink":"https://xlline.github.io/2020/05/16/Redis-config/","excerpt":"本文是在本地环境学习配置Redis集群的流程文。使用Redis版本为5.0.8，基于VMware中的centOS7系统。","text":"本文是在本地环境学习配置Redis集群的流程文。使用Redis版本为5.0.8，基于VMware中的centOS7系统。 安装选择自己喜欢需要的版本，根据Redis官方文档引导执行安装编译。 1234567cd ~mkdir redis-clustercd redis-cluster # 该文件我用来存放redis源码wget http://download.redis.io/releases/redis-5.0.8.tar.gztar xzf redis-5.0.8.tar.gzcd redis-5.0.8make 执行完成。为了方便操作，我将在src目录下生成的可执行文件拷贝到/usr/local/redis目录下。执行命令如下 123456789cd /usr/localsudo mkdir redis sudo chown -R xugz:xugz rediscd redismkdir bin confcd bincp ~/redis-cluster/redis-5.0.8/src/redis-* .cd ../conf # 进入conf文件夹，将源码中的redis配置文件拷贝过来，重命名为6380.conf（我虚拟机上6379端口已被占用）cp ~/redis-cluster/redis-5.0.8/redis.conf 6380.conf 配置最简单的主从为了方便我在同一台机器上启动两个实例实现。 启动master修改配置文件必要选项，如将port修改为未被占用的端口如6380。将 daemonize改为 yes，后台程序方式运行。修改pidfile，让其生成到有权限的目录下pidfile /usr/local/redis/redis_6380.pid指定6380.conf为其配置文件，启动实例 /usr/local/redis/bin/redis-server /usr/local/redis/conf/6380.conf。 启动slave复制一份redis配置文件命名为6381.conf，修改对应的端口和pidfile配置。加入 slaveof 127.0.0.1 6380，意思是将自己作为127.0.0.1主机6380端口的备服。启动实例 /usr/local/redis/bin/redis-server /usr/local/redis/conf/6381.conf。 使用ps -ef | grep redis检查两个进程是否正常存在。使用./redis-cli -h 127.0.0.1 -p 6380命令指定端口和服务器进入客户端，使用info命令查看Replication选项确定是否配置成功，使用role也可。 1234# Replicationrole:master # 角色，master代表是主机connected_slaves:1 # 连接的从机的数量 我们这里只配置了6381一个slave0:ip=127.0.0.1,port=6381,state=online,offset=280,lag=0 下图为验证主备功能的。图片显示6380主服务器可读可写，6381备服只有读取权限。 使用哨兵模式实现主从切换参考Redis中文文档中对哨兵的描述 Redis的Sentinel系统用于管理多个Redis服务器（instance），该系统执行以下三个任务: 监控（Monitoring）：Sentinel会不断地检查你的主服务器和从服务器是否运作正常。 提醒（Notification）：当被监控的某个Redis服务器出现问题时，Sentinel可以通过API向管理员或者其他应用程序发送通知。 自动故障迁移（Automatic failover）：当一个主服务器不能正常工作时，Sentinel会开始一次自动故障迁移操作，它会将失效主服务器的其中一个从服务器升级为新的主服务器， 让失效主服务器的其他从服务器改为复制新的主服务器；当客户端试图连接失效的主服务器时，集群也会向客户端返回新主服务器的地址，使得集群可以使用新主服务器代替失效服务器。 配置Redis 源码中包含了一个名为 sentinel.conf 的文件， 这个文件是一个带有详细注释的 Sentinel 配置文件示例。运行一个 Sentinel 所需的配置如下所示： 12345678910111213141516// 端口port 6380 // 工作目录dir /usr/local/redis/tmp// 指定的要检测的实例。参数分别是 别名 ip 端口 server异常时需要确认异常的哨兵个数。1表示至少1个setinel实例同时检测到redis server异常时才将redis server的状态判决为\"宕机\"sentinel monitor mymaster 127.0.0.1 6380 1 // 指定某个sentinel实例监控到某个redis实例持续异常多长时间后，会判决其状态为down。单位毫秒sentinel down-after-milliseconds mymaster 60000 // 若sentinel在该配置值内未能完成failover操作（即故障时master/slave自动切换），则认为本次failover失败sentinel failover-timeout mymaster 180000 // 指定failover过程中，同时被sentinel reconfigure的最大slave实例数。由于reconfigure过程中，对应的slave会中断响应客户端请求，故为避免所有的slave同时不可用，该值需适当配小。sentinel parallel-syncs mymaster 1// know-salve 代表已知的从机sentinel known-slave mymaster 127.0.0.1 6381 // 同时一时间最多3个slave可同时更新配置sentinel leader-epoch mymaster 3 将Redis源码中的 sentinel.conf 的文件拷贝到/usr/local/redis/conf目录下，修改自身需要的配置选项。 启动对于 redis-sentinel 程序，可以用./redis-sentinel /path/to/sentinel.conf命令来启动 Sentinel 系统。或者使用nohup /usr/local/redis/bin/redis-sentinel /usr/local/redis/conf/sentinel.conf &amp;不挂断地运行命令。对于 redis-server 程序，可以用./redis-server /path/to/sentinel.conf --sentinel命令来启动一个运行在 Sentinel 模式下的 Redis 服务器。启动完成后我进行了数据验证，下图是验证用到的相关命令（注意redis服务的切换） 通过上图的验证我们发现：本来主机是6380可以读写，从服务器是6381只可读。手动杀掉主服务器的运行进程，等待最大持续异常时间（down-after-milliseconds）后，哨兵会将主服务器自动切换成6381，将6380作为6381的备服。即使我们后续将6380再次启动，6380仍是6381的备服，数据只读。这在哨兵的服务进程中也有体现，见下图 主从从配置如果让所有的slave节点数据的复制和同步都由master节点来处理，会造成master节点I/O压力过大。所以我们打算将6380作为主服务器，用于写入操作，6381和6382作为备服负责读操作。为了减轻master压力，让6382数据备份来源改成6381，实现主从从模式。 配置修改redis.conf确认以下参数：port、pidfile、daemonize、dbfilename和dir。将slaveof选项添加到备服。将6382数据备份来源改成6381，6381的数据备份来源还是6380。6382的部分配置如下 1234567bind 127.0.0.1port 6382daemonize yespidfile \"/usr/local/redis/redis_6382.pid\"slaveof 127.0.0.1 6381dbfilename \"dump6382.rdb\"dir \"/usr/local/redis/datadir/\" Sentinel.conf哨兵启动后其实自动修改配置文件，一般建议不要手工修改。如果之前配的是一主多从，配置中会存在sentinel known-slave选项。如果我们要配置主从从，要把多余的从在配置文件手工删掉。 便捷操作为了操作方便，将多台服务启动命令整合到可执行脚本。 server_start该脚本是为了方便启动redis server。在~/redis-cluster目录下新增文件server_start，同时启动三台redis实例和哨兵后台运行。脚本内容如下 1234/usr/local/redis/bin/redis-server /usr/local/redis/conf/6380.conf/usr/local/redis/bin/redis-server /usr/local/redis/conf/6381.conf/usr/local/redis/bin/redis-server /usr/local/redis/conf/6382.confnohup /usr/local/redis/bin/redis-sentinel /usr/local/redis/conf/sentinel.conf &amp; cli_start该脚本是为了方便启动redis server。在~/redis-cluster目录下新增文件cli_start，可支持传入端口参数。脚本内容如下 1234567#!/bin/bashif [ -n \"$1\" ] #-n 传入参数不为空 $1代表第二参数，$0是可执行文件名自己本身 then /usr/local/redis/bin/redis-cli -h 127.0.0.1 -p $1 else echo \"error,no port\"fi 将redis server启动后，使用./cli-start port命令进入客户端，各自键入info命令尝试插入获取数据验证发现：6380为master，可读可写。其有一个从服为6381，6381角色为slave，他也有一个从服为6382。6381和6382都只可读。 cluster集群参考Redis中文文档中对集群的描述 配置搭建集群的第一件事情我们需要一些运行在 集群模式的Redis实例. 这意味这集群并不是由一些普通的Redis实例组成的，集群模式需要通过配置启用，开启集群模式后的Redis实例便可以使用集群特有的命令和特性了. 下面是一个最少选项的集群的配置文件: 123456789101112131415161718port 7000pidfile \"/usr/local/redis/redis_7000.pid\"# 表示打开集群 cluster-enabled yes cluster-node-timeout 5000# 开启AOF存储模式appendonly yes #集群模式下,每个redis节点生成一个配置文件，由redis自己维护。文件名区分开即可 下面两个文件名如果不像我一样放在同目录的话，可以不修改cluster-config-file nodes_7000.confappendfilename \"appendonly_7000.aof\"# 注释掉dbfilename 关闭RDB改用AOF# dbfilename # 关掉RDB存储save \"\"#save 900 1#save 300 10#save 60 1000 要让集群正常运作至少需要三个主节点，不过在刚开始试用集群功能时， 官方强烈建议使用六个节点： 其中三个为主节点， 而其余三个则是各个主节点的从节点。所以我们创建进入一个新目录cluster_conf，并创建六个以端口号为名字的Redis.conf文件，文件的内容可以使用上面的示例配置文件，稍后我们将运行六个Redis实例。 安装Ruby低版本的redis需要安装ruby环境，现在高版本的redis-cli已经支持集群了，不再需要安装ruby了。 切换到root账号，执行默认安装。 123su - root yum -y install ruby ruby-devel rubygems rpm-buildgem install redis 或者编译安装。官方下载地址 wget https://cache.ruby-lang.org/pub/ruby/2.4/ruby-2.7.1.tar.gz --no-check-certificate 搭建集群首先启动六个实例，我们可以使用/usr/local/redis/bin/redis-server /usr/local/redis/cluster_conf/7000.conf命令一条条启动，也可以封装到可执行脚本中。启动完成 ps -ef | grep redis 查看如下 现在我们已经有了六个正在运行中的 Redis 实例， 接下来我们需要使用这些实例来创建集群， 并为每个节点编写配置文件。通过使用 Redis 集群命令行工具 redis-trib ，编写节点配置文件的工作可以非常容易地完成：redis-trib 位于 Redis 源码的 src 文件夹中，它是一个 Ruby 程序，这个程序通过向实例发送特殊命令来完成创建新集群，检查集群，或者对集群进行重新分片（reshared）等工作。 创建一个新的集群, 选项–replicas 1 表示我们希望为集群中的每个主节点创建一个从节点。下面命令默认创建7000 7001 7002 为主节点，7003 7004 7005为备节点。低版本使用：./redis-trib.rb create --replicas 1 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005Redis5.0后不再支持上条命令，需要使用redis-cli来实现。如下./redis-cli --cluster create 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 --cluster-replicas 1之后跟着的其他参数则是这个集群实例的地址列表,3个master3个slave redis-trib 会打印出一份预想中的配置给你看，如果你觉得没问题的话，就可以输入yes，redis-trib 就会将这份配置应用到集群当中,让各个节点开始互相通讯,最后可以得到如下信息： [OK] All nodes agree about slots configuration.[OK] All 16384 slots covered. 这表示集群中的 16384 个槽都有至少一个主节点在处理， 集群运作正常。此时，我们可以使用redis-cli -c -p 7000命令连接到7000端口的客户端，也可以通过脚本进入。相关验证如下图 官方提供了一个自动化脚本,在 redis源码目录的utils文件夹，下面有个create-cluster文件夹，下面有个create-cluster脚本。也可以根据里面的代码进行脚本执行搭建。 常见错误ERR Slot xxxxx is already busy (Redis::CommandError)如果上一次运行出错，则必须去datadir对应目录去手工删除自动生成的cluster配置文件。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Redis","slug":"Redis","permalink":"https://xlline.github.io/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://xlline.github.io/tags/Redis/"},{"name":"cluster","slug":"cluster","permalink":"https://xlline.github.io/tags/cluster/"},{"name":"sentinel","slug":"sentinel","permalink":"https://xlline.github.io/tags/sentinel/"}]},{"title":"Git常用命令整理","slug":"Git-base","date":"2020-03-11T06:51:37.000Z","updated":"2022-06-05T01:24:49.037Z","comments":true,"path":"2020/03/11/Git-base/","link":"","permalink":"https://xlline.github.io/2020/03/11/Git-base/","excerpt":"整理 Git 中常见、常用命令提供快速翻阅。","text":"整理 Git 中常见、常用命令提供快速翻阅。 使用 git --version 查看当前版本。 Git 配置git config --list 命令用来列出所有 Git 当时能找到的配置。通过输入 git config &lt;key&gt; 来检查 Git 的某一项配置。 设置你的用户名和邮件地址 12git config --global user.name \"xugz\"git config --global user.email \"xugz_@outlook.com\" git config --global alias.last 'log -1 HEAD' 创建别名。此时我们可以用 git last 命令代替 git log -1 HEAD 来查看最后一次提交。git config --global core.autocrlf false 设置是否自动转化行结束符。 windows下和linux下的文本文件的换行符不一致。 windows：两个字符，CR+LF，即一个回车，一个换行 linux及OS X：一个字符，LF，在Linux下查看文件会在行末多个^M。 在windows下，git安装时，默认该选项为true，从仓库下载下来，结尾会改为CRLF格式。当提交文件到仓库时，会将CRLF格式转为LF。这样可以保证仓库中的文件是LF结尾的。 windows下开发将编辑器默认设置为LF格式（如VSCode，在settings中设置file:eol 选项为\\n），core.autocrlf 该项设置为false最好。 获取 Git 仓库通常有两种获取 Git 项目仓库的方式： 将尚未进行版本控制的本地目录转换为 Git 仓库； 从其它服务器 克隆 一个已存在的 Git 仓库 使用 git init 在已存在的本地目录中初始化仓库。 git clone &lt;url&gt; [rename_dir_name] 命令将指定仓库克隆下来，默认配置下远程 Git 仓库中的每一个文件的每一个版本都将被拉取下来。这会在当前目录下创建 和你指定URL对应仓库名同名 的目录，并在这个目录下初始化一个 .git 文件夹， 从远程仓库拉取下所有数据放入 .git 文件夹，然后从中读取最新版本的文件的拷贝。如果你想在克隆远程仓库的时候，自定义本地仓库的名字，你可以通过额外的参数指定新的目录名。 分支操作git branch 会列出你在本地的分支。git branch &lt;branch_name&gt; 使用该命令创建新分支。git branch -d &lt;branch_name&gt; 删除指定分支。git branch -v 查看每一个分支的最后一次提交。git branch --merged 查看哪些分支已经合并到当前分支， git branch --no-merged 查看尚未合并到当前分支的分支。 git checkout &lt;branch_name&gt;切换分支。git checkout -b &lt;branch_name&gt; 创建新分支并切换。 git stash 命令用来临时地保存一些还没有提交的工作，以便在分支上不需要提交未完成工作就可以清理工作目录。git stash list 用以查看贮藏的内容。git stash apply [stash_name] 应用指定贮藏版本，不指定的话默认最新的贮藏。git stash drop [stash_name] 删除指定贮藏版本。git stash clean 清空所有贮藏版本。 git merge &lt;branch_name&gt; 将指定分支合并到你的当前分支。 查看变更用 git status 命令查看文件状态。-s 选项可以以简洁的方式查看更改。新添加的未跟踪文件前面有 ?? 标记，新添加到暂存区中的文件前面有 A 标记，修改过的文件前面有 M 标记。 git diff 能通过文件补丁的格式具体地显示尚未缓存文件的变更对比。git diff --staged 或 git diff --cached 命令查看已暂存的将要添加到下次提交里的内容，这条命令将比对已暂存文件与最后一次提交的文件差异。git diff HEAD 查看已缓存文件的与未缓存文件的所有改动。git diff --stat 显示变动摘要。 用 git log 用 --oneline 选项来查看历史记录的紧凑简洁的版本。使用 git log --oneline --graph 选项，开启了拓扑图查看历史中什么时候出现了分支、合并。 提交变更用 git add &lt;filename/.&gt; 命令添加需要追踪的新文件和待提交的更改。 git checkout &lt;filename&gt;/. 撤销对指定文件/所有变更的修改。 git commit 提交更新。-m 用于备注提交说明。 -a 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤。--amend 选项用来重新提交。例如，你提交后发现忘记了暂存某些需要的修改，可以像下面这样操作。从效果上来说，就像是旧的提交从未存在过一样，它并不会出现在仓库的历史中。 123git commit -m 'initial commit'git add forgotten_filegit commit --amend 用 git rm &lt;filename&gt; 从暂存区域移除指定文件。 git reset HEAD/&lt;filename&gt; 取消缓存已缓存的全部内容/指定文件。 git mv file_from file_to 移动/重命名已跟踪的文件。 忽略本地指定文件变更，比如本地配置了开发环境参数，不需要提交git update-index --assume-unchanged &lt;filename&gt; 当需要提交该文件时，执行 git update-index --no-assume-unchanged &lt;filename&gt; 取消忽略 远程仓库的使用git remote -v 命令查看已经配置的远程仓库服务器名字及对应URL。git remote add &lt;shortname&gt; &lt;url&gt; 添加一个新的远程 Git 仓库，同时指定一个方便使用的简写。 git fetch &lt;remote&gt; 从远端仓库获取新分支与数据。 git pull 从远端仓库提取数据并尝试合并到当前分支。 git push [alias] [branch] 推送你的新分支与数据到某个远端仓库。git push origin --delete &lt;branch_name&gt; 删除指定的远端分支 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Git","slug":"Git","permalink":"https://xlline.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://xlline.github.io/tags/Git/"}]},{"title":"基于win+PHPStorm+Linux的推荐开发环境配置","slug":"DevelopTool-phpstorm","date":"2019-12-06T06:01:44.000Z","updated":"2021-09-11T08:19:22.549Z","comments":true,"path":"2019/12/06/DevelopTool-phpstorm/","link":"","permalink":"https://xlline.github.io/2019/12/06/DevelopTool-phpstorm/","excerpt":"想要在Windows开发可偏偏有拓展包依赖于Linux？也不想使用samba进行网络映射挂载虚拟盘？那这里还有一个方法，使用PHPstorm配置下下就可以。当前我的环境在Vmware，基于centos7使用Docker搭建的。具体步骤见详情。","text":"想要在Windows开发可偏偏有拓展包依赖于Linux？也不想使用samba进行网络映射挂载虚拟盘？那这里还有一个方法，使用PHPstorm配置下下就可以。当前我的环境在Vmware，基于centos7使用Docker搭建的。具体步骤见详情。 虚拟机部分使用非Root账户创建一个空文件夹设置SSH权限和密码，确保本地可以正常连接到虚拟机。不清楚的话可以参考点我，我是猴子派来的救兵确保当前容器已经正常启动且已实现代码映射到虚拟机主机部分本地我们要新建一个空目录（存放我们即将要同步的代码），使用PHPstorm打开，此时是一个空项目。PHP storm会在我们新建的目录里生成 .idea 文件夹。File-&gt;Settings-&gt;Build,Execution,Deployment中点击Deployment。选择”+”中的SFTP创建新连接，键入你喜欢的连接名。在Connection中填写基础连接配置 在Mappings中填写本地路径和目标路径 在Excluded Paths中填写我们要忽略排除的文件路径 配置完成点击应用就可以啦。在Tools-&gt;Deployment下选择Upload to swoole(这里的swoole是你创建的连接名，我本地是swoole)手动上传到远端，选择Automatic Upload(always)自动上传。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"IDE","slug":"IDE","permalink":"https://xlline.github.io/categories/IDE/"}],"tags":[{"name":"IDE","slug":"IDE","permalink":"https://xlline.github.io/tags/IDE/"},{"name":"PHPStorm","slug":"PHPStorm","permalink":"https://xlline.github.io/tags/PHPStorm/"}]},{"title":"Docker配置Samba文件共享服务","slug":"Docker-samba","date":"2019-12-03T09:41:16.000Z","updated":"2021-09-11T08:17:00.711Z","comments":true,"path":"2019/12/03/Docker-samba/","link":"","permalink":"https://xlline.github.io/2019/12/03/Docker-samba/","excerpt":"在windows网络环境中，主机之间进行文件和打印机共享是通过微软公司自己的SMB/CIFS网络协议实现的。SMB（Server Message Block，服务消息块）和CIFS（Common Internet File System，通用互联网文件系统）协议是微软的私有协议，在Samba项目出现之前，并不能直接与Linux/UNIX系统进行通信。Samba是著名的开源软件项目之一，它在Linux/UNIX系统中实现了微软的SMB/CIFS网络协议，从而使得跨平台的文件共享变得更加容易。在部署Windows、Linux/UNIX混合平台的企业环境时，选用Samba可以很好地解决不同系统之间的文件互访问题。","text":"在windows网络环境中，主机之间进行文件和打印机共享是通过微软公司自己的SMB/CIFS网络协议实现的。SMB（Server Message Block，服务消息块）和CIFS（Common Internet File System，通用互联网文件系统）协议是微软的私有协议，在Samba项目出现之前，并不能直接与Linux/UNIX系统进行通信。Samba是著名的开源软件项目之一，它在Linux/UNIX系统中实现了微软的SMB/CIFS网络协议，从而使得跨平台的文件共享变得更加容易。在部署Windows、Linux/UNIX混合平台的企业环境时，选用Samba可以很好地解决不同系统之间的文件互访问题。 选择高下载量的镜像拉取 docker pull dperson/samba关闭必要端口防火墙，执行下面命令 12345sudo iptables -I INPUT -p tcp --dport 139 -j ACCEPTsudo iptables -I INPUT -p tcp --dport 445 -j ACCEPTsudo iptables -I INPUT -p udp --dport 137 -j ACCEPTsudo iptables -I INPUT -p udp --dport 138 -j ACCEPT 运行执行以下命令后，在window本机使用window+R调出运行窗口，输入 linux主机的IP回车，比如 \\\\192.168.2.156即可看到分享的xugz_tp5文件目录。选中目录右键选择映射网络驱动器选择喜欢的盘，即可在计算机中找到。如此可实现先共享文件夹到本地盘。 12345678docker run -it -p 139:139 -p 445:445 --name smb -d --rm \\ -v /home/xugz/tp5/web:/mount \\ dperson/samba \\ -u \"xugz;123\" \\ -s \"xugz_tp5;/mount/;yes;no;yes;all;all;all\" \\ -w \"WORKGROUP\" \\ -g \"force user= xugz\" \\ -g \"guest account= xugz\" Samba在docker镜像地址中介绍了很多参数选项，简单记录上条命令用到的 123456789101112131415161718-u \"&lt;username;password&gt;[;ID;group;GID]\" 设置用户及密码-s \"&lt;name;/path&gt;[;browse;readonly;guest;users;admins;writelist;comment]\" 配置一个共享。其中&lt;name;/path&gt;为必须参数 &lt;name&gt; 分享名称 &lt;path&gt; 要分享的路径 [browsable] 是否可浏览 参数值为:'yes' or 'no' [readonly] 是否只读 参数值为:'yes' or 'no' [guest] 游客模式 参数值为:'yes' or 'no' [users] 用户列表 参数值为:'all' or 允许的用户秒表，多用户使用','分割 [admins] 系统用户 参数值为:'none' or 系统用户列表 [writelist] 可以写入RO共享的用户列表 [comment] 分享描述-w \"&lt;workgroup&gt;\" 配置要使用的工作组 比如要和windows共享，这里的工作组路径在 控制面板&gt;系统和安全&gt;系统&gt;工作组设置里面。（此电脑右键选择管理以快速打开）-g \"&lt;parameter&gt;\" 配置全局变量 相当于修改配置文件 smb.conf 格式参考： -g \"log level = 2\" 上行命令中我们使用用户xugz挂载程序文件夹到mount文件夹，所以mount目录下文件的所有者为xugz。当我们在外部访问分享文件夹此时新建文件，他的所属者默认为smbuser（我们可以通过 docker run -it dperson/samba sh 进入命令行查看 /etc/samba/smb.conf）配置force user指定用户以解决用户 map to guest 匿名访问且无密码 guest account 匿名用户映射到指定账户 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Docker","slug":"Docker","permalink":"https://xlline.github.io/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://xlline.github.io/tags/Docker/"},{"name":"Smaba","slug":"Smaba","permalink":"https://xlline.github.io/tags/Smaba/"}]},{"title":"Docker+ThinkPHP5部署基础","slug":"Docker-tp5-base","date":"2019-12-03T08:22:40.000Z","updated":"2021-09-11T08:37:58.375Z","comments":true,"path":"2019/12/03/Docker-tp5-base/","link":"","permalink":"https://xlline.github.io/2019/12/03/Docker-tp5-base/","excerpt":"本篇是使用Docker部署ThinkPHP运行环境的命令笔记。这里ThinkPHP框架版本为5.0.24。主要包括Apache下的基本运行、apache角度的URL重写、添加PHP拓展、连接数据库和结合redis的简单操作示例等。","text":"本篇是使用Docker部署ThinkPHP运行环境的命令笔记。这里ThinkPHP框架版本为5.0.24。主要包括Apache下的基本运行、apache角度的URL重写、添加PHP拓展、连接数据库和结合redis的简单操作示例等。 下载框架 官网框架下载地址到本地，使用ftp方式上传到虚拟机tool目录中。 结合apache的基本运行创建一个目录叫做tp5在tp5中创建两个目录。一个放程序文件(web)，一个放docker-compose.yml(compose) 解压框架压缩包至目录 /home/xugz/tp5/web，使用命令 cd tool &amp;&amp; unzip mydata.zip -d ../tp5/web 解压至指定目录如果没有安装zip和unzip。执行 sudo yum install zip unzip -y我们需要将TP5web文件夹整个目录挂载到PHP-FPM容器，Apache容器仅仅挂载public文件夹，httpd.conf文件中fpm配置改为：ProxyPassMatch ^/(.*\\.php)$ fcgi://192.138.0.2:9000/php/public/$1 docker-compose.yml文件中添加如下内容 12345678910111213141516171819202122232425262728version: \"3\"services: fpm: image: php:7.2.0-fpm-alpine3.6 container_name: fpm volumes: - /home/xugz/tp5/web:/php networks: mywebnet: ipv4_address: 192.138.0.2 httpd: image: httpd:2.4-alpine container_name: httpd ports: - 8081:80 volumes: - /home/xugz/tp5/web/public:/usr/local/apache2/htdocs/ - /home/xugz/conf/httpd.conf:/usr/local/apache2/conf/httpd.conf networks: mywebnet: ipv4_address: 192.138.0.3networks: mywebnet: driver: bridge ipam: config: - subnet: 192.138.0.0/16 保存文件使用 docker-compose up -d 编译运行成功后使用 curl localhost:8081/index.php验证。 添加控制器、url重写tp5默认有个控制器，位置在: application/index/controller/index.php 在我们开启防火墙端口sudo iptables -A INPUT -p tcp -m tcp --dport 8081 -j ACCEPT 后，可以在windows本机通过 虚拟机:端口/index.phptp5创建控制可以用命令直接帮你创建：php think make:controller index/test 需要确保本地有PHP环境 当然我们也可以手工创建 开启apache重写模块取消本行注释 LoadModule rewrite_module modules/mod_rewrite.so在网站配置相关节点加入 AllowOverride all 完成后使用 docker-compose restart 让其重启重新构建容器虚拟机:端口/index 访问Index目录下index文件 虚拟机:端口/index/index/test 访问Index目录下index中的test方法虚拟机:端口/index/user 访问Index目录下user文件index方法 虚拟机:端口/index/user_index 访问Index目录下UserIndex文件index方法 添加PHP扩展在容器中直接修改安装的话，容器删除后重新启动时，拓展和配置等都会丢失，所以我们在docker-compose文件中进行构建。在docker-compose.yml文件同目录创建新文件夹叫做build.参考地址： https://hub.docker.com/_/php/ PDO_MYSQL扩展默认的PHP–FPM容器没有PDO_MYSQL扩展，我们需要指定安装。在build里面新建一个Dockerfile文件，注意文件名 我们这次随便取，譬如叫做phpfpm，配置镜像源并更新apk包后执行安装PDO_MYSQL扩展。参考命令 1234FROM php:7.2.0-fpm-alpine3.6RUN echo http://mirrors.ustc.edu.cn/alpine/v3.6/main &gt; /etc/apk/repositories &amp;&amp; echo http://mirrors.ustc.edu.cn/alpine/v3.6/community &gt;&gt; /etc/apk/repositoriesRUN apk update &amp;&amp; apk upgradeRUN docker-php-ext-install pdo_mysql 返回上级目录修改docker-compose.yml文件，增加fpm服务标签 12345fpm: build: context: ./build dockerfile: phpfpm …… redis拓展在build里面新建一个Dockerfile文件，随便取，譬如叫做phpredis，安装redis依赖使用pecl来安装Redis扩展。参考命令 12345FROM php:7.2.0-fpm-alpine3.6RUN apk add autoconf gcc g++ make COPY ./redis-4.0.1 / # curl 'http://pecl.php.net/get/redis-4.0.1.tgz' -o redis-4.0.1.tgzRUN pecl install redis-4.0.1 \\ &amp;&amp; docker-php-ext-enable redis 返回上级目录修改docker-compose.yml文件，增加fpm服务build标签 12345fpm: build: context: ./build dockerfile: phpredis …… 构建fpm服务设置 docker-compose build fpm， 完成后我们发现他帮我们新建了一个镜像，原有镜像没有所需拓展，删除原有启动新镜像docker-compose stop fpm &amp;&amp; docker-compose rm fpm &amp;&amp; docker-compose up -d fpm 连接数据库编辑TP5对应的compose配置docker-compose.yml文件，加入MySQL的配置 123456789101112mysql: image: mysql:5.7 container_name: mysqld ports: - 3306:3306 volumes: - /home/xugz/mysql/conf:/etc/mysql/conf.d - /home/xugz/mysql/data:/var/lib/mysql environment: - MYSQL_ROOT_PASSWORD=123456 networks: - mywebnet 然后使用 docker-compose up -d mysql 创建MySQL服务器容器在应用程序web目录里application/database.php中修改MySQL配置，参考配置如下 配置完成后，可定义模型和数据库调用尝试验证。点我，我是隐藏的参考地址 结合redis容器基本操作拉取官方镜像 docker pull redis:alpine在conf目录下拉取redis配置文件 wget https://raw.githubusercontent.com/antirez/redis/5.0/redis.conf编辑redis.conf文件修改一些基本参数 如 bind 0.0.0.0 和 dir /data 编辑TP5对应的compose配置docker-compose.yml文件，加入Redis的配置 1234567891011redis: image: redis:alpine container_name: redis ports: - 6379:6379 volumes: - /home/xugz/tp5/conf/redis.conf:/usr/local/etc/redis/redis.conf - /home/xugz/tp5/redisdata:/data # 这里的data和 conf/redis.conf中的dir配置保持一致 networks: mywebnet: ipv4_address: 192.138.0.10 修改application/config.php中关于缓存相关配置，参考如图 然后使用 docker-compose up -d 创建redis服务器容器。成功的话使用 docker exec -it redis redis-cli 可进入Redis客户端。也可以写简单的测试验证，最简单的代码如图 使用浏览器访问 http://192.168.2.156:8081/news 即可看到测试数据参考文档： https://hub.docker.com/_/redis/ 上传文件 todo默认模板配置已完成 参考地址。默认模板实例代码已创建 模板实例代码参考地址此时我们刷新页面报错：mkdir():Permission denied。这是因为主机上的用户和容器里用户未对应导致的权限问题。如果你是apline 3.4 版本在数据源中加入 echo http://nl.alpinelinux.org/alpine/edge/testing &gt;&gt; /etc/apk/repositories 然后执行 apk -no-cache add shadow。是 alpine 3.6.则直接安装即可 apk add shadow。通过 地址 找到对于 usermod文件的所在包。完成之后执行 usermod -u 1000 www-data &amp;&amp; groupmod -g 1000 www-data修改用户www-data的用户以及群组ID为1000。搞定后要重启容器。 使用 cat /etc/passwd 命令查看用户归属组等信息 常见问题浏览器访问报错 variable type error:array默认输出类型导致解析异常。在应用程序web目录里application/config.php中修改，如 default_return_type = 'json' wget文件报错 unable to resolve host address因为VPS的本地DNS不通导致的，我们需要修改当前VPS的DNS。修改 /etc/resolv.conf 文件，增加DNS nameserver 8.8.8.8保存退出后重试。 查看运行在docker中的redis版本使用命令 `docker exec -it redis-server -v document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Docker","slug":"Docker","permalink":"https://xlline.github.io/categories/Docker/"},{"name":"PHP","slug":"Docker/PHP","permalink":"https://xlline.github.io/categories/Docker/PHP/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://xlline.github.io/tags/Docker/"},{"name":"PHP","slug":"PHP","permalink":"https://xlline.github.io/tags/PHP/"},{"name":"ThinkPHP","slug":"ThinkPHP","permalink":"https://xlline.github.io/tags/ThinkPHP/"}]},{"title":"Docker结合MySQL常用操作","slug":"Docker-mysql-base","date":"2019-12-03T04:22:21.000Z","updated":"2021-09-11T08:16:39.692Z","comments":true,"path":"2019/12/03/Docker-mysql-base/","link":"","permalink":"https://xlline.github.io/2019/12/03/Docker-mysql-base/","excerpt":"本篇是一些Docker结合MySQL常用操作的笔记。这里MySQL版本为5.7。主要是使用Docker搭建MySQL并导入数据、基于alpine镜像构建MySQL客户端、制作MySQL备份专用镜像和使用crontab实现数据库定时备份。","text":"本篇是一些Docker结合MySQL常用操作的笔记。这里MySQL版本为5.7。主要是使用Docker搭建MySQL并导入数据、基于alpine镜像构建MySQL客户端、制作MySQL备份专用镜像和使用crontab实现数据库定时备份。 启动MySQL容器、导入数据拉取官方镜像 docker pull mysql:5.7启动MySQL -e 设置环境变量 MYSQL_ROOT_PASSWORD 是root的密码docker run --name mysql --rm -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123123 -d mysql:5.7测试连接 docker exec -it mysql mysql -u root -p123123 或者 docker exec -it mysql mysql -u root -p实际运行必定要配置文件，根据官网的提示，配置文件在 /etc/mysql/my.cnf，数据目录在 /var/lib/mysql。 本地新建mysql目录，其中新建conf和data目录。conf挂载/etc/mysql/conf.d，data挂载/var/lib/mysql 1234567891011121314151617vim /home/xugz/mysql/conf/conf.cnf# 下面是对应配置信息[mysqld]server-id = 1 #服务Id唯一 用于主从同步port = 3306log-error = /var/log/mysql/error.log #错误日志#只能用IP地址skip_name_resolve #数据库默认字符集character-set-server = utf8mb4#数据库字符集对应一些排序等规则 collation-server = utf8mb4_general_ci#设置client连接mysql时的字符集,防止乱码init_connect='SET NAMES utf8mb4'#最大连接数max_connections = 300 修改完成后启动，确定放行3306端口 123docker run --name mysql --rm -p 3306:3306 \\-v /home/xugz/mysql/conf:/etc/mysql/conf.d -v /home/xugz/mysql/data:/var/lib/mysql \\-e MYSQL_ROOT_PASSWORD=123123 -d mysql:5.7 使用 docker logs 查看是否存在报错或者使用客户端进入MySQL确认配置是否生效。 123docker exec -it mysql mysql -uroot -p123123# 或者上行命令使用 docker exec -it mysql bash 然后 mysql -uroot -p123123 正常来说会进入mysql交互界面show variables like '%max_connections%'； #查看最大连接数是否和配置一致用于判断配置是否生效。 利用容器执行命令导入SQL文件 12345docker cp test.sql mysql:/tmpdocker exec -it mysql mysql -uroot -p123123 create database test; use test; source /tmp/test.sql; 基于alpine构建MySQL客户端alpine使用的是apk包管理器,命令，如apk add 、apk update 、apk del。默认镜像源可能比较慢，常用的有中科大镜像源：http://mirrors.ustc.edu.cn/alpine/ 阿里云镜像源：http://mirrors.aliyun.com/alpine/ 拉取官方镜像 docker pull alpine新建目录 mkdir mytool 并在目录中新建Dockerfile文件，键入以下内容。安装MySQL客户端 123456FROM alpine:latestRUN echo http://mirrors.aliyun.com/alpine/v3.10/main &gt; /etc/apk/repositoriesRUN echo http://mirrors.aliyun.com/alpine/v3.10/community &gt;&gt; /etc/apk/repositoriesRUN apk update &amp;&amp; apk upgradeRUN apk add mysql-clientENTRYPOINT [\"mysql\"] 如果不知道当前 alpine的版本，可以通过 docker exec -it 容器名 sh 通过命令行方式进入容器 使用命令 cat /etc/issue 查看。 不使用dockerfile的话，手工配置加速镜像源使用命令docker exec -it tmp sh -c \"echo \\\"http://mirrors.aliyun.com/alpine/v3.10/main/\\\" &gt; /etc/apk/repositories\"docker exec -it tmp sh -c \"echo \\\"http://mirrors.aliyun.com/alpine/v3.10/community/\\\" &gt;&gt; /etc/apk/repositories\"当然设置好后，还得 执行apk update &amp;&amp; apk upgrade构建镜像，使用命令编译 docker build -t mytool:1.0 .使用docker run -it --name tmp mytool:1.0 mysql -h 192.168.2.156 -uroot -p123123 运行验证。这里的192.168.2.156是MySQL服务端部署主机的IP alpine镜像官方文档 制作MySQL备份专用镜像我们现在想要制作一个MySQL备份数据库数据的镜像，要求存放到指定目录 /home/xugz/mysql/database_bak/下，文件名与数据库名一致。数据库备份命令mysqldump -u用户名 -p密码 数据库名 &gt; 导出的文件名。修改原mytool目录中的Dockerfile文件，覆盖以下内容，注意需要去掉注释哦 123456FROM mytool:1.0 # 基于上文中alpine构建的MySQL客户端ENV mysql_host 192.168.2.156 # 环境变量 目标连接服务器ENV mysql_user root # 环境变量 默认用户为 rootENV mysql_pass 123123 # 环境变量 连接mysql服务器主机对应用户的密码ENV mysql_db testENTRYPOINT mysqldump -h$mysql_host -u$mysql_user -p$mysql_pass $mysql_db &gt; /data/$mysql_db.sql 构建镜像，使用命令编译docker build -t mytool:1.1 .新建备份目录地址 mkdir database_bak运行并挂载指定目录 docker run -it --name bakup --rm -v /home/xugz/mysql/database_bak:/data mytool:1.1 或者增加环境变量指定，用于跨主机备份，参考以下命令 123docker run -it --name bakup --rm -v /home/xugz/mysql/database_bak:/data \\-e mysql_pass=qwe123 -e mysql_host=192.168.222.1 -e mysql_db=db_test_products -e mysql_user=root \\mytool:1.1 运行完成后，可到备份目标地址查看是否存在文件。 crontab定时备份数据表一般我们先写个脚本文件，塞入计划语句，然后加入到计划任务中。 新建dbback目录，进入新建备份计划脚本文件 vi /bakup.sh 塞入以下内容 12345#!/bin/shif [ ! -d \"/data\" ]; then mkdir /datafimysqldump -h$mysql_host -u$mysql_user -p$mysql_pass $mysql_db &gt; /data/$mysql_db-$(date +%Y%m%d_%H%M%S).sql 保存文件后，授予脚本可执行权限 chmod +x bakup.sh。新建Dockerfile文件，添加以下内容，注意需要去掉注释哦 12345678910FROM mytool:1.0ENV mysql_host 192.168.2.156ENV mysql_user rootENV mysql_pass 123123ENV mysql_db testCOPY ./bakup.sh /RUN chmod +x bakup.shENV cron_conf \"* * * * * \"RUN echo \"$cron_conf /bakup.sh\" &gt;&gt; /var/spool/cron/crontabs/rootENTRYPOINT [\"crond\",\"-f\"] # alpine中crond -f 命令为在客户端执行 执行编译 docker build -t mysqlbakup:1.0 .使用下面命令运行，备份192.168.2.125主机上的db_test_products表 123docker run -d --name bakup -v /home/xugz/mysql/database_bak:/data \\-e mysql_pass=qwe123 -e mysql_host=192.168.2.125 -e mysql_db=db_test_products -e mysql_user=root \\mysqlbakup:1.0 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Docker","slug":"Docker","permalink":"https://xlline.github.io/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://xlline.github.io/tags/Docker/"},{"name":"MySQL","slug":"MySQL","permalink":"https://xlline.github.io/tags/MySQL/"}]},{"title":"MySQL指定日期加减","slug":"MySQL-time-addsub","date":"2019-12-02T02:16:59.000Z","updated":"2021-09-11T08:21:07.572Z","comments":true,"path":"2019/12/02/MySQL-time-addsub/","link":"","permalink":"https://xlline.github.io/2019/12/02/MySQL-time-addsub/","excerpt":"MySQL官网是不承认时间直接相加减的，本篇记录时间加减操作需要注意点，加深记忆，避免以后入坑。先来看看MySQL中常用的内建日期函数 函数 描述 语法 NOW() 返回当前的日期和时间 NOW() CURDATE() 返回当前的日期，该函数相当于current_date关键字 CURDATE() CURTIME() 返回当前的时间，相当于current_time关键字 CURTIME() DATE() 提取日期或日期/时间表达式的日期部分 DATE(date) date 参数是合法的日期表达式 EXTRACT() 用于返回日期/时间的单独部分，如年、月、日、小时、分钟等 EXTRACT(unit FROM date) date 参数是合法的日期表达式 DATE_ADD() 给日期添加指定的时间间隔 DATE_ADD(date,INTERVAL expr type) date 是合法的日期表达式，expr 是时间间隔。 DATE_SUB() 从日期减去指定的时间间隔 DATE_SUB(date,INTERVAL expr type) date 是合法的日期表达式，expr 是时间间隔。 DATEDIFF() 返回两个日期之间的天数 DATEDIFF(date1,date2) date1 和 date2 是合法的日期或日期/时间表达式。 DATE_FORMAT() 用不同的格式显示日期/时间 DATE_FORMAT(date,format) date 是合法的日期。format 规定日期/时间的输出格式。","text":"MySQL官网是不承认时间直接相加减的，本篇记录时间加减操作需要注意点，加深记忆，避免以后入坑。先来看看MySQL中常用的内建日期函数 函数 描述 语法 NOW() 返回当前的日期和时间 NOW() CURDATE() 返回当前的日期，该函数相当于current_date关键字 CURDATE() CURTIME() 返回当前的时间，相当于current_time关键字 CURTIME() DATE() 提取日期或日期/时间表达式的日期部分 DATE(date) date 参数是合法的日期表达式 EXTRACT() 用于返回日期/时间的单独部分，如年、月、日、小时、分钟等 EXTRACT(unit FROM date) date 参数是合法的日期表达式 DATE_ADD() 给日期添加指定的时间间隔 DATE_ADD(date,INTERVAL expr type) date 是合法的日期表达式，expr 是时间间隔。 DATE_SUB() 从日期减去指定的时间间隔 DATE_SUB(date,INTERVAL expr type) date 是合法的日期表达式，expr 是时间间隔。 DATEDIFF() 返回两个日期之间的天数 DATEDIFF(date1,date2) date1 和 date2 是合法的日期或日期/时间表达式。 DATE_FORMAT() 用不同的格式显示日期/时间 DATE_FORMAT(date,format) date 是合法的日期。format 规定日期/时间的输出格式。 比如说，我们现在想要查询得出当前日期的一天前和五天前的日期，测试SQL语句如下 1SELECT NOW(),CURDATE(), CURTIME(), DATE_SUB(CURDATE(),INTERVAL 1 DAY),CURDATE()-1, DATE_SUB(CURDATE(),INTERVAL 5 DAY), CURDATE()-5; 明显发现使用 CURDATE()函数直接进行加减存在问题，需要留意。当我们需要日期加减操作时，可使用 DATE_SUB() 和 DATE_ADD() 函数。 DATE_ADD()和DATE_SUB()函数常用type参数有： 123456789MICROSECOND 微秒 SECOND 秒MINUTE 分钟HOUR 小时DAY 天WEEK 周MONTH 月 QUARTER 季度 YEAR 年 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://xlline.github.io/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://xlline.github.io/tags/MySQL/"}]},{"title":"Docker搭建PHP运行环境","slug":"Docker-php-base","date":"2019-11-29T09:12:38.000Z","updated":"2021-09-11T08:16:52.908Z","comments":true,"path":"2019/11/29/Docker-php-base/","link":"","permalink":"https://xlline.github.io/2019/11/29/Docker-php-base/","excerpt":"本篇是使用Docker安装PHP运行环境的命令笔记。这里PHP版本为7.0+。主要是手动运行php+fpm+apache步骤、使用compose编排php+fpm+apache 和nginx+PHP-FPM环境搭建过程简述。","text":"本篇是使用Docker安装PHP运行环境的命令笔记。这里PHP版本为7.0+。主要是手动运行php+fpm+apache步骤、使用compose编排php+fpm+apache 和nginx+PHP-FPM环境搭建过程简述。 运行PHP程序拉取7.2版本的官方PHP镜像 docker pull php:7.2-cli运行刚才的镜像 –rm 运行完自己干掉自己，一般用于执行临时任务 12docker run -it --rm --name runphp -v /home/xugz/php:/usr/src/myphp php:7.2-cli \\php /usr/src/myphp/index.php 手动运行php+fpm+apache我们尽可能的使用基于alpine的镜像。安装FPM镜像 docker pull php:7.2.0-fpm-alpine3.6 ，使用命令docker run -d --rm --name fpm php:7.2.0-fpm-alpine3.6 让容器以后台守护模式运行安装Apache镜像 docker pull httpd:2.4-alpine，写一个测试HTML网页，使用命令 docker run -d -p 80:80 --rm --name myweb -v /home/xugz/php:/usr/local/apache2/htdocs/ httpd:2.4-alpine映射80端口挂载默认网站路径，尝试是否正常使用。一般来说应该是可使用的。 然后我们需要修改配置文件。我们可以自己准备配置，或者从容器中拷贝一个。根据文档，容器里默认的配置文件路径为/usr/local/apache2/conf/httpd.conf。使用 docker exec -it myweb cat /usr/local/apache2/conf/httpd.conf查看配置文件信息使用 docker cp myweb:/usr/local/apache2/conf/httpd.conf /home/xugz/conf/复制文件修改配置文件 vi /home/xugz/conf/httpd.conf 找到以下内容，把前面的#号去掉开启对应模块 123LoadModule proxy_module modules/mod_proxy.soLoadModule proxy_http_module modules/mod_proxy_http.soLoadModule proxy_fcgi_module modules/mod_proxy_fcgi.so 另需增加修改配置如下内容 123456789101112&lt;VirtualHost *:80&gt; ServerAdmin xugz@com.cn DocumentRoot \"/usr/local/apache2/htdocs\" ServerName localhost &lt;Directory \"/usr/local/apache2/htdocs\"&gt; Options None Require all granted &lt;/Directory&gt; ProxyRequests Off ProxyPassMatch ^/(.*\\.php)$ fcgi://192.158.0.2:9000/php/$1 #转向fpm基本配置。使用docker network ls &amp;&amp; docker network inspect bridge 中查看FPM的inet&lt;/VirtualHost&gt; 启动fpm的时候把php文件夹挂载到fpm容器中，因此fpm容器的启动要增加文件挂载，命令改成docker run -d --rm --name fpm -v /home/xugz/php:/php php:7.2.0-fpm-alpine3.6重新运行apache容器 123docker run -d -p 80:80 --name myweb -v /home/xugz/php:/usr/local/apache2/htdocs/ \\-v /home/xugz/conf/httpd.conf:/usr/local/apache2/conf/httpd.conf \\httpd:2.4-alpine 没有异常的话，可用 curl localhost 和 curl localhost/index.php 测试。 compose编排php+fpm+apache为了让我们容器的启动和删除操作方便，所以要我们要使用docker compose ，一款编排工具。下载安装步骤见本站其他篇，点我瞬时移动。新建目录webcompose目录，在目录中新建docker-compose.yml文件,拷贝如下内容(就是将上文中两条启动容器命令翻译成dockerfile) 12345678910111213141516171819202122232425262728293031version: \"3\" services: fpm: image: php:7.2.0-fpm-alpine3.6 container_name: fpm volumes: - /home/xugz/php:/php networks: mywebnet: ipv4_address: 192.159.0.2 # 这里的IP需要和Apache配置文件httpd.conf中的ProxyPassMatch fcgi地址保持一致 httpd: image: httpd:2.4-alpine container_name: httpd ports: - 80:80 volumes: - /home/xugz/php:/usr/local/apache2/htdocs/ - /home/xugz/conf/httpd.conf:/usr/local/apache2/conf/httpd.conf networks: mywebnet: ipv4_address: 192.159.0.3 # 设置指定IP IP从0.1开始生成 networks: mywebnet: # 如果之前创建了相同子网的网络 要先删掉之前的,否则冲突 driver: bridge ipam: config: - subnet: 192.159.0.0/16 # 子网随便填写 IP地址是以网络号和主机号来表示网络上的主机的，只有在一个网络号下的计算机之间才能“直接”互通，不同网络号的计算机要通过网关（Gateway）才能互通。但这样的划分在某些情况下显得并不十分灵活。为此IP网络还允许划分成更小的网络，称为子网（Subnet）。 然后可以使用 docker-compose up -d启动可用 curl localhost 和 curl localhost/index.php 测试。 搭建nginx+PHP-FPM环境使用命令 docker pull nginx:1.13.9-alpine安装Nginx默认的网页文件夹是 /usr/share/nginx/html默认的配置文件地址是/etc/nginx/nginx.conf如果我们没有现成的配置文件，那么可以先胡乱启动下容器，然后拷贝到 我们的文件夹中。如下 12docker run --name nginx --rm -d nginx:1.13.9-alpinedocker cp nginx:/etc/nginx/nginx.conf ~/conf 普通html的情况下，nginx不需要做任何配置，使用如下命令重新运行后，尝试普通HTML访问是否正常 12docker run --name nginx -d --rm -v /home/xugz/php:/usr/share/nginx/html \\-p 80:80 nginx:1.13.9-alpine nginx+FPM的配置nginx配置文件的内容参考 12345678910111213141516171819202122232425262728293031323334353637383940414243444546user nginx;worker_processes 1;error_log /var/log/nginx/error.log warn;pid /var/run/nginx.pid;events { worker_connections 1024;}http { include /etc/nginx/mime.types; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\"'; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; # include /etc/nginx/conf.d/*.conf; server{ listen 80; location / { root /usr/share/nginx/html; index index.html index.htm index.php; } location ~ \\.php$ { root /php; fastcgi_pass 192.138.0.2:9000; # 这个192.138.0.2 是容器IP 需要指定 fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; } }} 启动FPM和Nginx 1234567891011docker network create --driver=bridge --subnet=192.138.0.0/16 mynginxdocker run -d --rm --name fpm \\--network mynginx --ip 192.138.0.2 \\ # 这个IP和Nginx配置文件中 fastcgi_pass配置的IP需要保持一致-v /home/xugz/php:/php \\php:7.2.0-fpm-alpine3.6docker run --name nginx -d --rm -v /home/xugz/php:/usr/share/nginx/html \\-v /home/xugz/conf/nginx.conf:/etc/nginx/nginx.conf \\--network mynginx -p 80:80 \\nginx:1.13.9-alpine 当然可以使用compose进行编排，很简单这里不就赘述了，不要忘记同步修改Apache和Nginx配置文件中的fpm部分，统一改成fpm的IP。nginx 官方镜像 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Docker","slug":"Docker","permalink":"https://xlline.github.io/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://xlline.github.io/tags/Docker/"},{"name":"PHP","slug":"PHP","permalink":"https://xlline.github.io/tags/PHP/"}]},{"title":"Docker-Machine","slug":"Docker-Machine","date":"2019-11-28T07:40:26.000Z","updated":"2021-09-11T08:16:10.584Z","comments":true,"path":"2019/11/28/Docker-Machine/","link":"","permalink":"https://xlline.github.io/2019/11/28/Docker-Machine/","excerpt":"Docker Machine是简化的Docker安装的命令行工具,通过命令行即可在相应的平台上(目前支持在本机运行virtualbox虚拟主机，Hyper-V虚拟主机，VMware虚拟主机，AWS EC2，Azure，DigitalOcean，Google等公有云主机)安装Docker。（好比在你机器上装个虚拟机，老外帮你准备好了专门的ISO，docker 都帮你弄好了） 本篇主要涉及Docker-Machine创建虚拟Docker主机、创建私有镜像仓库，利用Docker-Machine在虚拟主机中使用compose启动Nginx负载均衡、设置IP转发在windows中访问。","text":"Docker Machine是简化的Docker安装的命令行工具,通过命令行即可在相应的平台上(目前支持在本机运行virtualbox虚拟主机，Hyper-V虚拟主机，VMware虚拟主机，AWS EC2，Azure，DigitalOcean，Google等公有云主机)安装Docker。（好比在你机器上装个虚拟机，老外帮你准备好了专门的ISO，docker 都帮你弄好了） 本篇主要涉及Docker-Machine创建虚拟Docker主机、创建私有镜像仓库，利用Docker-Machine在虚拟主机中使用compose启动Nginx负载均衡、设置IP转发在windows中访问。 安装使用如下命令，或者直接到对应github下载，授予可执行权限，保证最后拷贝到环境变量相关目录里(/usr/local/bin/)即可。 123curl -L https://github.com/docker/machine/releases/download/v0.16.2/docker-machine-`uname -s`-`uname -m` &gt;/tmp/docker-machine &amp;&amp; \\chmod +x /tmp/docker-machine &amp;&amp; \\sudo cp /tmp/docker-machine /usr/local/bin/docker-machine Docker Machine安装参考文档 创建Docker主机首先我们需要安装virtualbox 官方下载地址点我。选择对应版本的rpm下载包，通过ftp方式拷贝到服务器，进行yum install &lt;包名&gt; -y 安装即可。同时，oracle也告诉我们存在其他方法 参考地址，如下 123wget http://yum.oracle.com/public-yum-ol7.repo然后把下载下来的文件拷贝到/etc/yum.repos.d中yum install VirtualBox-5.2 创建Docker主机安装virtualbox参考地址完成可以执行 docker-machine create --driver=virtualbox vbox-test 创建。执行该命令，他首先检查 /home/xugz/.docker/machine/cache 是否存在，没有则创建文件夹；然后寻找该文件夹下是否有 boot2docker.iso文件（一个基于Tiny Core Linux的系统，里面Docker啥的都帮你搞定了），另外会默认会创建一个虚拟网卡 （vboxnet0）。所以如果太慢，我们可以去boot2docker.iso对应gitHub下载地址手工下载用ftp传到目标服务器再执行创建。 常用命令查看列表 docker-machine ls查看IP地址 docker-machine ip 虚拟机名称停止和开启 docker-machine stop/start 虚拟机名称查看环境变量 docker-machine env vbox-test 如果我们要操作machine里面的docker环境变量 ,可以不用进入到虚拟机 使用eval命令（可以读取一连串的参数,然后按照参数特性来执行） 此时我们执行 eval $(docker-machine env vbox-test) 这时我们本机的docker客户端就连接了vbox-test的docker服务端 切换回来使用命令 eval $(docker-machine env -u)SSH的方式连接到虚拟机 docker-machine ssh 虚拟机名称 移植主机镜像到虚拟机创建私有镜像库 1234567docker pull registry # docker pull一个官方镜像 专门处理私有镜像的提交和拉取docker run -d -p 5000:5000 --name registry registry # 运行镜像生成新容器docker tag centos:httpd localhost:5000/web # 给本地centos:httpd 镜像打标签，命名为localhost:5000/webdocker push localhost:5000/web # 提交镜像docker tag centos:nginx localhost:5000/nginxdocker push localhost:5000/nginxdocker rmi localhost:5000/web # 提交完成后, 可以删除刚才创建的标签 查看仓库目录注意以下的命令要保证registry容器正在运行可以利用API的方式 查看私有仓库中的目录 curl http://localhost:5000/v2/_catalog 参考文档同步镜像最后使用命令 docker-machine ssh vbox-test 进入docker pull 192.168.99.1:5000/nginx 将私有镜像库中的Nginx下载到虚拟机里 主机的IP:端口 修改镜像名使用tag命令 docker tag &lt;原镜像名称&gt; &lt;新的镜像名&gt; 完成后再把原镜像删除即可。我也不知道为什么官方没有rename命令，非得整这么麻烦。等我学会Go语言，就来本地尝试下。 利用Docker-Machine在虚拟主机中使用compose启动Nginx负载均衡这里我们也想使用compose进行容器统一管理，之前我们在宿主机中安装了compose（位置在：/usr/local/bin/docker-compose）我们可以直接拷贝就行了。 拷贝compose 到虚拟主机利用scp命令 参考文档我们进入宿主机执行 docker-machine scp /usr/local/bin/docker-compose vbox-test:/home/docker/.local/bin /home/docker/.local/bin 是虚拟机用户的一个环境变量 （也可以自己设置）把我们之前做的compose配置文件拷贝过去 docker-machine scp -r mycompose vbox-test:/home/docker/(如果是文件夹，则要加入-r 进行递归操作)。然后修改docker-compose.yml镜像配置改为虚拟主机自己的。我们的compose里面有个映射文件，也就是把主机的文件映射到容器。那么是否我们也需要 把网站文件给拷贝到 虚拟机里面呢？答案是不需要，我们可以使用 mount命令来完成。 映射文件挂载到虚拟主机mount命令参考文档官方提醒我们，需要依赖使用sshfs将目录从虚拟机挂载到本地主机。SSHFS可以利用SFTP的方式把远程文件映射到本机 。在宿主机的安装sshfs，安装如下依赖 12yum install -y epel-releaseyum install -y fuse-sshfs 首先在虚拟机里创建一个文件夹叫做 nginx docker-machine ssh vbox-test mkdir nginx主机上也创建一个文件夹 （空的），叫做 vbox-nginx。挂载使用命令 docker-machine mount vbox-test:/home/docker/nginx /home/xugz/mnginx 需要注意不在挂载点目录执行取消挂载使用命令 docker-machine mount -u vbox-test:/home/docker/nginx /home/xugz/mnginx 把本地主机之前的nginx文件夹里面的文件，拷贝到mnginx里面。进入nginx文件夹使用命令cp . /home/xugz/mnginx -r对应修改docker-compose.yml中对应文件挂载的配置。我们以后只要在宿主机修改文件就可以了。接下来我们就可以利用 docker-compose up -d 在我们的虚拟机中启动容器了。 外部访问 IP转发在虚拟主机中使用curl localhost:9090访问在宿主机中使用 curl $(docker-machine ip vbox-test):9090访问在windows里访问使用VBoxManage（我们上面虚了好几层了哦~）简单说一下virtualbox的几个命令 文档点我VBoxManage list vms 列出当前的所有虚拟机VBoxManage controlvm 可以用来修改正在运行的虚拟机状态 存在参数语法： natpf&lt;1-N&gt; [&lt;name&gt;],tcp|udp,[&lt;hostip&gt;],&lt;hostport&gt;,[&lt;guestip&gt;], &lt;guestport&gt;譬如VBoxManage controlvm \"vbox-test\" natpf1 \"mynat1,tcp,,9090,,9090\" 这代表把vbox-test这个虚拟机的tcp端口（IP不限制）转发到 宿主机的9090端口。执行完成后我们就可以使用 宿主机IP:9090端口访问VBoxManage controlvm \"vbox-test\" natpf1 delete mynat1 删掉规则，这样外部就不能访问了 常见问题http: server gave HTTP response to HTTPS client因为docker为了安全，需要https 。但是我们可以让其不需要。如果我们在主机里，那么要修改的是/etc/docker/daemon.json。在machine里也是一样的，那么要在/etc/docker下面 手动创建daemon.json文件（默认是木有的），添加如下内容 123{ \"insecure-registries\":[\"192.168.99.1:5000\"]} 修改完成需要重启虚拟机主机 docker-machine restart 虚拟机名称。 ## This computer doesn't have VT-X/AMD-v enabled. Enabling it in the BIOS is mandatory 如果是在VMware中的Linux，需要在关机状态的虚拟机进行配置: 虚拟机&gt;设置&gt;处理器中勾选虚拟化 Intel VT-x/EPT 或 AMD-V/RVI(V) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Docker","slug":"Docker","permalink":"https://xlline.github.io/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://xlline.github.io/tags/Docker/"}]},{"title":"Docker+Nginx负载均衡","slug":"Docker-Nginx负载均衡","date":"2019-11-25T05:33:36.000Z","updated":"2021-09-11T08:19:52.660Z","comments":true,"path":"2019/11/25/Docker-Nginx负载均衡/","link":"","permalink":"https://xlline.github.io/2019/11/25/Docker-Nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/","excerpt":"使用手工commit的方式创建了一个基于CentOS的Nginx容器，并且可以通过外部访问到。入手docker compose——Docker容器编排的工具，可以配置并启动多个容器，适合复杂业务场景。本篇是铺垫nginx负载均衡的步骤记录。","text":"使用手工commit的方式创建了一个基于CentOS的Nginx容器，并且可以通过外部访问到。入手docker compose——Docker容器编排的工具，可以配置并启动多个容器，适合复杂业务场景。本篇是铺垫nginx负载均衡的步骤记录。 手工搭建CentOS+Nginx容器docker pull centos在centos镜像基础上创建一个临时容器tmp，执行命令 docker run -it --privileged --name tmp centos /usr/sbin/init后如下图。保持不动，新开窗口进行后续操作。 进入容器 docker exec -it tmp /bin/bash升级包 rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm默认安装 yum install nginx -y 安装完成之后，nginx配置文件默认路径为 /etc/nginx/nginx.conf ，是全局配置文件。启动nginx systemctl start nginx设置开机自启动 systemctl enable nginx 启动成功我们可以使用 curl http://localhost 验证，正常的话，我们会看到Welcome to nginx之类的HTML源码。接下来我们要把容器作为镜像保存起来，使用commit命令。利用dockerfile里面的格式去创建新镜像 docker commit -c 'CMD [\"/usr/sbin/init\"] ' -c \"EXPOSE 80\" tmp centos:nginx基于这个镜像创建新容器，因为docker非持久化，把配置文件映射到本地主机。使用cp命令。docker cp tmp:/etc/nginx/nginx.conf /home/xugz/nginx/conf/此时可以停止并删除临时容器tmp。启动Nginx镜像 指定端口9090，nginx.conf文件同步 docker run --name mynginx --privileged -p 9090:80 -v /home/xugz/nginx/conf/nginx.conf:/etc/nginx/nginx.conf -d centos:nginx。启动成功后，使用虚拟机IP:9090在本地浏览器可以访问。 cp命令参考地址commit命令参考地址 模拟创建多个web网站本地新建文件/home/xugz/nginx/web1/index.html和/home/xugz/nginx/web2/index.html。两个HTML页面内容不一致。基于本地已有镜像centos:httpd启动两个容器 12docker run --name web1 -d -p 8080:80 --privileged -v /home/xugz/nginx/web1/:/var/www/html/ centos:httpddocker run --name web1 -d -p 8081:80 --privileged -v /home/xugz/nginx/web1/:/var/www/html/ centos:httpd 要停止删除也要执行两条语句 docker stop web1 &amp;&amp; docker rm web1 和 docker stop web2 &amp;&amp; docker rm web2很明显，这样很麻烦，我们可以用compose来进行统一管理。 compose下载安装根据官方文档引导，首先下载Docker Compose的当前稳定版本sudo curl -L \"https://github.com/docker/compose/releases/download/1.24.1/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose 如果根本下载不动，也可以更换下载地址，使用命令 sudo curl -L \"https://get.daocloud.io/docker/compose/releases/download/1.24.1/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose完成后授予文件可执行权限 sudo chmod +x /usr/local/bin/docker-compose使用 docker-compose --version 查看版本 启动为项目创建一个目录，这里我们基于的是原来创建的镜像 12mkdir composetestcd composetest 创建docker-compose.yml 文件,拷贝如下内容 123456789101112131415161718services: # 任务 web1: # 自定义 container_name: web1 # 容器名称 image: \"centos:httpd\" # 这个容器基于的镜像 ports: - \"8080:80\" privileged: true #给容器加特权 volumes: - \"/home/xugz/nginx/web1/:/var/www/html/\" #映射文件 web2: container_name: web2 image: \"centos:httpd\" ports: - \"8081:80\" privileged: true volumes: - \"/home/xugz/nginx/web2/:/var/www/html/\"version: \"3\" 保存退出，在文件所在目录执行docker-compose up -d启动。停止容器使用命令 docker-compose stop web1 删除容器使用命令 docker-compose rm当然我们也可以连带Nginx一起启动操作，只需要在docker-compose.yml文件中services增加如下内容 12345678nginx: container_name: mynginx image: \"centos:nginx\" ports: - \"9090:80\" privileged: true volumes: - \"/home/xugz/nginx/conf/nginx.conf:/etc/nginx/nginx.conf\" yaml在线检查工具compose官方参考文档 network网络列表 docker network ls查看详细信息 docker network inspect &lt;network name&gt;容器之前可以使用IP进行互通，实验如图 手动配置现在我们新建网络 mynginx 然后让上文中涉及的三个容器都加入我们新建的网络里停止原有三个容器 使用命令 docker-compose stop创建网络 指定子网为192.168.0.0 docker network create -d bridge --subnet=192.168.0.0/16 mynginx在docker-compose.yml文件中新增如下内容 12345678910version: \"3\"services: web: …… networks: - \"mynginx-net\" # 和networks中网络名称一致networks: mynginx-net: # 可自定义 external: name: \"mynginx\" 启动三个容器 使用命令docker-compose start就可以了。也可以进入容器验证查看 子网掩码的计算地址network官方参考文档网络配置参考(version 3) compose up 时自动创建网络参考文档修改docker-compose.yml文件，示例如下 123456789101112131415version: \"3\"services: app: image: centos:nginx container_name: mynginx networks: mynginx-net: ipv4_address: 192.158.0.2 networks: mynginx-net: driver: bridge ipam: config: - subnet: 192.158.0.0/24 保存后使用命令docker-compose up -d 启动，会自动生成名称为 mycompose_mynginx-net 的网络。 env_file如果设置比较复杂，那么我们可以通过env_file来完成变量的引用在docker-compose.yml文件同目录内新建 .env 文件，里面输入变量，格式为 xugz=192.158.0.7。在docker-compose.yml文件中直接使用 ${xugz}引用即可。 env_file参数参考文档 简单的Nginx负载均衡设置修改本地nginx配置文件，当然你要确保你本地的文件已经和docker容器中的实时同步。注释掉 include /etc/nginx/conf.d/*.conf; 这行，删除原来关于server配置，增加如下内容 123456789101112131415upstream mydocker { server 192.158.0.7; # web1 的ip地址 可以通过 docker network inspect mycompose_mynginx-net 查看到 server 192.158.0.3; # web2 的ip地址 } server { listen 80; # 默认80端口 server_name mydocker; location / { # 访问根目录 默认跳转到http://mydocker，就是我们配置的 upstream mydocker proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_buffering off; proxy_pass http://mydocker; } } 保存退出后回到docker-compose.yml文件所在目录，使用 docker-compose restart nginx 重启Nginx。访问 http://192.168.2.156:9090/ 会轮流跳转到web1或web2。 容器健康检查机制参数如下：–health-cmd: 检查的命令–health-interval：两次健康检查的间隔–health-timeout：健康检查命令运行超时时间，超过代表失败–health-retries：当连续失败指定次数后，则将容器状态视为 unhealthy–health-start-period:容器启动的初始化时间，此时健康检查失效不会计入次数 运行web1容器同时进行检查80端口是否正常，每三秒检查一次，当连续失败3次后提示，健康检查命令超5秒也代表失败。示例命令如下 1234docker run --name web1 -d -p 8080:80 --privileged -v /home/xugz/nginx/web1/:/var/www/html/ \\--health-cmd=\"curl --silent --fail http://localhost:80/ || exit 1\" --health-interval=3s --health-retries=3 \\--health-timeout=5s \\ centos:httpd 参数说明 ： \\ 换行使用 --silent --fail 出现错误的时候不进行输出 exit 1 非正常退出 || 表示 左边执行为false才会执行右边 &amp;&amp; 为左边执行为true才会执行右边 此时，可以使用 docker inspect web1 命令检查容器只看Health部分使用命令 docker inspect --format='' web1 使用Compose进行健康检查docker-compose.yml文件对应容器中添加如下示例配置即可 12345healthcheck: test: [\"CMD\", \"curl\", \"-f\", \"http://localhost:80\"] interval: 3s timeout: 10s retries: 3 healthcheck参考文档 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Docker","slug":"Docker","permalink":"https://xlline.github.io/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://xlline.github.io/tags/Docker/"},{"name":"Nginx","slug":"Nginx","permalink":"https://xlline.github.io/tags/Nginx/"}]},{"title":"docker基础及常见问题","slug":"Docker-基础及常见问题","date":"2019-11-21T08:43:20.000Z","updated":"2021-09-11T08:16:06.917Z","comments":true,"path":"2019/11/21/Docker-基础及常见问题/","link":"","permalink":"https://xlline.github.io/2019/11/21/Docker-%E5%9F%BA%E7%A1%80%E5%8F%8A%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/","excerpt":"我们常说的Docker是指Docker引擎(Engine),主要包含1、Docker Daemon — docker守护进程(Server)2、Docker REST API — 和docker daemon交互的REST API (用python或Go程序调用API和Daemon交互)3、Docker CLI — 命令行应用 （我们执行docker run 等命令，用来和Daemon交互） Docker服务端提供了一系列REST API（Docker Remote API)，当我们敲入docker命令时实际上是通过API和Docker服务端进行交互。官方提供了三种链接方式：a. unix:///var/run/docker/sock（默认连接方式）b. tcp://host:portc. fd://socketfd本篇整理了docker常用命令及遇到的问题。","text":"我们常说的Docker是指Docker引擎(Engine),主要包含1、Docker Daemon — docker守护进程(Server)2、Docker REST API — 和docker daemon交互的REST API (用python或Go程序调用API和Daemon交互)3、Docker CLI — 命令行应用 （我们执行docker run 等命令，用来和Daemon交互） Docker服务端提供了一系列REST API（Docker Remote API)，当我们敲入docker命令时实际上是通过API和Docker服务端进行交互。官方提供了三种链接方式：a. unix:///var/run/docker/sock（默认连接方式）b. tcp://host:portc. fd://socketfd本篇整理了docker常用命令及遇到的问题。 centOS7下安装docker安装基本依赖 sudo yum install -y yum-utils device-mapper-persistent-data lvm2设置即将安装的是稳定版仓库 sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo(该步骤可不选)edge月更新仓库 sudo yum-config-manager --enable docker-ce-edge安装之前可以查看所有仓库中所有docker版本 yum list docker-ce --showduplicates | sort -r默认安装使用命令 yum install docker-ce -y安装完成启动 systemctl start docker 并设置开机自启动 systemctl enable dockerdocker安装时默认创建了docker用户组，将普通用户加入docker用户组就可以不使用sudo来操作docker。使用命令 sudo usermod -aG docker xugz加入，需要重新登录或者执行 newgrp docker 改变当前用户的有效群组才能生效。到这里没有异常的话，使用 docker version 验证安装是否成功 安装过程同时可以参照阿里云的帮助文档 centOS8安装docker卸载旧版本 较旧的 Docker 版本称为 docker 或 docker-engine 。如果已安装这些程序，请卸载它们以及相关的依赖项安装步骤下载docker-ce的repo curl https://download.docker.com/linux/centos/docker-ce.repo -o /etc/yum.repos.d/docker-ce.repo安装依赖（这是相比centos7的关键步骤） yum install https://download.docker.com/linux/fedora/30/x86_64/stable/Packages/containerd.io-1.2.6-3.3.fc30.x86_64.rpm安装docker-ce yum install docker-ce启动dockersystemctl start docker启动成功，使用systemctl status docker 查看docker启动状态或者使用docker version验证是否安装成功。 配置镜像加速器这里我用的是阿里云的镜像，配置加速器官方已经给到参考步骤了，如下图 常用命令检查docker版本 docker --version or docker info拉取镜像 docker pull &lt;images name&gt;运行镜像 docker run -i -t --name &lt;new container name&gt; &lt;images name&gt; 参数说明： -d: 后台运行 ； -p: 映射端口 ； --name : 譬如 --name xxxooo: 为容器指定一个名称； -i: 打开stdin，用于和容器进行交互，通常与 -t 同时使用； -t: 为容器创建虚拟终端，我们就可以登录终端了通常与 -i 同时使用。 提示：使用ctrl+d 可退出当前终端。ctrl+p+q 退出容器但不关闭 列出容器 docker ps查看到当前所有容器 docker ps -a再次启动运行容器 先通过 docker ps -a 获得容器ID ，使用 docker start &lt;container ID&gt; 启动容器，使用 docker attach &lt;container ID &gt; 进入运行容器。当然也可以使用组合命令 docker start &lt;contianer ID &gt; -a -i -a 打开容器的输出流 -i 打开容器的输入流。注意，退出后容器也会自动停止。在运行中的容器中执行命令进行交互式操作 docker exec -i -t &lt;container Name or container ID &gt; &lt;cmd&gt; docker exec -i -t myos1 /bin/bash 停止所有的container docker stop $(docker ps -a -q)删除所有容器 docker rm $(docker ps -a -q)删除所有镜像 docker rmi $(docker images -q) 具体命令格式规范参考官方文档 利用Dockerfile创建自定义镜像Dockerfile是由一系列命令和参数构成的脚本，这些命令应用于基础镜像并最终创建一个新的镜像。譬如我要用到apache，希望直接构建出一个环境容器。我们创建一个空文件夹 build，在该目录下创建一个叫做Dockerfile(注意大小写)的文件，插入内容如下: 12345FROM centos:latestRUN yum -y install httpd RUN systemctl enable httpd.service CMD /usr/sbin/init # 如果这里不加cmd 的话，运行命令需要改写成 docker run --privileged -d -p 8080:80 --name myhttpd centos:httpd /usr/sbin/initEXPOSE 80 # 暴露80端口 保存退出。命令 docker build 用于读取Dockerfile创建镜像。使用命令 docker build -t centos:httpd .创建 -t 指定镜像名称创建完成，使用命令 docker run --privileged -d -p 8080:80 --name myhttpd centos:httpd 运行。 参考文档 https://docs.docker.com/engine/reference/builder/#usage 容器和主机间的数据共享利用docker run -v使用命令 docker run --privileged -d -p 8080:80 --name myhttpd -v /home/xugz/myweb:/var/www/html centos:httpd在容器中设置了一个挂载点/var/www/html(即apache的默认的网站目录) ，并将主机上的 /home/xugz/myweb目录中的映射到/var/www/html下。这时我们容器中操作该目录或在主机中操作，两者均是实时同步的 配置远程访问我们发现docker默认连接方式为unix:///var/run/docker/sock。编辑docker文件修改服务启动运行方法，增加TCP连接配置，保存后重启Docker。再次查看发现已配置成功。具体命令如下 123456ps -ef | grep dockersudo vim /usr/lib/systemd/system/docker.service# 将原来`ExecStart=/usr/bin/dockerd`改成`ExecStart=/usr/bin/dockerd -H tcp://0.0.0.0:2375 -H unix://var/run/docker.sock`systemctl daemon-reloadsystemctl restart dockerps -ef | grep docker Docker管理工具portainerDocker API必须通过TCP公开，确保已经开放TCP连接2375端口拉取镜像 docker pull portainer/portainer运行容器 docker run -d -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock -v /opt/portainer:/data --name mydocker portainer/portainer运行成功后，浏览器输入虚拟机IP+9000即可进入对应可视化界面。初次进入portainer会让你先创建用户，密码不能少于八位。而后配置将Portainer连接到要管理的Docker环境。 如果在此时报错: Get http://192.168.2.156:2375/_ping: dial tcp 192.168.2.156:2375: connect: no route to host 。关闭防火墙即可解决。 github地址：https://github.com/portainer/portainerportainer官网地址: https://portainer.readthedocs.io/en/latest/deployment.html 使用portainer创建MySQL容器在搭建好的可视化界面中，找到App Templates选择需要的镜像，填写必要配置后点击部署。这里我安装的是MySQL。需要注意的是，创建完成后自动帮我们启动这个镜像，MySQL官方提醒使用命令docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag 进行运行需要注意。记录密码 docker run --name mysql -p 3307:3306 -e MYSQL_ROOT_PASSWORD=123123 -d mysql。之后就可以使用本地进行来连接了。当然我们也可以使用命令行docker exec -it mysql bash 进入docker的MySQL容器。 MySQL官方镜像文档: https://hub.docker.com/_/mysql/ 常见问题普通用户运行docker命令不需要使用sudo使用root账号，修改文件 /etc/sudoers，找到 Allow root to run any commands anywhere 位置增加普通用户。如图 在Linux系统中运行没有sudo密码的特定命令 12345678910[xugz@xugz yum.repos.d]$ docker imagesGot permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get http://%2Fvar%2Frun%2Fdocker.sock/v1.40/images/json: dial unix /var/run/docker.sock: connect: permission denied[xugz@xugz yum.repos.d]$ sudo docker images[sudo] password for xugz:REPOSITORY TAG IMAGE ID CREATED SIZE[xugz@xugz yum.repos.d]$ id xugzuid=1000(xugz) gid=1000(xugz) groups=1000(xugz),0(root)[xugz@xugz yum.repos.d]$ sudo usermod -aG docker $(whoami)[xugz@xugz yum.repos.d]$ id xugzuid=1000(xugz) gid=1000(xugz) groups=1000(xugz),984(docker),0(root) 注销并再次登录或者使用命令 `newgrp - docker` 改变当前用户的有效群组，完成后可以使用 `docker version` 命令检查安装的Docker版本了。 docker 安装完成后测试hello-world出现问题（Unable to find image ‘hello-world:latest’ locally）安装docker之后，测试hello-world镜像，终端卡在Unable to find image 'hello-world:latest' locally位置docker在本地没有找到hello-world镜像，也没有从docker仓库中拉取镜像，出项这个问题的原因：是因为docker服务器再国外，我们在国内无法正常拉取镜像，所以就需要我们设置国内的镜像加速器。我这里用的是阿里云，当然其他的也可以，大家可以自己选择。Docker 官方和国内很多云服务商都提供了国内加速器服务，例如： Docker官方提供的中国镜像库https://registry.docker-cn.com。 12345678sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'{ \"registry-mirrors\": [\"https://v2xlbv24.mirror.aliyuncs.com\"]}EOFsudo systemctl daemon-reloadsudo systemctl restart docker 参考本篇配置镜像加速器 IPv4 forwarding is disabled. Networking will not work.解决办法：sudo vi /etc/sysctl.conf (Linux内核参数配置文件，可在运行时修改某些内核参数，使之永久生效)加入net.ipv4.ip_forward=1保存并退出后 执行sudo systemctl restart network。并且需要确保8080端口已放行 sudo iptables -A INPUT -p tcp -m tcp --dport 8080 -j ACCEPT Failed to get D-Bus connection: Operation not permitted。使用命令docker run -d -p 8080:80 --name myhttpd centos:httpd 运行后报错 Failed to get D-Bus connection: Operation not permitted。使用 docker run --privileged -d -p 8080:80 --name myhttpd centos:httpd 运行解决。 –privileged 参数，给容器加特权,否则交互式方式进入容器无法操作一些譬如修改内核、修改系统参数、甚至启动服务等 参考https://docs.docker.com/engine/reference/commandline/run/#capture-container-id-cidfilehttps://github.com/moby/moby/issues/7459https://developers.redhat.com/blog/2014/05/05/running-systemd-within-docker-container/ 使用Dockerfile成功启动Apache但浏览器拒绝访问如果是防火墙的问题，出现的报错提示应该是无法连接之类的，一般出现404 403那说明能连上。因为默认的容器里可能没有设置默认主页配置，所以先将apache的默认主页index.html或index.htm 在浏览器输全尝试。若还不行，进入容器，curl http://localhost/index.html尝试，确保浏览器地址没有输错。若还不行，进入apache配置文件 /etc/httpd/conf/httpd.conf 找到默认目录DocumentRoot然后查看 这个目录是否有，且对应文件是否存在。我这里的问题是，安装的这个apache镜像没有默认主页，新建就可以了…… 启动容器时报错Error response from daemon: driver failed programming external connectivity on endpoint mysqldocker服务启动时定义的自定义链DOCKER由于某种原因被清掉，重启docker服务及可重新生成自定义链DOCKER。使用命令systemctl restart docker在重新启动容器即可。如图 docker log 报错 SELinux: Could not open policy file &lt;= /etc/selinux/targeted/policy/policy.31: No such file or directory因为使用centos镜像的问题，需要处理SELinux。实际开发中使用镜像alpine，这里就先放过这个问题，以后再表。 参考地址阿里云docker安装帮助文档官方文档基本命令参考地址配置镜像加速器阿里云文档管理工具portainer仓库地址管理工具portainer官网地址 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Docker","slug":"Docker","permalink":"https://xlline.github.io/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://xlline.github.io/tags/Docker/"}]},{"title":"MySQL之联合索引最左原则","slug":"MySQL-联合索引最左原则","date":"2019-11-20T07:43:20.000Z","updated":"2021-09-11T08:21:04.084Z","comments":true,"path":"2019/11/20/MySQL-联合索引最左原则/","link":"","permalink":"https://xlline.github.io/2019/11/20/MySQL-%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E6%9C%80%E5%B7%A6%E5%8E%9F%E5%88%99/","excerpt":"MySQL可以创建复合索引，一个索引最多可以包含16列。联合索引参与条件规则的字段需要放在前面，即需要满足最左匹配原则。举例来说，如果你有一个三列的索引(col1, col2, col3)，走索引的条件顺序为(col1)，(col1, col2)以及 (col1, col2, col3)。使用EXPLAIN关键字可以模拟优化器执行SQL查询语句，指标TYPE结果值好坏依次是: system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL。","text":"MySQL可以创建复合索引，一个索引最多可以包含16列。联合索引参与条件规则的字段需要放在前面，即需要满足最左匹配原则。举例来说，如果你有一个三列的索引(col1, col2, col3)，走索引的条件顺序为(col1)，(col1, col2)以及 (col1, col2, col3)。使用EXPLAIN关键字可以模拟优化器执行SQL查询语句，指标TYPE结果值好坏依次是: system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL。 假设存在测试表，增加联合索引 idx_last_first_name (last_name,first_name) 1234567891011CREATE TABLE `employees` ( `emp_no` int(11) NOT NULL COMMENT '员工号', `birth_date` date NOT NULL COMMENT '出生年月', `first_name` varchar(14) NOT NULL COMMENT '名', `last_name` varchar(16) NOT NULL COMMENT '姓', `gender` enum('M','F') NOT NULL COMMENT '性别', `hire_date` date NOT NULL COMMENT '雇佣时间', `ids` char(18) DEFAULT NULL COMMENT '身份证号', PRIMARY KEY (`emp_no`), KEY `idx_last_first_name` (`last_name`,`first_name`)) 下面SQL是遵循了最左匹配原则的语句 1SELECT * FROM employees WHERE last_name='Jones'; 1SELECT * FROM employees WHERE last_name='Jones' ORDER BY last_name,first_name desc; 1SELECT * FROM employees WHERE last_name='Jones' AND first_name='John'; 1SELECT * FROM employees WHERE last_name='Jones' AND (first_name='John' OR first_name='Jon'); 1SELECT * FROM employees WHERE last_name='Jones' AND first_name &gt;='M' AND first_name &lt; 'N'; 1SELECT * FROM employees WHERE last_name ='M' ORDER BY first_name,last_name desc; 不走索引的语句类型有 1SELECT * FROM employees WHERE first_name='John'; 1SELECT * FROM employees WHERE last_name='Jones' OR first_name='John'; 1SELECT * FROM employees WHERE last_name='Jones' ORDER BY first_name,last_name desc; 注意，排序时是否走索引受MySQL版本的影响，在MySQL8.0后，在排序查询中字段顺序不受影响。如图 但是在MySQL5.7及以下版本中，排序查询受字段顺序影响。 参考文档 MySQL联合索引 https://dev.mysql.com/doc/refman/5.7/en/multiple-column-indexes.html EXPLAIN输出格式 https://dev.mysql.com/doc/refman/5.7/en/explain-output.html Visual Explain图 https://dev.mysql.com/doc/workbench/en/wb-performance-explain.html 各个引擎支持的索引类型 https://dev.mysql.com/doc/refman/5.7/en/create-index.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://xlline.github.io/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://xlline.github.io/tags/MySQL/"},{"name":"索引","slug":"索引","permalink":"https://xlline.github.io/tags/%E7%B4%A2%E5%BC%95/"}]},{"title":"MySQL8.0之caching_sha2_password","slug":"MySQL-8.0之caching_sha2_password","date":"2019-11-15T09:02:34.000Z","updated":"2021-09-11T08:20:57.361Z","comments":true,"path":"2019/11/15/MySQL-8.0之caching_sha2_password/","link":"","permalink":"https://xlline.github.io/2019/11/15/MySQL-8.0%E4%B9%8Bcaching_sha2_password/","excerpt":"本地MySQL8.0.18安装完成在命令行中可以正常连接访问，使用Navicat测试连接报错Authentication plugin ‘caching_sha2_password’ cannot be loaded。导致异常的原因是MySQL不同版本使用的密码加密规则不一致。在MySQL8之前的版本使用的密码加密规则是mysql_native_password，但是在MySQL8则是caching_sha2_password。","text":"本地MySQL8.0.18安装完成在命令行中可以正常连接访问，使用Navicat测试连接报错Authentication plugin ‘caching_sha2_password’ cannot be loaded。导致异常的原因是MySQL不同版本使用的密码加密规则不一致。在MySQL8之前的版本使用的密码加密规则是mysql_native_password，但是在MySQL8则是caching_sha2_password。 解决方案：一、指定加密规则为mysql_native_password使用语句修改用户加密方式ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'root'; 后重置密码alter user user() identified by 'qwe123';创建了一个新用户并指定，在命令行中执行语句CREATE USER 'your username'@'%' IDENTIFIED WITH mysql_native_password BY 'your password';，完成后使用新用户账号密码连接Navicat。二、将默认密码规则设置为mysql_native_password，刷新权限并重置root密码如仍无法使用, 应在my.cnf中设置 default_authentication_plugin = mysql_native_password完成后并执行flush privileges; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://xlline.github.io/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://xlline.github.io/tags/MySQL/"},{"name":"Navicat","slug":"Navicat","permalink":"https://xlline.github.io/tags/Navicat/"}]},{"title":"Ubuntu速学笔记","slug":"Ubuntu","date":"2019-11-08T09:02:34.000Z","updated":"2021-09-11T08:21:52.262Z","comments":true,"path":"2019/11/08/Ubuntu/","link":"","permalink":"https://xlline.github.io/2019/11/08/Ubuntu/","excerpt":"为了学习docker来回顾Linux基础，本篇是基于Ubuntu操作系统18.04.3版本安装部署遇到问题或有用知识点的汇总整理。 ifconfig命令找不到问题描述： 在Vmware安装完成Ubuntu后，输入ifconfig提示：Command ‘ifconfig’ not found, but can be installed with: sudo apt install net-tools。当然官方提醒我们可以使用sudo apt install net-tools安装net-tools，然而并不如预想。","text":"为了学习docker来回顾Linux基础，本篇是基于Ubuntu操作系统18.04.3版本安装部署遇到问题或有用知识点的汇总整理。 ifconfig命令找不到问题描述： 在Vmware安装完成Ubuntu后，输入ifconfig提示：Command ‘ifconfig’ not found, but can be installed with: sudo apt install net-tools。当然官方提醒我们可以使用sudo apt install net-tools安装net-tools，然而并不如预想。 解决方案： 执行语句 sudo apt-get update &amp;&amp; sudo apt-get install net-tools再输入ifconfig就正常啦。(apt-get用于自动从互联网的软件仓库中搜索、安装、升级或卸载软件。我们需要定期执行apt-get update，让我们缓存包在系统中的软件列表源是最新的) 如果在过程中提示 E: Could not get lock /var/lib/apt/lists/lock - open (11: Resource temporarily unavailable)， 不用担心，这是因为上一次安装时异常退出导致锁残留，可直接删除掉这个锁文件，使用命令sudo rm /var/lib/apt/lists/lock。 编译安装PHP7.3.11 官网 http://php.net/downloads.php 下载安装包到本地或者使用wget wget http://cn2.php.net/distributions/php-7.3.11.tar.gz 安装依赖包 libxml2-dev和 gcca. 如果遇到错误：error:xml2-config not found.Please check your libxml2 installation. ，说明依赖包libxml2不存在，需要安装使用命令sudo apt-get update &amp;&amp; sudo apt-get install libxml2-dev -y。 b. 如果安装libxml2过程又提示Unable to fetch some archives, maybe run apt-get update or try with –fix-missing?，可执行apt-get install libxml2-dev -y --fix-missing解决。多次尝试无效时，保证当前网络连接正常的基础上，执行sudo apt-get clean再进行后续操作。 c. 如果又报错configure: error: no acceptable C compiler found in $PATH，是因为你本地没有可执行编译的源文件，需要执行sudo apt-get update &amp;&amp; sudo apt-get install gcc -y解决。 执行预编译，使用./configure --prefix=/usr/local/php(这个后面最好加上--with-config-file-path=/usr/local/php/conf，代表指定php.ini路径，否则后面需要自己去设置) 代表我要装到/usr/local/php里，配置文件放到conf里 安装，执行完成之后最后一定要执行make，这一步是真正的编译。然后还要执行sudo make install，这一步是拷贝到你的目标文件夹，否则/usr/local/php是不会有的。 验证，没有Hello world感觉不完整是不是。写个简单的PHP页面 环境变量基于用户级的环境变量设置 在home目录下的隐藏文件 .bashrc，输入export name=xugz设置个名字，使用source .bashrc执行。比如说我现在安装了Nodejs，但是只能在node安装目录下进行操作，如何处理呢？可以通过修改环境变量实现。在.bashrc文件中追加export PATH=$PATH:/home/xugz/tool/node-v12.13.0-linux-x64/bin后保存退出，使用source .bashrc执行就可以在任何文件目录下执行node操作了。全局环境变量在/etc/profile文件下 Mysql8.0.18源码安装 官网下载源码 源码包分为带boost版和不带boost版的，我这里直接下面自带boost版的。 社区版 Compressed TAR Archive, Includes Boost Headers。浏览器下载或者使用wget: 123wget https://dev.mysql.com/get/Downloads/MySQL-8.0/mysql-boost-8.0.18.tar.gztar xzv -f mysql-boost-8.0.18.tar.gzcd mysql-8.0.18/ 安装依赖编译工具sudo apt install cmake build-essential bison libssl-dev pkg-config git gcc g++ libncurses5 libncurses5-dev -y详细依赖列表参考点我 编译执行 cmake . -DCMAKE_INSTALL_PREFIX=/usr/local/mysql -DSYSCONFDIR=/etc -DMYSQL_DATADIR=/usr/local/mysql/data -DWITH_BOOST=boost -DFORCE_INSOURCE_BUILD=1 （cmake的完整选项列表点我）。运行成功，会显示 123-- Configuring done-- Generating done-- Build files have been written to: /home/xugz/Downloads/mysql-8.0.18 如果没有报错，执行make编译，然后开始漫长的等待，等待……编译完成后执行 make install 安装 新建 /usr/local/mysql文件, 修改归属用户权限chown xugz:xugz mysql 初始化配置详细参考 https://dev.mysql.com/doc/refman/8.0/en/installing-source-distribution.htmlmysqld是最终需要运行的可执行程序，不过我们一般使用mysqld_safe这个脚本来执行。进入安装目录 cd /usr/local/mysql，进入bin目录我们执行mysqld --verbose --help生成所有mysqld选项和可配置变量的列表 如上图所示，MySQL先去寻找/etc/mysql/my.cnf文件，如果没有再去寻找 /etc/my.cnf，还没有再去寻找~/.my.cnf。我们只需要三选一创建文件，这里我选择大众常用的 /etc/my.cnf。执行sudo vi /etc/my.cnf添加以下内容 123456789[client]port = 3306socket = /usr/local/mysql/data/mysql.sock[mysqld]port = 3306socket = /usr/local/mysql/data/mysql.sockbasedir = /usr/local/mysqldatadir = /usr/local/mysql/data 检查安装目录是否存在data文件夹，这个文件夹用来存放数据库文件的，没有的话需要手动创建，并修改当前用户所有权限。回到bin目录初始化数据库，使用命令./mysqld --initialize --user=xugz --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data/这一步会随机生成的root账号初始密码，记录备用 kacIL6Vxs*dX 启动&amp;连接使用命令/usr/local/mysql/bin/mysqld_safe 启动，然后新开命令窗口执行ps -ef | grep mysql 验证在/usr/local/mysql/bin目录下，使用./mysql -u root -p登陆，密码为刚才生成的随机字串。临时密码不可用，键入命令会提示修改。使用命令alter user user() identified by 'qwe123';退出后MySQL链接重进就可以正常操作了。 关闭数据库连接使用命令 ./mysqladmin -u root -pqwe123 shutdown Memcached安装 安装包下载 官网地址 或者使用wget。官网已经给我们详细说明 安装依赖 sudo apt-get install libevent-dev -y 灵活点根据官网提示修改 配置安装进入memcache下载目录使用命令 ./configure --prefix=/usr/local/memcached 完成后执行make，之后执行make install。这时我们就可以在/usr/local/memcached中看到bin目录了 启动 12345678/usr/local/memcached/bin/memcached -d -m 512 -u xugz -l 127.0.0.1 -p 11211 -c 1024 -P /usr/local/memcached/memcached.pid 备注： -d 以守护进程 -m 代表分配的内存（单位M） -l 连接的IP地址。默认只有本机可以连。多个IP用,连接 -c 最大并发连接数 -P pid文件 连接telnet 127.0.0.1 11211进入。使用set keyName flags 过期时间（秒） bytes(值的长度)换行，键入值。使用get keyName获取 Navicat安装下载安装包 官网地址完成后解压。进入解压后的目录运行./start_navicat即可破解方案：执行start_navicat时，会在用户主目录下生成一个名为.navicat的隐藏文件夹。cd /home/xugz/.navicat/此文件夹下有一个system.reg文件。把此文件删除后，下次启动navicat 会重新生成此文件，规定试用期会按新的时间开始计算。 编译安装PHP下面的memcahed拓展 安装基本依赖 sudo apt-get update &amp;&amp; sudo apt-get install autoconf igbinary msgpack zlib1g-dev -y 安装依赖包 libmemcached。进入官网下载地址下载完成后解压进入解压目录执行 ./configure &amp;&amp; make &amp;&amp; make install和memcached 下载拓展包git clone https://github.com/php-memcached-dev/php-memcached.git document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Linux","slug":"Linux","permalink":"https://xlline.github.io/categories/Linux/"},{"name":"Ubuntu","slug":"Linux/Ubuntu","permalink":"https://xlline.github.io/categories/Linux/Ubuntu/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://xlline.github.io/tags/Linux/"}]},{"title":"Docker学习笔记","slug":"Docker入门","date":"2019-11-06T08:27:21.000Z","updated":"2021-09-11T08:17:15.293Z","comments":true,"path":"2019/11/06/Docker入门/","link":"","permalink":"https://xlline.github.io/2019/11/06/Docker%E5%85%A5%E9%97%A8/","excerpt":"CentOS8安装Docker卸载旧版本较旧的 Docker 版本称为 docker 或 docker-engine 。如果已安装这些程序，请卸载它们以及相关的依赖项 安装步骤 下载docker-ce的repocurl https://download.docker.com/linux/centos/docker-ce.repo -o /etc/yum.repos.d/docker-ce.repo 安装依赖（这是相比centos7的关键步骤）yum install https://download.docker.com/linux/fedora/30/x86_64/stable/Packages/containerd.io-1.2.6-3.3.fc30.x86_64.rpm 安装docker-ceyum install docker-ce 启动dockersystemctl start docker启动成功，使用systemctl status docker 查看docker启动状态或者使用docker version验证是否安装成功。","text":"CentOS8安装Docker卸载旧版本较旧的 Docker 版本称为 docker 或 docker-engine 。如果已安装这些程序，请卸载它们以及相关的依赖项 安装步骤 下载docker-ce的repocurl https://download.docker.com/linux/centos/docker-ce.repo -o /etc/yum.repos.d/docker-ce.repo 安装依赖（这是相比centos7的关键步骤）yum install https://download.docker.com/linux/fedora/30/x86_64/stable/Packages/containerd.io-1.2.6-3.3.fc30.x86_64.rpm 安装docker-ceyum install docker-ce 启动dockersystemctl start docker启动成功，使用systemctl status docker 查看docker启动状态或者使用docker version验证是否安装成功。 普通用户运行docker命令不需要使用sudo在Linux系统中运行没有sudo密码的特定命令 12345678910[xugz@xugz yum.repos.d]$ docker imagesGot permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get http://%2Fvar%2Frun%2Fdocker.sock/v1.40/images/json: dial unix /var/run/docker.sock: connect: permission denied[xugz@xugz yum.repos.d]$ sudo docker images[sudo] password for xugz:REPOSITORY TAG IMAGE ID CREATED SIZE[xugz@xugz yum.repos.d]$ id xugzuid=1000(xugz) gid=1000(xugz) groups=1000(xugz),0(root)[xugz@xugz yum.repos.d]$ sudo usermod -aG docker $(whoami)[xugz@xugz yum.repos.d]$ id xugzuid=1000(xugz) gid=1000(xugz) groups=1000(xugz),984(docker),0(root) 注销并再次登录以使用没有sudo的Docker，可以使用docker version命令检查安装的Docker版本了。 常见问题docker 安装完成后测试hello-world出现问题（Unable to find image ‘hello-world:latest’ locally）安装docker之后，测试hello-world镜像，终端卡在Unable to find image 'hello-world:latest' locally位置docker在本地没有找到hello-world镜像，也没有从docker仓库中拉取镜像，出项这个问题的原因：是因为docker服务器再国外，我们在国内无法正常拉取镜像，所以就需要我们设置国内的镜像加速器。（我这里用的是阿里云，当然其他的也可以，大家可以自己选择。Docker 官方和国内很多云服务商都提供了国内加速器服务，例如： Docker官方提供的中国镜像库：https://registry.docker-cn.com）。使用 systemd 的系统的同学，需要新增配置文件/etc/docker/daemon.json，添加以下内容保存退出 1{\"registry-mirrors\": [\"https://alzgoonw.mirror.aliyuncs.com\"]} 之后重新启动服务 12sudo systemctl daemon-reloadsudo systemctl restart docker 重启之后，就可以正常拉取helloworld镜像了。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Docker","slug":"Docker","permalink":"https://xlline.github.io/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://xlline.github.io/tags/Docker/"}]},{"title":"不要重复使用PHP的number_format函数","slug":"PHP-number_format函数","date":"2019-11-04T09:34:52.000Z","updated":"2021-09-11T08:44:03.360Z","comments":true,"path":"2019/11/04/PHP-number_format函数/","link":"","permalink":"https://xlline.github.io/2019/11/04/PHP-number_format%E5%87%BD%E6%95%B0/","excerpt":"和其他朋友聊起来，说是他们公司临近双十一做了一套秒杀系统，价值三千多的商品，被三块钱卖出去了。这种情况大概率是金额精度操作或者格式化有误之类的问题。果不其然，最后发现是重复使用number_format函数造成金额截取。这坑没有必要跳进去，现在写下来加深下记忆力，希望自己不会犯类似错误。","text":"和其他朋友聊起来，说是他们公司临近双十一做了一套秒杀系统，价值三千多的商品，被三块钱卖出去了。这种情况大概率是金额精度操作或者格式化有误之类的问题。果不其然，最后发现是重复使用number_format函数造成金额截取。这坑没有必要跳进去，现在写下来加深下记忆力，希望自己不会犯类似错误。 number_format() 函数通过千位分组来格式化数字。 Tips:该函数支持一个、两个或四个参数。 语法 number_format(number,decimals,decimalpoint,separator) 参数 描述 number 必需。要格式化的数字。如果未设置其他参数，则数字会被格式化为不带小数点且以逗号（,）作为千位分隔符。 decimals 可选。规定多少个小数。如果设置了该参数，则使用点号（.）作为小数点来格式化数字 decimalpoint 可选。规定用作小数点的字符串。 separator 可选。规定用作千位分隔符的字符串。仅使用该参数的第一个字符。比如 “xxx” 仅输出 “x”。注释：如果设置了该参数，那么所有其他参数都是必需的。 技术细节 参数 备注 返回值: 返回已格式化的数字。 PHP 版本： 4+ 更新日志： 自 PHP 5.4 起，该函数在参数 decimalpoint 和 separator 中支持多字节。在更老的版本中，只使用每个分隔符的第一个字节。 例子12345678910111213141516&lt;?php$num = 4999.59;echo number_format($num).\"\\n\";// 这里结果正确，四舍五入取整，输出结果为：5,000$formattedNum = number_format($num, 2);echo $formattedNum.\"\\n\";// 这里结果正确，保留两位小数，输出结果为：4,999.59echo number_format($num,2,'.',',').\"\\n\";// 这里结果正确，保留两位小数，输出结果为：4,999.59echo number_format($formattedNum).\"\\n\";// 这里有报错提醒（PHP Notice: A non well formed numeric value encountered in /usercode/file.php on），输出结果为：4// 假设以 $formattedNum 进行加减后再来一遍format就不会有报错，但是金额错的就更离谱了，假设运费六元 不考虑精度问题直接加减进行测试，如下$fee = 6; $totalAmount = $formattedNum + $fee;echo number_format($totalAmount).\"\\n\"; 从上面的栗子可以明显看出来，重复使用number_format会导致数字异常，需要留意。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"PHP","slug":"PHP","permalink":"https://xlline.github.io/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://xlline.github.io/tags/PHP/"}]},{"title":"SSH秘钥操作","slug":"SSH秘钥操作","date":"2019-10-31T06:52:34.000Z","updated":"2021-09-11T08:44:17.030Z","comments":true,"path":"2019/10/31/SSH秘钥操作/","link":"","permalink":"https://xlline.github.io/2019/10/31/SSH%E7%A7%98%E9%92%A5%E6%93%8D%E4%BD%9C/","excerpt":"前言SSH 为 Secure Shell 的缩写，由 IETF 的网络小组（Network Working Group）所制定；SSH 为建立在应用层基础上的安全协议。SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH最初是UNIX系统上的一个程序，后来又迅速扩展到其他操作平台。SSH在正确使用时可弥补网络中的漏洞。SSH客户端适用于多种平台。几乎所有UNIX平台—包括HP-UX、Linux、AIX、Solaris、Digital UNIX、Irix，以及其他平台，都可运行SSH。","text":"前言SSH 为 Secure Shell 的缩写，由 IETF 的网络小组（Network Working Group）所制定；SSH 为建立在应用层基础上的安全协议。SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH最初是UNIX系统上的一个程序，后来又迅速扩展到其他操作平台。SSH在正确使用时可弥补网络中的漏洞。SSH客户端适用于多种平台。几乎所有UNIX平台—包括HP-UX、Linux、AIX、Solaris、Digital UNIX、Irix，以及其他平台，都可运行SSH。 验证方式从客户端来看，SSH提供两种级别的安全验证。 第一种级别基于口令的安全验证只要你知道自己帐号和口令，就可以登录到远程主机。所有传输的数据都会被加密，但是不能保证你正在连接的服务器就是你想连接的服务器。可能会有别的服务器在冒充真正的服务器，也就是受到“中间人”这种方式的攻击。 第二种级别基于密钥的安全验证依靠密钥，为本地创建，公钥要放到需要访问的服务器上。使用SSH连接到服务器，客户端向服务器发出请求，请求用你的密钥进行安全验证。服务器收到请求后在你的目录下寻找属于你的公共密钥，找到后和你发过来的进行比较。如果密钥一致，服务器用你的公钥加密随机字符串给到客户端。客户端使用私钥解密得到随机字符串后MD5加密给到服务端，服务端拿随机字符串进行同样操作后验证两个字符是否一致的过程。 SSH密钥操作 客户端生成密钥对ssh-keygen -t rsaTips:一路回车就好~ 客户端进入.SSH目录cd C:\\Users\\Administrator\\.ssh 客户端把公钥拷贝到linux下/root/.ssh目录下scp id_rsa.pub root@192.168.2.1:/root/.sshTips: 保证目标服务器存在/root/.ssh目录哦 目标服务器中把公钥改名mv id_rsa.pub authorized_keys 客户端无口令测试-命令操作ssh root@192.168.2.1 客户端无口令测试-文件传输scp index.php root@192.168.2.1:/root/ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"SSH","slug":"SSH","permalink":"https://xlline.github.io/categories/SSH/"}],"tags":[{"name":"SSH","slug":"SSH","permalink":"https://xlline.github.io/tags/SSH/"}]},{"title":"linux中rc.local设置开机自启没有生效","slug":"Linux-rc.local开机自启未生效","date":"2019-10-29T09:29:34.000Z","updated":"2021-09-11T08:46:18.572Z","comments":true,"path":"2019/10/29/Linux-rc.local开机自启未生效/","link":"","permalink":"https://xlline.github.io/2019/10/29/Linux-rc.local%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E6%9C%AA%E7%94%9F%E6%95%88/","excerpt":"在/etc/rc.d/rc.local中追加了执行命令但重启未生效，在网上找到解决方案： 查看指定文件相关数据使用ll /etc/rc.d/rc.local在第一个栏位文件的属性。Linux的文件基本上分为三个属性：可读（r），可写（w），可执行（x）。发现/etc/rc.d/rc.local没有可执行权限 使用chmod命令修改在/etc/rc.d/rc.local有这样一段话12# Please note that you must run 'chmod +x /etc/rc.d/rc.local' to ensure# that this script will be executed during boot. 执行chome +x /etc/rc.d/rc.local命令后，重启发现命令可以执行了。但前提要保证执行命令正确可执行才行。","text":"在/etc/rc.d/rc.local中追加了执行命令但重启未生效，在网上找到解决方案： 查看指定文件相关数据使用ll /etc/rc.d/rc.local在第一个栏位文件的属性。Linux的文件基本上分为三个属性：可读（r），可写（w），可执行（x）。发现/etc/rc.d/rc.local没有可执行权限 使用chmod命令修改在/etc/rc.d/rc.local有这样一段话12# Please note that you must run 'chmod +x /etc/rc.d/rc.local' to ensure# that this script will be executed during boot. 执行chome +x /etc/rc.d/rc.local命令后，重启发现命令可以执行了。但前提要保证执行命令正确可执行才行。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Linux","slug":"Linux","permalink":"https://xlline.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://xlline.github.io/tags/Linux/"}]},{"title":"rsync+sersync实现数据实时同步","slug":"rsync+sersync","date":"2019-10-29T06:26:34.000Z","updated":"2021-09-11T08:45:38.809Z","comments":true,"path":"2019/10/29/rsync+sersync/","link":"","permalink":"https://xlline.github.io/2019/10/29/rsync+sersync/","excerpt":"sersync是基于inotify+rsync的大量文件的多服务器自动同步程序使用 Linux 2.6 内核的 inotify 监控 Linux 文件系统事件，被监听目录下如果有文件发生修改，sersync 将通过内核自动捕获到事件，并将该文件利用 rsync 同步到多台远程服务器。sersync 仅仅同步发生增、删、改事件的单个文件或目录，不像rsync镜像同步那样需要比对双方服务器整个目录下数千万的文件，并且支持多线程同步，因此效率非常高 rsync 采用c/s模式，监听端口为 873","text":"sersync是基于inotify+rsync的大量文件的多服务器自动同步程序使用 Linux 2.6 内核的 inotify 监控 Linux 文件系统事件，被监听目录下如果有文件发生修改，sersync 将通过内核自动捕获到事件，并将该文件利用 rsync 同步到多台远程服务器。sersync 仅仅同步发生增、删、改事件的单个文件或目录，不像rsync镜像同步那样需要比对双方服务器整个目录下数千万的文件，并且支持多线程同步，因此效率非常高 rsync 采用c/s模式，监听端口为 873 前期准备下载sersync 123谷歌项目地址：(https://code.google.com/archive/p/sersync/) 64位下载地址：(https://storage.googleapis.com/google-code-archive-downloads/v2/code.google.com/sersync/sersync2.5.4_64bit_binary_stable_final.tar.gz) 32位下载地址：(https://storage.googleapis.com/google-code-archive-downloads/v2/code.google.com/sersync/sersync2.5_32bit_binary_stable_final.tar.gz) 上不去google的可以使用百度网盘我的备份包，这里只提供64位版本的：链接：https://pan.baidu.com/s/1j3H7KBv4y3_DzOWb-rwpMQ提取码：0g8a 注： 压缩包里面有两个文件confxml.xml和sersync2。前者是sersync配置文件，后者是sersync主程序。 确认当前系统关闭selinux及防火墙，或将873端口加入iptables白名单注意： 该步骤需要在备份源服务器和目标服务器上都要操作 关闭SELINUX 123456[root@rsync ~]# vim /etc/selinux/config #编辑防火墙配置文件#SELINUX=enforcing #注释掉#SELINUXTYPE=targeted #注释掉SELINUX=disabled #增加:wq! #保存，退出[root@rsync ~]# setenforce 0 #立即生效 开启防火墙tcp 873端口 1234[root@rsync ~]# vim /etc/sysconfig/iptables #编辑防火墙配置文件-A RH-Firewall-1-INPUT -m state --state NEW -m tcp -p tcp --dport 873 -j ACCEPT:wq! #保存退出[root@rsync ~]# /etc/init.d/iptables restart #最后重启防火墙使配置生效 开放873端口 比如阿里云服务器 要到后台设置哦 需求说明我这里有两台centos8的主机，IP分别是192.168.2.98和192.168.2.248。我在192.168.2.98安装sersync，主动推送数据到192.168.2.248上。也就是说 192.168.2.98作为数据备份源，192.168.2.248作为目标机器。 实现过程目标机器配置 安装rsyncyum install rsync 创建rsync配置文件vi /etc/rsyncd.conf 增加以下内容 123456789101112131415161718uid = root #这里是系统用户 需要有备份目标文件夹操作权限 这个注释后续需要删除gid = rootuse chroot = yeshosts allow=*max connections = 5port = 873timeout = 900pid file = /var/run/rsyncd.pidlock file = /var/run/rsync.locklog file = /var/log/rsyncd.logmotd file = /etc/rsyncd.motd[backup]path = /var/www/backupcomment = Hiread only = falselist =yesauth users = rsyncusersecrets file =/etc/rsync.passwd 编辑完成保存退出 具体配置注释见下图 在secrets file指定的用户密码文件vim /etc/rsync.passwd 内容格式：用户名：密码,可以设置多个，每行一个用户名:密码执行echo \"rsyncuser:password\" &gt;&gt; /etc/rsync.passwd把内容追加到rsync.passwd末尾然后，更改文件的读写权限为600chmod 600 /etc/rsync.passwd 启动rsync配置完成可使用netstat -antup |grep 873 查看是否有端口873在运行没有的话启动/usr/bin/rsync --daemon # 以守护进程方式/usr/bin/rsync --daemon --config=/etc/rsyncd.conf # 加载配置文件rsyncd.conf启动rsync服务 注： 可使用 kill -9 杀掉进程.(进程ID 可以通过 ps aux | grep rsync 方法得到) 配置rsync开机自启动直接追加 echo \"/usr/bin/rsync --daemon --config=/etc/rsyncd.conf\" &gt;&gt; /etc/rc.d/rc.local 实时监控进入你要备份的目标路径 键入watch ls -l可实现实时监控。 数据备份源机器配置 安装rsync 123[root@rsync ~]# whereis rsync #查看系统是否已安装rsync,出现下面的提示，说明已经安装rsync: /usr/bin/rsync /usr/share/man/man1/rsync.1.gzyum install rsync #如果默认没有rsync，运行此命令进行安装rsync 下载sersync到本地解压 1234567# 我这里将sersync放在了/usr/local/sersync/目录下 cd /usr/local/ wget https://storage.googleapis.com/google-code-archive-downloads/v2/code.google.com/sersync/sersync2.5.4_64bit_binary_stable_final.tar.gz tar xzf sersync2.5.4_64bit_binary_stable_final.tar.gz rm -rf sersync2.5.4_64bit_binary_stable_final.tar.gz mv GNU-Linux-x86/ sersync cd sersync 创建认证密码文件密码需和目标服务器配置的一致，且不需要用户名．将该文件的权限也更改为600echo \"password\" &gt;&gt; /etc/rsync.passwdchmod 600 /etc/rsync.passwd 修改confxml.xml文件 12345678910......&lt;sersync&gt;24 &lt;localpath watch=\"监控目录路径\"&gt;25 &lt;remote ip=\"rsync目标服务端IP地址\" name=\"模块名\"/&gt;......&lt;rsync&gt;30 &lt;commonParams params=\"-az\"/&gt;31 &lt;auth start=\"true\" users=\"rsync客户端用户名\" passwordfile=\"rsync客户端密码文件\"/&gt;......36 &lt;failLog path=\"指定Sersync日志文件路径\" timeToExecute=\"60\"/&gt;...... 修改权限 chmod +x sersync2 读取指定路径配置文件启动sersync /usr/local/serync/serync2 -d -r -o /usr/local/sersync/confxml.xml耐心等待执行完成后进行后续操作。 -n 启用线程数量 -d daemon方式启动 -o 指定配置文件 sersync整体同步一次 在sersync目录下运行 ./sersync2 -r 开启实时同步命令 ./sersync2 -d。 一般先运行完整体同步后，再进行该命令操作 设置开机启动echo \"/usr/local/sersync/sersync2 -r -d -o /usr/local/sersync/confxml.xml\" &gt;&gt; /etc/rc.d/rc.local执行完成可以测试。 添加脚本监控sersync是否正常运行 编辑脚本vi /usr/local/check_sersync.sh，添加以下代码 #!/bin/bash sersync=\"/usr/local/serync/serync2\" confxml=\"/usr/local/sersync/confxml.xml\" status=$(ps aux |grep 'sersync2'|grep -v 'grep' |wc -l) if [ $status -eq 0 ]; then $sersync -d -r -o $confxml &amp; else exit 0; fi 测试脚本sh /usr/local/check_sersync.sh 赋予脚本执行权限chmod +x /usr/local/check_sersync.sh 定义计划任务实现定时备份echo ‘*/5 * * * * sh /usr/local/check_sersync.sh &amp;’ &gt;&gt; /var/spool/cron/root rsync参数说明 参考文章 https://blog.whsir.com/post-1097.htmlhttps://blog.csdn.net/chrisjingu/article/details/78317907https://www.jianshu.com/p/31a67de3f669 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Linux","slug":"Linux","permalink":"https://xlline.github.io/categories/Linux/"},{"name":"rsync","slug":"Linux/rsync","permalink":"https://xlline.github.io/categories/Linux/rsync/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://xlline.github.io/tags/Linux/"},{"name":"rsync","slug":"rsync","permalink":"https://xlline.github.io/tags/rsync/"}]},{"title":"虚拟机ping不通主机，但是主机可以ping通虚拟机","slug":"ping_error","date":"2019-10-28T10:02:34.000Z","updated":"2021-09-11T08:44:59.980Z","comments":true,"path":"2019/10/28/ping_error/","link":"","permalink":"https://xlline.github.io/2019/10/28/ping_error/","excerpt":"在Windows10系统安装了虚拟机，设置的主机与虚拟机的连接方式是桥接，安装好后，发现虚拟机ping不通主机，但是主机可以ping通虚拟机。上网查看资料，发现是因为Windows10防火墙阻止，防火墙没有打开ICMPv4-in这个规则。那怎么打开呢？","text":"在Windows10系统安装了虚拟机，设置的主机与虚拟机的连接方式是桥接，安装好后，发现虚拟机ping不通主机，但是主机可以ping通虚拟机。上网查看资料，发现是因为Windows10防火墙阻止，防火墙没有打开ICMPv4-in这个规则。那怎么打开呢？ 修改防火墙规则设置 &gt; 网络和Internet &gt; Windows防火墙 &gt; 高级设置 &gt; 入站规则中找到配置文件类型为“公用”的“文件和打印共享（回显请求 – ICMPv4-In）”规则，设置为启用规则。这样虚拟机就可以ping通主机了。 更改适配器选项如果确保安装无误且防火墙已关闭却还没解决问题,可能是这个原因，我们一般都是自动获取ip地址和网关，设置为手动就可以了。步骤如下：打开cmd查看你的IP地址，ipconfig，记住IP地址和默认网关。 设置 &gt; 网络和Internet &gt; 更改适配器选项 &gt; 选择主机连接的网络右键属性 &gt; Internet 协议4（TCP/IPv4）属性 中选择使用下面的DNS服务器地址进行自定义，填入IP地址 默认网关和子网掩码再试。 防火墙是虚拟机ping不通本机ip的主要原因，但是如果开启了入站规则没管用那就是其他问题了，我的把自动获取改为手动就好了，之前设置的入站规则也管用了，现在防火墙也都开着。 本文参考文章： 链接 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Linux","slug":"Linux","permalink":"https://xlline.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://xlline.github.io/tags/Linux/"},{"name":"VMware","slug":"VMware","permalink":"https://xlline.github.io/tags/VMware/"}]},{"title":"实现Hexo博客多地更新和配置博客源文件","slug":"Hexo-deploy","date":"2019-10-25T06:51:37.000Z","updated":"2021-09-11T08:18:24.498Z","comments":true,"path":"2019/10/25/Hexo-deploy/","link":"","permalink":"https://xlline.github.io/2019/10/25/Hexo-deploy/","excerpt":"使用Hexo部署上传GitHub后我们发现，博客源文件没有上传，处于安全考虑在.gitinore文件中配置忽略了。仅仅将public文件夹内的文件通过hexo d上传到GitHub去了，其他的文件则留在本地目录下。为解决多台电脑需要更新博客和博客部署文件隔离的问题，这里将使用github存放网站静态文件，coding私有仓库存放博客源文件来处理。","text":"使用Hexo部署上传GitHub后我们发现，博客源文件没有上传，处于安全考虑在.gitinore文件中配置忽略了。仅仅将public文件夹内的文件通过hexo d上传到GitHub去了，其他的文件则留在本地目录下。为解决多台电脑需要更新博客和博客部署文件隔离的问题，这里将使用github存放网站静态文件，coding私有仓库存放博客源文件来处理。 准备工作确保已经使用hexo在GitHub搭建好了自己的个人博客，步骤参见 使用Hexo+GitHub搭建个人博客教程 参数配置 注册/登录Coding，点此进入 新建项目 新建代码仓库 配置SSH公钥 路径：头像 &gt; 个人账户设置 &gt; SSH公钥 &gt; 新增公钥 新建代码仓库 git clone到本地 将本地博客代码copy过来 修改.gitinore文件如下1234567.DS_StoreThumbs.dbdb.json*.lognode_modules/public/.deploy*/ 将themes目录以内中的主题的.git目录删除（如果有），因为一个git仓库中不能包含另一个git仓库，提交主题文件夹会失败。 使用git提交变动到Coding仓库。完成后就可以在当前目录进行正常博客更新与维护了。此时我们的静态文件会在执行hexo d时被上传到GitHub，不要忘记使用git命令上传到coding对应仓库。 当存在新电脑 将新电脑生成的SSH KEY分别添加到GitHub和Coding中 在新电脑上将Coding中存放Hexo源码的仓库clone到本地 执行npm install 可以进行博客文章的编辑和新增了。完成后使用git提交源文件变动到Coding，使用hexo g &amp;&amp; hexo d更新静态文件到GitHub。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://xlline.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://xlline.github.io/tags/Hexo/"}]},{"title":"Hexo博客添加图片不显示问题","slug":"Hexo-addpic","date":"2019-10-25T05:52:14.000Z","updated":"2021-09-11T08:40:33.292Z","comments":true,"path":"2019/10/25/Hexo-addpic/","link":"","permalink":"https://xlline.github.io/2019/10/25/Hexo-addpic/","excerpt":"本想在自己文章中加入图片进行详细说明，奈何这图片偏要与我玩躲猫猫死活不出来，在网上看了几篇博客之后才得以解决，浪费了一些不必要的时间。所以在这里记录一下，希望以后遇到这问题可以快速解决。 🚴","text":"本想在自己文章中加入图片进行详细说明，奈何这图片偏要与我玩躲猫猫死活不出来，在网上看了几篇博客之后才得以解决，浪费了一些不必要的时间。所以在这里记录一下，希望以后遇到这问题可以快速解决。 🚴 安装插件在博客文件所在位置，右键-&gt;打开git bash后键入 1npm install hexo-asset-image --save 安装完成后，使用命令hexo new 'test'新建文章时，会在test.md同目录(_post)下生成同名文件夹，该文件夹可用于存放对应文章的图片等相关信息当然，你也可以手动创建与新建文章同名的文件夹。 修改配置文件把站点配置文件_config.yml的 post_asset_folder设置为 true在blog（hexo）目录下执行 npm install hexo-asset-image --save 引入图片格式使用markdown的格式引入图片：![你想要输入的替代文字](存放图片的文件夹名称/图片名.jpg) 提示：通过常规的 markdown 语法和相对路径来引用图片和其它资源可能会导致它们在存档页或者主页上显示不正确。如果你也恰好遇到该问题，可以使用下方标签解决： 1{% asset_img example.jpg This is an example image %} 执行hexo g -d 生成页面并部署后查看图片是否正常显示 如果以上步骤都确认执行完成但图片还是很有个性，千呼万唤不出来。那么到/node_modules/hexo-asset-image/index.js文件更换为如下内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960'use strict';var cheerio = require('cheerio');// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-stringfunction getPosition(str, m, i) { return str.split(m, i).join(m).length;}var version = String(hexo.version).split('.');hexo.extend.filter.register('after_post_render', function(data){ var config = hexo.config; if(config.post_asset_folder){ var link = data.permalink; if(version.length &gt; 0 &amp;&amp; Number(version[0]) == 3) var beginPos = getPosition(link, '/', 1) + 1; else var beginPos = getPosition(link, '/', 3) + 1; // In hexo 3.1.1, the permalink of \"about\" page is like \".../about/index.html\". var endPos = link.lastIndexOf('/') + 1; link = link.substring(beginPos, endPos); var toprocess = ['excerpt', 'more', 'content']; for(var i = 0; i &lt; toprocess.length; i++){ var key = toprocess[i]; var $ = cheerio.load(data[key], { ignoreWhitespace: false, xmlMode: false, lowerCaseTags: false, decodeEntities: false }); $('img').each(function(){ if ($(this).attr('src')){ // For windows style path, we replace '\\' to '/'. var src = $(this).attr('src').replace('\\\\', '/'); if(!/http[s]*.*|\\/\\/.*/.test(src) &amp;&amp; !/^\\s*\\//.test(src)) { // For \"about\" page, the first part of \"src\" can't be removed. // In addition, to support multi-level local directory. var linkArray = link.split('/').filter(function(elem){ return elem != ''; }); var srcArray = src.split('/').filter(function(elem){ return elem != '' &amp;&amp; elem != '.'; }); if(srcArray.length &gt; 1) srcArray.shift(); src = srcArray.join('/'); $(this).attr('src', config.root + link + src); console.info&amp;&amp;console.info(\"update link as:--&gt;\"+config.root + link + src); } }else{ console.info&amp;&amp;console.info(\"no src attr, skipped...\"); console.info&amp;&amp;console.info($(this)); } }); data[key] = $.html(); } }}); 自测以上方法可以解决我的问题，希望对你有帮助。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://xlline.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://xlline.github.io/tags/Hexo/"}]},{"title":"Git bash Error:Could not fork child process:There are no available terminals (-1)","slug":"Gitbash_error","date":"2019-10-25T03:22:14.000Z","updated":"2021-09-11T08:42:42.053Z","comments":true,"path":"2019/10/25/Gitbash_error/","link":"","permalink":"https://xlline.github.io/2019/10/25/Gitbash_error/","excerpt":"使用Git bash未正常退出后，再次打开出现 Git bash Error: Could not fork child process: There are no available terminals (-1)报错。可以使用 tasklist命令 找到git-bash.exe和node.exe对应进程号后，使用taskkill结束进程即可。","text":"使用Git bash未正常退出后，再次打开出现 Git bash Error: Could not fork child process: There are no available terminals (-1)报错。可以使用 tasklist命令 找到git-bash.exe和node.exe对应进程号后，使用taskkill结束进程即可。 win+r调出运行键入cmd后回车打开，使用tasklist查看本机进程。查询得到的字段有： 映像名称，PID(进程ID)，会话名，会话#，内存使用。如下图： 如图 smss.exe 的进程ID为 520(你看随便找个进程都是爱你的数字)，咳咳 找到git-bash.exe对应的进程号，比如我的是 12184，然后使用命令 taskkill /pid 12184 -t -f 终止ID为12184的进程。 找到node.exe对应的进程号，比如我的是 868，然后使用命令 taskkill /pid 868 -t -f 终止ID为868的进程。 终止后，即可打开git bash终端再次尝试。自测可以解决问题，希望对你有帮助。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Git","slug":"Git","permalink":"https://xlline.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://xlline.github.io/tags/Git/"},{"name":"taskkill","slug":"taskkill","permalink":"https://xlline.github.io/tags/taskkill/"}]},{"title":"Linux的crontab命令","slug":"Linux-crontab","date":"2019-10-23T09:02:34.000Z","updated":"2021-09-11T08:43:21.917Z","comments":true,"path":"2019/10/23/Linux-crontab/","link":"","permalink":"https://xlline.github.io/2019/10/23/Linux-crontab/","excerpt":"Linux下的任务调度分为两类：系统任务调度和用户任务调度。系统任务调度：系统周期性所要执行的工作，比如写缓存数据到硬盘、日志清理等。在/etc目录下有一个crontab文件，这个就是系统任务调度的配置文件。用户任务调度：用户定期要执行的工作，比如用户数据备份、定时邮件提醒等。用户可以使用 crontab 工具来定制自己的计划任务。","text":"Linux下的任务调度分为两类：系统任务调度和用户任务调度。系统任务调度：系统周期性所要执行的工作，比如写缓存数据到硬盘、日志清理等。在/etc目录下有一个crontab文件，这个就是系统任务调度的配置文件。用户任务调度：用户定期要执行的工作，比如用户数据备份、定时邮件提醒等。用户可以使用 crontab 工具来定制自己的计划任务。 所有用户定义的crontab文件都被保存在/var/spool/cron目录中。其文件名与用户名一致，使用者权限文件如下：/etc/cron.deny 该文件中所列用户不允许使用crontab命令/etc/cron.allow 该文件中所列用户允许使用crontab命令/var/spool/cron/ 所有用户crontab文件存放的目录,以用户名命名 12345678分 时 日 月 星期 命令# .---------------- minute (0 - 59)# | .------------- hour (0 - 23)# | | .---------- day of month (1 - 31)# | | | .------- month (1 - 12) OR jan,feb,mar,apr ...# | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat# | | | | |# * * * * * user-name command to be executed 在以上各个字段中，还可以使用以下特殊字符：星号（*）：代表所有可能的值，例如month字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。逗号（,）：可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9”中杠（-）：可以用整数之间的中杠表示一个整数范围，例如“2-6”表示“2,3,4,5,6”正斜线（/）：可以用正斜线指定时间的间隔频率，例如“0-23/2”表示每两小时执行一次。同时正斜线可以和星号一起使用，例如*/10，如果用在minute字段，表示每十分钟执行一次。 1234567/sbin/service crond start // 启动服务 或者使用 service crond start 命令 手动启动crontab服务/sbin/service crond stop // 关闭服务/sbin/service crond restart // 重启服务/sbin/service crond reload // 重新载入配置chkconfig –level 35 crond on // 加入开机自动启动service crond status // 查看crontab服务状态 crontab (选项 例如:-e)(参数 crontab文件)-e：编辑该用户的计时器设置；-l：列出该用户的计时器设置；-r：删除该用户的计时器设置；-u&lt;用户名称&gt;：指定要设定计时器的用户名称。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Linux","slug":"Linux","permalink":"https://xlline.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://xlline.github.io/tags/Linux/"},{"name":"crontab","slug":"crontab","permalink":"https://xlline.github.io/tags/crontab/"}]},{"title":"Linux基础","slug":"Linux-base","date":"2019-10-23T09:02:34.000Z","updated":"2021-09-11T08:42:48.532Z","comments":true,"path":"2019/10/23/Linux-base/","link":"","permalink":"https://xlline.github.io/2019/10/23/Linux-base/","excerpt":"最近在云之梦网站学习Linux基础，发现有好多基础命令见面不相识……此篇作为学习笔记，利用零碎的时间终于完成课程学习，该篇添加常用命令以方便后续翻阅参考。","text":"最近在云之梦网站学习Linux基础，发现有好多基础命令见面不相识……此篇作为学习笔记，利用零碎的时间终于完成课程学习，该篇添加常用命令以方便后续翻阅参考。 操作系统操作系统分类 客户端操作系统 windows 7,8,10等 服务器端操作系统 windows server 2019 linux操作系统 centos redhat enterprise linux rhel ubuntu debian suse opensuse freebsd aliyun linux coreos unix操作系统常用命令Linux查看版本当前操作系统内核信息uname -aLinux查看当前操作系统版本信息cat /proc/versionLinux查看版本当前操作系统发行版信息cat /etc/redhat-release查看centOS版本cat /etc/centos-release查看内存 free or free -m or free -g查看硬盘 df or df -T or df -h查看系统正在登录的用户 who查看系统最后一重要操作 last查看进程实时消耗的cpu和内存 top查看系统1分钟、5分钟和15分钟平均负载 uptime查看服务进程 ps -ef or pstree == !ps查看服务端口 netstat -tunpl杀掉进程 kill -9 pid or pkill pname 系统启动流程 BIOS加电自检 把MBR加载到内存 加载grub Kernel自身初始化 启动第一个程序systemd 检查默认运行级别Linux运行级别0 shutdown.target(关机) 1 emergency.target(紧急救援模式) 2 rescue.target(救援模式) 3 multi-user.target(多用户模式|字符系统模式) 4 无 5 graphical.target(桌面系统) 6 无(重启) 常用命令 查看运行级别 runlevelinit命令`init 0` // 关机 `init 3` // 到达字符界面 `init 5` // 到达图形界面 `init 6` // 重启 systemd服务管理 利用systemctl 进行服务控制。 1. 查看默认级别 `systemctl get-default` Tips: 或者使用`cd /etc/systemd/system`后`ll`查看`default.target`字段 2. 设置默认级别 `systemctl set-default multi-user.target` 3. 查看指定服务状态 `systemctl status sshd.service` 4. 启动服务指定服务 `systemctl start sshd.service` 5. 重启服务指定服务 `systemctl restart sshd.service` 6. 关闭服务指定服务 `systemctl stop sshd.service` 7. 重载服务指定服务 `systemctl reload sshd.service` 8. 开机启动指定服务 `systemctl enable sshd.service` 9. 开机关闭指定服务 `systemctl disable sshd.serivce` 9. 查看指定服务是否开机启动 `systemctl is-enabled sshd.service` 10. 查看指定服务是否启动 `systemctl is-active sshd.serivce` 11. 临时切换选择分配运行级别 `systemctl isolate multi-user.target` # 临时切换选择分配运行级别至字符系统模式 `systemctl isolate graphical.target` # 临时切换选择分配运行级别至桌面系统模式 12. 列出所有target `systemctl list-units --type=target --all` 13. 查看系统中所有服务的启动状态 `systemctl list-unit-files` 启动相应级别下的所有程序服务 加载/etc/rc.d/rc.local脚本直接在/etc/rc.d/rc.local文件中追加即可，例如 systemctl start sshd.serviceTips：在CentOS8版本改文件需要手动增加执行权限，使用命令chmod +x /etc/rc.d/rc.local systemd执行multi-user.target下的getty.target及登录服务 systemd执行graphical需要的服务 Root用户破解流程 开机后页面 按e进入LINUX内核编辑模式 在quiet后加入 rd.break 按ctrl+x进入swtch_root模式 使用命令 mount -o remount,rw /sysroot 重新挂载根分区 使用命令 chroot /sysroot 切换根分区 使用命令 passwd root 修改root的密码，必须是8位以上复杂密码 当前设置的是 xUGZ1030 使用命令 touch /.autorelabel 让selinux在重启后更新label 不执行该句新设置密码不会保存 等到进度条加载完成后可退出 验证新密码是否有效 使用命令 exit 退出 使用命令 reboot 重启系统 最后用root和新密码登录即可 防火墙Selinux防火墙: 文件级防火墙 使用命令 sestatus 查看selinux防火墙状态 关闭防火墙使用命令 vi /etc/selinux/config 进入selinux配置文件 将SELINUX状态改成关闭 使用命令 SELINUX=disabled 使用命令 init 6 重启 firewalld防火墙: 网络级防火墙 使用命令 systemctl status firewalld 查看 firewalld防火墙状态 使用命令 systemctl stop firewalld 关闭 该命令只能暂时关闭 开机关闭需要另设 使用命令 systemctl disable firewalld 设置开机关闭 iptables防火墙: 网络级防火墙 常用 使用命令 iptables -L -n 查看规则 使用命令 iptables -F 清空规则 使用命令 service iptables save 保存规则 （如果不能保存 查询是否已安装iptables-service包） 主机名管理 查看主机名(localhost)hostname 查看主机名与系统详情hostnamectl status 临时修改hostname yzmedu 永久修改 1) 直接修改文件 vi /etc/hostname 2) hostnamectl方法 hostnamectl set-hostname 3) 重启生效 init 6 网络管理直接修改文件vi /etc/sysconfig/network-scripts/ifcfg-ens32 1234567BOOTPROTO=dhcp | staticONBOOT=yes | noIPADDR=192.168.239.200NETMASK=255.255.255.0GATEWAY=192.168.239.2DNS1=114.114.114.114DNS2=8.8.8.8 修改完成成功重启systemctl restart network即可。参考博客Tips: 使用ifconfig查看IP地址，使用route -n查看路由网关，使用cat /etc/resolv.conf查看DNS，使用cat /etc/sysconfig/network-scripts/ifcfg-ens32查看配置文件。 使用nmcli配置使用nmcli命令要确保系统中已经安装NetworkManager，默认是自动启动的。使用systemctl status NetworkManager检查确认。CentOS8中network已经淘汰掉了，不建议使用。 查看网络设备状态nmcli device status 查看ens32网卡的相关信息nmcli device show ens32 设置静态ip地址nmcli connection modify ens32 ipv4.addresses '192.168.1.100' 设置DNSnmcli connection modify ens32 ipv4.dns '114.114.114.114' 设置网关nmcli connection modify ens32 ipv4.gateway '192.168.1.1' 设置IP地址为手动指定nmcli connection modify ens32 ipv4.method manual 设置IP地址为dhcp自动获取nmcli connection modify ens32 ipv4.method auto 设置开机自动连接nmcli connection modify ens32 connection.autoconnect yes 重新加载ifcfg-ens32配置文件nmcli connection reload 不重启系统让网卡生效的方法123nmcli connection up ens32nmcli device connect ens32nmcli device reapply ens32 系统目录结构 123456789101112131415161718/bin 存放二进制可执行文件(ls,cat,mkdir等)，存放系统命令/boot 核心系统启动文件，存放用于系统引导时使用的各种文件/dev 存放硬件设备，使用里面设备需要挂载,糖炒栗子：mount /dev/cdrom /media//etc 存放系统程序管理和配置文件/home 存放除了root用户之外的所有用户文件的根目录，比如用户user的主目录就是/home/user，可以用~user表示/lib 存放跟文件系统中的程序运行所需要的共享库及内核模块。共享库又叫动态链接共享库，作用类似windows里的.dll文件，存放了根文件系统程序运行所需的共享文件。/media 空目录，不可删，用于挂在光盘使用/mnt 空测试目录，系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统/opt 空测试目录，额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把tomcat等都安装到这里。/proc 虚拟文件系统目录，是系统内存的映射。存放cpu、内存和硬盘等设备信息，可直接访问这个目录来获取系统信息。/root 超级用户（root）的主目录/run 程序进程PID /sbin 存放二进制可执行文件，只有root才能访问。这里存放的是系统管理员使用的系统级别的管理命令和程序。如ifconfig等/srv 自己的程序或源代码的放置目录/sys 内核信息文件/tmp 用于存放各种临时文件，是公用的临时文件存储点/usr 非系统程序用于存放系统应用程序，比较重要的目录/usr/local 本地系统管理员软件安装目录（安装系统级的应用）。这是最庞大的目录，要用到的应用程序和文件几乎都在这个目录。/var 用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统或程序日志等） 基础命令 历史命令查看用 history， 使用history -c清除历史命令 强制中断正在执行的操作 ctrl+c 清空当前屏幕 clear或ctrl+l 记录最近两次使用的目录 cd - 文件管理 新建修改和删除创建文件 touch file1批量创建文件 touch file{1..9}编辑文件 vi file2修改文件名 mv file1 file2删除文件 rm -rf file 查看文件内容全文查看文件内容 cat file4分页查看文件内容 more file4跟踪文件数据 tail -f file1查看文件前十行数据head file1 or head -10 file1查看文件后十行数据 tail flle1 or tail -10 file1 复制和文件复制文件cp file1 file2移动文件mv file1 file2 查找文件查找文件名为file1的文件 find / -name file1快速查找文件名为file1的文件 updatedb;locate file1查找file1文件中linux字符 cat file1 | grep linux or grep 'linux' file1查找file1文件中linux字符 忽略大小写 grep -i 'linux' file1 Vi编辑器Vi是Unix及Linux系统下标准的编辑器，由美国加州大学伯克利分校开发。学会它后，你将在Linux的世界里畅行无阻。基本上vi可以分为三种状态，分别是命令模式、插入模式，和底行模式。 Vi编辑器的模式 命令模式 command 输入模式 insert 末行模式 :末行命令 视图模式 visual 常用模式切换 命令模式 =&gt; 输入模式输入模式 =&gt; 命令模式 按下esc命令模式 =&gt; 末行模式 使用 shift+:输入x保存退出末行模式 =&gt; 命令模式 按下esc命令模式 =&gt; 视图模式 使用v 按v键再按上下左右进行视图选中，进行快速缩进 命令模式常用命令 上k下j左h右l撤销用u恢复用ctrl+r(撤销多了恢复，两个配合使用) 复制当前行 yy 复制多行 nyy, 比如3yy为复制三行 粘贴到下一行 p, 粘贴到下一行n次 np. 粘贴到上一行 P, 粘贴到上一行n次 nP 单字符替换用r , 按过r后直接输入需要替换的字符即可 查找用 /, 查找下一个结果用 n 到最后一行首用G, 到指定行首用nG , 比如3G为到第三行行首 从当前行删除到最后一行 dG(当前行也会删除哦), 从当前行删除到第n行 dnG 删除一个单词用 dwn 删除并剪切一行用dd 从当前字符删除到行首用 d^ , 从当前字符删除到行末用 d$ 删除单个字符使用x, 删除指定个数的字符用 nx, 比如3x为删除当前光标所在位置的后三个字符 按v键再按上下左右进行视图选中，进行快速缩进 输入模式常用命令 使用i在光标当前所在字符的前面输入 使用a在光标当前所在字符的后面输入 使用I在光标所在当前行的前面开始输入 使用A在光标所在当前行的后面开始输入 使用s删除光标所在的当前字符并输入 使用o在当前字符所在行下方另起一行输入 使用S删除光标所在当前行并输入 使用O在当前字符所在行上方另起一行输入 末行模式常用模式 不保存退出 q 强制不保存退出 q! 保存退出 wq 保存不退出 w 把一篇文章中的所有hello全部替换成world(%第一行到最后的意思) :%s/hello/world/g 把第1行到第10行的hello替换成world :1,10s/hello/world/g 把每行中首个hello换成world :%s/hello/world/ 目录管理创建目录 mkdir dir1递归创建多级目录 mkdir -p dir1/dir2/dir3删除目录 rm -rf dir1修改目录名称 mv dir1 dir2复制多级结构目录cp -r div1 div2查看目录 tree dir1 用户和组用户管理查看用户 id root创建用户 useradd user1设置密码 passwd user1回车后会有提示键入密码， shell中设置密码 echo \"123\" | passwd --stdin user1与用户有关的文件 1234/etc/passwd 用户信息/etc/group 用户组信息/etc/shadow 用户密码/home/user1 用户家目录 删除用户 userdel -r user1 组管理把user1加入root组 gpasswd -a user1 root把user1从root组删除 gpasswd -d user1 root GZ、Bz2和Zip压缩包Gz压缩包管理制作gz压缩包 tar czf mydir1.tar.gz mydir1解压gz压缩包 tar xzf mydir1.tar.gz查看gz压缩包 tar tf mydir1.tar.gz Bz2压缩包管理制作bz2压缩包 tar cjf mydir1.tar.bz2 mydir1解压bz2压缩包 tar xjf mydir1.tar.bz2查看bz2压缩包 tar tf mydir1.tar.bz2 Zip压缩包管理制作zip压缩包 zip -r mydir1.zip mydir1zip压缩包解压 unzip mydir1.zip查看zip压缩包 unzip -l mydir1.zip 光盘管理在linux系统中，可以使用mount命令挂载光盘镜像文件、移动硬盘、U盘以及Windows网络共享和UNIX NFS网络共享。挂载光盘 mount /dev/cdrom /media/查看挂载情况 df df -h df -Th卸载光盘 umount /media开机挂载 vi /etc/fstab后追加/dev/cdrom /media iso9660 defaults 0 0开机挂载测试 mount -a成功后重启即可 RPM包管理RPM：redhat package management英文缩写，只适用于Redhat和Centos系统。 安装RPM包 rpm -ivh psmisc-23.1-3.el8.x86_64查看RPM包 rpm -qa or rpm -qa | grep psmisc-23.1 or 使用rpm -qa | wc -l查看安装个数查看RPM包安装的文件 rpm -ql psmisc-23.1 or rpm -ql psmisc-23.1 | grep pstree反查文件是否是由RPM包安装的 rpm -qf /usr/bin/pstree删除RPM安装程序 rpm -e psmisc-23.1 yum命令yum（ Yellow dog Updater, Modified）是一个在Fedora和RedHat以及SUSE中的Shell前端软件包管理器。YUM仓库的前提是做准备光盘 检查光盘是否正常挂载 使用命令 dfmount /dev/cdrom /media 使用该命令挂载光盘下面为配置yum流程 1234cd /etc/yum.repos.d/mv CentOS-Media.repo /mntrm -rf *mv /mnt/CentOS-Media.repo ./ vi CentOS-Media.repo 进行配置文件编辑 下面对应配置需要对照 123456789[c8-media-BaseOS]baseurl=file:///media/BaseOSgpgcheck=0enabled=1[c8-media-AppStream]baseurl=file:///media/AppStreamgpgcheck=0enabled=1 查看yum可控制的软件包yum list | wc -l 或者 yum list | grep iptables yum安装rpm软件包 yum -y install iptables-service 1234567891011yum check-update // 列出所有可更新的软件清单yum update // 更新所有软件yum install &lt;package_name&gt; // 仅安装指定的软件yum update &lt;package_name&gt; // 仅更新指定的软件yum list // 列出所有可安裝的软件清单yum remove &lt;package_name&gt; // 删除软件包yum search &lt;keyword&gt; // 查找软件包yum clean packages // 清除缓存目录下的软件包yum clean headers // 清除缓存目录下的 headersyum clean oldheaders // 清除缓存目录下旧的 headers 权限管理查看文件权限 ls -l fileName or ll查看单个目录本身的权限 ll -d dirName权限类型 r 读(4) w 写(2) x 执行(1) - 无权限(0)权限详情 123456789101112三段式drwxr-xr-x 2 root root 6 Oct 16 19:14 dir1.目录2.root对dir的权限:rwx:读+写+执行3.rootGroup对dir的权限:rx:读+执行4.other用户对dir的权限:rx:读+执行-rw-r--r-- 1 root root 0 Oct 16 19:14 file1.文件2.root对file的权限:rw:读+写3.root组对file的权限:r:读4.other对file的权限:r:读 umask权限掩码默认权限: 文件:666，目录777文件: 644(默认权限:666-权限掩码:022)目录: 755(默认权限:777-权限掩码:022) Chomd命令数字式 chmod 755 /mnt英文参数式 chmod a+x file 等价于 chmod u+x,g+x,o+x linux.sh # a=u+g+o ACL命令查看权限 getfacl test.sh设置权限 setfacl -m u:user1:rwx test.sh设置acl的默认权限 setfacl -m d:u:user1:rwx test.sh or setfacl -m default:u:user1:rwx test.sh删除/test上的所有acl权限 setfacl -b test.sh删除user1在/test上的权限 setfacl -x u:user1 test.sh Sudo命令使用 root 用户修改文件/etc/sudoers添加可写权限后编辑，在root ALL=(ALL) ALL下一行加入以下内容：你的账号ALL=(ALL)ALL 保存退出。分配用户对命令的权限 12visudoxugz localhost=/usr/sbin/useradd // 完成后，指定用户 xugz 就可添加用户 Shell命令技巧使用 tab 快速补全调出历史命令中第1001号命令 !1001调出最后一次执行的以s开头的命令!s管道 | 帮助技巧ls --helpsystemctl -hman ls shell编程概述别名管理查看别名 alias新建别名 alias myif='nmcli device show ens32'删除别名 unalias myif 日期管理-datedate '+%Y-%m-%d %H:%M:%S'Y 年 m 月 d 日 H 时 M 分 S 秒 Bash重定向正确输出 &gt;正确追加输出 &gt;&gt;错误输出 2&gt;错误追加输出 2&gt;&gt;正确和错误输出 &amp;&gt;正确和错误追加输出 &amp;&gt;&gt;正确或错误立即销毁 &amp;&gt;/dev/null Shell编程-基础操作变量定义 name='user1'输出变量 echo $name or echo \"my name is ${name}\" Shell编程-文件测试-d：测试是否为目录（Directory）-e：测试目录或文件是否存在（Exist）-f：测试是否为文件（File）-L：测试是否为符号连接（Link）文件 Shell编程-字符串测试=： 字符串内容相同!=：字符串内容不同-z: 字符串为空 Shell编程-数学测试-eq：等于（Equal）-ne：不等于（Not Equal）-gt：大于（Greater Than）-lt：小于（Lesser Than）-ge：大于或等于（Greater or Equal）-le：小于或等于（Lesser or Equal） Shell编程-逻辑测试&amp;&amp;：逻辑与||：逻辑或!： 逻辑否 Shell编程-用户交互read -p ‘please input your name: ‘ nameecho $name Shell编程实例光盘挂载 12345678#!/bin/bashif [ ! -e /media/BaseOS ]then mount /dev/cdrom /media &amp;&gt; /dev/null echo 'cdrom is ok'else echo 'cdrom is ok'fi 创建用户 12345678910111213141516#!/bin/bashread -p 'please input your name:' nameif [ ! -z $name ]then read -p 'please input your pass:' pass if [ ! -z $pass ] then useradd $name echo $pass | passwd --stdin $name &amp;&gt; /dev/null echo \"your name is ${name}，your pass is ${pass}，create is ok\" else echo 'pass is empty' fielse echo 'name is empty'fi 内存判断 123456789#!/bin/bashmem=`free -m |grep 'Mem'|awk '{print $4}'` # 执行`里的代码if [ $mem -lt 400 ]then echo \"mem is no,now is ${mem}\"else echo \"mem is yes,now is ${mem}\"fi 循环输出 123456#!/bin/bashfor name in `cat /etc/passwd | awk -F: '{print $1}'`do echo $name sleep 1done crontab任务计划cron是一个可以用来根据时间、日期、月份和星期的组合来调度对周期性任务执行的守护进程，利用cron所提供的功能，可以将需要周期性重复执行的任务设置为cron任务，并且设置为在主机较空闲的时间自动完成。 查看Crontab服务状态 systemctl status crond任务计划格式 (分) *(时) *(日) *(月) *(周) 周期执行的程序查看cron任务计划 crontab -l编辑cron任务计划 crontab -e删除所有cron任务计划 crontab -r 每年1月2日晚上22:30执行time.sh脚本 30 22 2 1 * time.sh每周六晚上22:30执行time.sh脚本 30 22 * * 6 time.sh每周的周一、周三和周五晚上22:30执行time.sh脚本 30 22 * * 1,3,5 time.sh每周的周一到周五晚上22:30执行time.sh脚本 30 22 * * 1-5 time.sh每分钟执行一次time.sh脚本 * * * * * time.sh每五分钟执行一次time.sh脚本 */5 * * * * time.sh每天晚上00点执行time.sh脚本 00 00 * * * time.sh 该命令详见 点我，我是链接地址 top命令top命令用于实时显示 process 的动态 123456top // 显示进程信息top -c // 显示完整命令top -b // 以批处理模式显示程序信息top -s // 以累积模式显示程序信息top -p &lt;pid&gt; // 显示指定的进程信息top -n 10 // 显示更新十次后退出 Cockpit Web系统监控初始化 systemctl enable --now cockpit.socket开启cockpit服务 systemctl start cockpit.service查看cockpit状态 systemctl status cockpit.service 自定义服务脚本流程需求：自定义startMyApp脚本，使用systemd服务管理放入开机自启动。用于练手systemcrl命令 创建文件 vi /mnt/startMyApp.sh # 路径可自指定 12345678#!/bin/shi=0while truedo echo $i&gt;&gt;/mnt/MyApp.txt ((i++)) sleep 1done 给脚本设置执行权限chmod a+x startMyApp.sh 自定义myapp服务脚本vi /etc/systemd/system/myapp.service1234567891011[Unit] # 服务单元Description=myapp service [Service]Type=simpleWorkingDirectory=/mnt # 工作目录ExecStart=/mnt/startMyApp.shExecStop=/bin/kill -s TERM $MAINPID [Install]WantedBy=multi-user.target # 设置开机启动放到哪个运行级别 重载所有修改过的配置文件,扫描新的或有变动的单元systemctl daemon-reload 把myapp服务加入开机启动systemctl enable myapp.service 启动myapp服务后程序执行systemctl start myapp.service 关闭myapp服务systemctl stop myapp.service Tips: 查看myapp服务状态使用systemctl status myapp.service document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Linux","slug":"Linux","permalink":"https://xlline.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://xlline.github.io/tags/Linux/"}]},{"title":"TP框架-上传apk包文件","slug":"Upload_apk","date":"2019-06-22T09:28:08.000Z","updated":"2022-06-22T09:29:43.366Z","comments":true,"path":"2019/06/22/Upload_apk/","link":"","permalink":"https://xlline.github.io/2019/06/22/Upload_apk/","excerpt":"TP中的写法，增加了根据文件mime类型二次校验上传文件的类型。","text":"TP中的写法，增加了根据文件mime类型二次校验上传文件的类型。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * @ApiTitle (上传apk文件) * @ApiSummary (在线升级) * @ApiMethod (POST) * @ApiParams (name=\"apk\", type=\"file\", required=true, description=\"apk包\") * * @ApiReturnParams (name=\"version_code\", type=\"string\", required=false, description=\"版本号\") * @ApiReturnParams (name=\"device_type\", type=\"string\", required=false, description=\"设备类型\") * @ApiReturnParams (name=\"device_model\", type=\"string\", required=false, description=\"设备型号\") * @ApiReturnParams (name=\"url\", type=\"string\", required=false, description=\"路径地址\") */public function upload_apk(){ $file_name = key($_FILES); $file = request()-&gt;file($file_name); if (!$file) { return $this-&gt;error(\"文件上传失败\"); } if (!$file-&gt;checkExt('apk')) { return $this-&gt;error(\"不允许上传此类型文件！\"); } $path = ROOT_PATH . 'public' . DS . 'upload' . DS . 'apk'; $name = iconv('utf-8', 'gbk', $file-&gt;getInfo()['name']); // 包名格式： 设备型号_版本号.apk list($device_model, $version_code) = explode('_', $name); if (empty($device_model) || empty($version_code)) { return $this-&gt;error(\"文件上传失败，版本号解析异常！\"); } $service = new LibraryUpgrade(); $device_version = $service-&gt;get_newest_version($device_model); $info = $file-&gt;move($path, $name); if (!$info) { return $this-&gt;error(\"上传失败\"); } $tmp_path = DS . 'upload' . DS . 'apk' . DS . $name; $save_path = str_replace(DS, \"/\", $tmp_path); // 根据文件的mime类型二次校验 $finfo = finfo_open(FILEINFO_MIME_TYPE); $mime = finfo_file($finfo, '.'.$save_path); finfo_close($finfo); if ($mime != 'application/java-archive') { unlink($path . \"/\" . $name); return $this-&gt;error(\"上传失败，文件类型异常！\"); } $return = [ 'url' =&gt; $save_path, 'version_code' =&gt; substr($version_code, 0, -4), 'device_type' =&gt; $device_version['device_type'] ?? '', 'device_model' =&gt; $device_model ]; return $this-&gt;success(\"成功\", $return);} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"PHP","slug":"PHP","permalink":"https://xlline.github.io/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://xlline.github.io/tags/PHP/"},{"name":"ThinkPHP","slug":"ThinkPHP","permalink":"https://xlline.github.io/tags/ThinkPHP/"}]},{"title":"TP框架-批量文件","slug":"Upload_file","date":"2019-06-21T04:31:18.000Z","updated":"2022-10-11T08:05:28.824Z","comments":true,"path":"2019/06/21/Upload_file/","link":"","permalink":"https://xlline.github.io/2019/06/21/Upload_file/","excerpt":"TP框架，批量上传文件简单demo","text":"TP框架，批量上传文件简单demo controller1234567891011121314151617181920212223242526272829namespace app\\fire\\controller;use app\\fire\\library\\Upload as LibraryUpload;/** * @ApiSector (上传类) */class Upload extends Api{ /** * @ApiTitle (批量上传文件) * @ApiSummary () * @ApiMethod (POST) * @ApiParams (name=\"files\", type=\"file\", required=true, description=\"文件\") * @ApiReturnParams (name=\"data\", type=\"array\", required=false, description=\"列表\") * @ApiReturnParams (name=\"|- file_name\", type=\"string\", required=false, description=\"存储路径\") * @ApiReturnParams (name=\"|- save_path\", type=\"string\", required=false, description=\"文件名\") */ public function file() { $files = request()-&gt;file('files'); if (!$files) { return $this-&gt;error(\"文件上传失败\"); } $service = new LibraryUpload(); $return = $service-&gt;multiple_upload($files); return $this-&gt;success(\"成功\", $return); }} lib类123456789101112131415161718192021222324252627282930313233343536373839404142434445namespace app\\fire\\library;use think\\File;/** * 文件上传类 */class Upload{ /** * 批量上传文件 * @param array $files * @return void */ public function multiple_upload($files) { $path = ROOT_PATH . 'public' . DS . 'upload' . DS . 'files'; $retrun = []; $flag = true; foreach ($files as $file) { if ($file) { $name = $file-&gt;getInfo()['name']; $upload = $file-&gt;move($path); if ($upload) { $tmp_path = DS . 'upload' . DS . 'files' . DS . $name; $save_path = str_replace(DS, \"/\", $tmp_path); $retrun[] = [ 'file_name' =&gt; $name, 'save_path' =&gt; $save_path ]; } else { $flag = false; } } else { $flag = false; } if (!$flag) { continue; } } return $retrun; }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"PHP","slug":"PHP","permalink":"https://xlline.github.io/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://xlline.github.io/tags/PHP/"},{"name":"ThinkPHP","slug":"ThinkPHP","permalink":"https://xlline.github.io/tags/ThinkPHP/"}]},{"title":"使用Hexo+GitHub搭建个人博客教程","slug":"Hexo+GitHub","date":"2019-06-19T07:29:14.000Z","updated":"2021-09-11T08:41:31.716Z","comments":true,"path":"2019/06/19/Hexo+GitHub/","link":"","permalink":"https://xlline.github.io/2019/06/19/Hexo+GitHub/","excerpt":"开始搭建自己的小站吧。简单记录，方便后续翻阅。从无到有的流程还是比较详细的，按步骤从头到尾跟着执行可以避免大部分问题。本次搭站 参考文章 人家写的已经很详细了，这里进行备份基础补充和常见问题的汇总。","text":"开始搭建自己的小站吧。简单记录，方便后续翻阅。从无到有的流程还是比较详细的，按步骤从头到尾跟着执行可以避免大部分问题。本次搭站 参考文章 人家写的已经很详细了，这里进行备份基础补充和常见问题的汇总。 准备工作Hexo 基于 Node.js，搭建过程中还需要使用 npm（Node.js 已带） 和 git，因此先搭建本地操作环境，安装 Node.js 和 Git。Node.js下载地址Git下载地址下载 Node.js 和 Git 程序并安装，一路点 “下一步” 按默认配置完成安装。安装完成后，Win+R 输入 cmd 并打开，依次输入 node -v、npm -v 和 git –version 并回车，出现程序版本号即可。 连接 Github使用邮箱注册 GitHub 账户，选择免费账户，并完成邮件验证。右键 -&gt; Git Bash Here，设置用户名和邮箱： 12git config --global user.name \"GitHub 用户名\"git config --global user.email \"GitHub 邮箱\" 创建SSH密钥：输入 ssh-keygen -t rsa -C \"GitHub 邮箱\"，然后一路回车。 添加密匙：进入 [C:\\Users\\用户名.ssh] 目录（要勾选显示“隐藏的项目”），用记事本打开公钥 id_rsa.pub 文件并复制里面的内容。登陆 GitHub ，进入 Settings 页面，选择左边栏的 SSH and GPG keys，点击 New SSH key。Title 随便取个名字，粘贴复制的 id_rsa.pub 内容到 Key 中，点击 Add SSH key 完成添加。 验证连接： 打开 Git Bash，输入 ssh -T git@github.com 出现 “Are you sure……”，输入yes 回车确认。显示 “Hi xxx! You’ve successfully……” 即连接成功。 创建 Github Pages 仓库GitHub 主页右上角加号 -&gt; New repository： Repository name 中输入 用户名.github.io 勾选 “Initialize this repository with a README” Description 选填 填好后点击 Create repository 创建。创建后默认自动启用 HTTPS，博客地址为：https://用户名.github.ioTips：最好这里的用户名和仓库名称一样哦，会避免很多麻烦。 本地安装 Hexo 博客程序使用 npm 一键安装 Hexo 博客程序： 1npm install -g hexo-cli Mac 用户需要管理员权限（sudo），运行这条命令： 1sudo npm install -g hexo-cli 等待安装，出现hexo版本号即为安装成功，安装成功后初始化并安装所需组件： 12hexo init # 初始化npm install # 安装组件 完成后依次输入下面命令，启动本地服务器进行预览： 12hexo g # 生成页面hexo s # 启动预览 访问 http://localhost:4000，出现 Hexo 默认页面，本地博客安装成功！ Tips：如果出现页面加载不出来，可能是端口被占用了。Ctrl+C 关闭服务器，运行 hexo server -p 5000 更改端口号后重试。 Hexo 博客文件夹目录结构如下： 1234567├── _config.yml ## 用于存放网站的配置信息，你可以在此配置大部分的参数├── package.json├── scaffolds ## 存放模板的文件夹，当新建文章时，Hexo会根据scaffold来建立文件├── source ## source是资源文件夹，用于存放用户资源| ├── _drafts| └── _posts└── themes ## themes是主题文件夹，存放博客主题，Hexo 会根据主题来生成静态页面 部署 Hexo 到 GitHub Pages本地博客测试成功后，就是上传到 GitHub 进行部署，使其能够在网络上访问。首先安装 hexo-deployer-git： 1npm install hexo-deployer-git --save 然后修改 _config.yml 文件末尾的 Deployment 部分，修改成如下： 1234deploy: type: git repository: git@github.com:用户名/用户名.github.io.git branch: master 完成后运行 hexo d 将网站上传部署到 GitHub Pages。 完成！这时访问我们的 GitHub 域名 https://用户名.github.io 就可以看到 Hexo 网站了。 绑定域名（可选）博客搭建完成使用的是 GitHub 的子域名（用户名.http://github.io），我们可以为 Hexo 博客绑定自己的域名替换 GitHub 域名，更加个性化和专业，也利于 SEO。 域名注册和解析教程：Namesilo 域名购买及使用教程按上面教程注册并解析域名，在 DNS 设置部分，删除自带的记录，然后添加 CNAME 记录将 www 域名解析指向 用户名.github.io。 绑定域名到 Hexo 博客进入本地博客文件夹的 source 目录，打开记事本，里面输入自己的域名，如http://www.example.com，保存名称为 “CNAME”，格式为 “所有文件”（无 .txt 后缀）。 清除缓存等文件并重新发布网站： 123hexo clean # 清除缓存文件等hexo g # 生成页面hexo s # 启动预览 现在就可以使用自己的域名访问 Hexo 博客了。 开启 HTTPS配置自己的域名后，需要我们手动开启 HTTPS。打开博客所在 GitHub 仓库，Settings -&gt; 下拉找到 GitHub Pages -&gt; 勾选 Enforce HTTPS。HTTPS 证书部署成功需要一定时间，等大概几分钟再访问域名，就可以看到域名前面的小绿锁了，HTTPS 配置完成！ 常用命令进入博客所在目录，右键打开 Git Bash Here 12345678hexo new \"name\" # 新建文章hexo new page \"name\" # 新建页面hexo g # 生成页面hexo d # 部署hexo g -d # 生成页面并部署hexo s # 本地预览hexo clean # 清除缓存和已生成的静态文件hexo help # 帮助 也可以不使用命令自己创建 .md 文件，只需在文件开头手动加入如下格式 Front-matter 即可，写完后运行 hexo g 和 hexo d 发布。 1234567891011---title: Hello World # 标题date: 2000/01/01 hh:mm:ss # 时间categories: # 分类- Diarytags: # 标签- PS3- Games---这里需要补充文章的正文，加油哦 常见问题 更换主题在 Themes | Hexo 选择一个喜欢的主题，比如 NexT，进入网站目录打开 Git Bash Here 下载主题： 1git clone https://github.com/iissnan/hexo-theme-next themes/next 然后修改 _config.yml 中的 theme 为新主题名称 next，发布。（有的主题需要将 _config.yml 替换为主题自带的，参考主题说明。） Hexo 设置显示文章摘要，首页不显示全文Hexo 主页文章列表默认会显示文章全文，浏览时很不方便，可以在文章中插入 &lt;!--more--&gt; 进行分段。该代码前面的内容会作为摘要显示，而后面的内容会替换为 “Read More” 隐藏起来。 设置网站图标进入 themes/主题 文件夹，打开 _config.yml 配置文件，找到 favicon 修改，一般格式为：favicon: 图标地址。（不同主题可能略有差别） 修改并部署后没有效果使用 hexo clean 清理后重新部署。 开启 HTTPS 后访问网站显示连接不安全证书还未部署生效，等待一会儿，清除浏览器缓存再试。 Mac 安装 Hexo 报错无法安装Mac 用户需要管理员权限运行，使用 sudo npm install -g hexo-cli 命令安装。 npm 下载速度慢，甚至完全没反应使用 npm 安装程序等待很久也没反应，或者下载速度很慢，可以更换 npm 源为国内 npm 镜像。临时更换方法：在 npm 安装命令后面加上：--registry https://registry.npm.taobao.org 站点首页不显示文章全文打开主题配置文件 _config.yml 文件，找到如下 12345 # Automatically Excerpt. Not recommend.# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt: enable: false length: 150 把这里的false改为true就可以了在首页启动显示文章预览了，length是显示预览的长度。 我们也可以通过在文章使用&lt;!-- more --&gt;标志来精确控制文章的摘要预览，比如这篇文章就是在这个段落的末尾添加了该标志，所以本文在首页的预览就会显示到这个段落为止。 本篇就这样吧，拜拜喽。✨✨ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://xlline.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://xlline.github.io/tags/Hexo/"}]},{"title":"Hexo添加emoji表情","slug":"Hexo-addemjo","date":"2019-06-19T07:29:14.000Z","updated":"2021-09-11T08:40:48.534Z","comments":true,"path":"2019/06/19/Hexo-addemjo/","link":"","permalink":"https://xlline.github.io/2019/06/19/Hexo-addemjo/","excerpt":"废话不多说，直接动手干吧。 具体表情参考 GFM 表情列表 😜","text":"废话不多说，直接动手干吧。 具体表情参考 GFM 表情列表 😜 安装123npm install hexo-filter-github-emojis --savenpm un hexo-renderer-stylus --savenpm i hexo-renderer-stylus-plus --save 打开 站点配置文件，添加以下内容123456githubEmojis: enable: true className: github-emoji unicode: false styles: localEmojis: 解决渲染错误问题 修改 themes/next/layout/_partials/head.swig, 解决渲染错误问题，渲染 emoji 表情时会被自动加上 a 标签123456789101112131415161718192021222324252627&lt;script type=\"text/javascript\" id=\"hexo.configurations\"&gt; var NexT = window.NexT || {}; var CONFIG = { root: '{{ theme.root }}', scheme: '{{ theme.scheme }}', sidebar: {{ theme.sidebar | json_encode }}, fancybox: {{ theme.fancybox }}, tabs: {{ theme.tabs.enable }}, motion: {{ theme.use_motion }}, duoshuo: { userId: '{{ theme.duoshuo_info.user_id | default() }}', author: '{{ theme.duoshuo_info.admin_nickname | default(__('author'))}}' }, algolia: { applicationID: '{{ theme.algolia.applicationID }}', apiKey: '{{ theme.algolia.apiKey }}', indexName: '{{ theme.algolia.indexName }}', hits: {{ theme.algolia_search.hits | json_encode }}, labels: {{ theme.algolia_search.labels | json_encode }} }, *{# ↓ 在这里修改，其他未动 ↓ #} {# 添加 emojis 参数 #} emojis: { className: '{{ config.githubEmojis.className | default('github-emoji') }}' }* };&lt;/script&gt; 修改 themes/next/source/js/src/utils.js123456// 注意看 CONFIG.emojis.className 那一行，其他未动$('.content img') .not('[hidden]') .not('.group-picture img, .post-gallery img, *img.' + CONFIG.emojis.className*) .each(function () { …… 自定义emoji 样式在 站点配置文件 中，我们配置： 123456githubEmojis: enable: true className: github-emoji unicode: false styles: localEmojis: 在 themes/next/source/css/_variables/base.styl 中使用 hexo-site-config 方法获取 站点配置文件 中的值，我们添加 12345678// Github emojis class name// --------------------------------------------------get_emoji_class() { emoji_class = hexo-site-config('githubEmojis.className') return emoji_class ? emoji_class : 'github-emoji'}$github-emojis-class-name = get_emoji_class() 最后在自定义样式文件 themes/next/source/css/_custom/custom.styl 中添加： 1234567img.{$github-emojis-class-name} { display: inline; height: 1.7em; width: 1.7em; vertical-align: -0.4em; border: none !important;} 到这里就可以啦。🍀 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://xlline.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://xlline.github.io/tags/Hexo/"}]},{"title":"Hexo NexT主题添加字数统计阅读时长","slug":"Hexo-addwordcount","date":"2019-06-19T07:29:14.000Z","updated":"2021-09-11T08:42:06.545Z","comments":true,"path":"2019/06/19/Hexo-addwordcount/","link":"","permalink":"https://xlline.github.io/2019/06/19/Hexo-addwordcount/","excerpt":"配置NexT 主题默认已经集成了文章【字数统计】、【阅读时长】统计功能，如果我们需要使用，只需要在主题配置文件 _config.yml 中打开 wordcount 统计功能即可。","text":"配置NexT 主题默认已经集成了文章【字数统计】、【阅读时长】统计功能，如果我们需要使用，只需要在主题配置文件 _config.yml 中打开 wordcount 统计功能即可。如下所示： 12345678# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true wordcount: true # 单篇 字数统计 min2read: true # 单篇 阅读时长 totalcount: false # 网站 字数统计 separated_meta: true 安装插件123npm i --save hexo-wordcount# Node 版本7.6.0之前,请安装 2.x 版本 (Node.js v7.6.0 and previous)npm install hexo-wordcount@2 --save post 添加如果还是不行，建议简单强暴添加，方法如下打开hexo\\themes\\hexo-theme-next\\layout\\_macro\\post.swig 文件，在文件类搜索关键词busuanzi，找到这段代码后 12345678910{% if not is_index and theme.busuanzi_count.enable and theme.busuanzi_count.post_views %} &lt;span class=\"post-meta-divider\"&gt;|&lt;/span&gt; &lt;span class=\"post-meta-item-icon\" {% if not theme.post_meta.item_text %} title=\"{{ __('post.views') }}\" {% endif %}&gt; &lt;i class=\"fa fa-{{ theme.busuanzi_count.post_views_icon }}\"&gt;&lt;/i&gt; {% if theme.post_meta.item_text %} {{__('post.views') + __('symbol.colon') }} {% endif %} &lt;span class=\"busuanzi-value\" id=\"busuanzi_value_page_pv\" &gt;&lt;/span&gt; &lt;/span&gt; {% endif %} 在endif上面，即本文代码块那个空行处添加以下代码 12&lt;span class=\"post-meta-divider\"&gt;|&lt;/span&gt;&lt;span title=\"{{ __('post.wordcount') }}\"&gt;&lt;span class=\"post-meta-item-icon\"&gt;&lt;i class=\"fa fa-file-word-o\"&gt;&lt;/i&gt;&lt;/span&gt;字数： {{ wordcount(post.content) }}&lt;/span&gt; 全站添加打开hexo\\themes\\hexo-theme-next\\layout\\_partials\\footer.swig 文件，新增如下代码 1234&lt;div class=\"theme-info\"&gt; &lt;div class=\"powered-by\"&gt;&lt;/div&gt; &lt;span class=\"post-count\"&gt;全站共 {{ totalcount(site) }} 字&lt;/span&gt;&lt;/div&gt; 到这里就可以啦，快去试试吧。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://xlline.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://xlline.github.io/tags/Hexo/"}]},{"title":"修改Hexo博客NexT主题文章页面宽度","slug":"Hexo-postwidth","date":"2019-06-19T07:29:14.000Z","updated":"2021-09-11T08:41:06.399Z","comments":true,"path":"2019/06/19/Hexo-postwidth/","link":"","permalink":"https://xlline.github.io/2019/06/19/Hexo-postwidth/","excerpt":"网上方法很多，我简单记录一种，手动修改样式，宽度自适应。","text":"网上方法很多，我简单记录一种，手动修改样式，宽度自适应。 \\themes\\next\\source/css/_schemes/Picses/_layout.styl文件末尾添加如下代码即可 // 以下为新增代码！！修改post宽度 header{ width: 80% !important; } header.post-header { width: auto !important; } .container .main-inner { width: 80%; } .content-wrap { width: calc(100% - 260px); } .header { +tablet() { width: auto !important; } +mobile() { width: auto !important; } } .container .main-inner { +tablet() { width: auto !important; } +mobile() { width: auto !important; } } .content-wrap { +tablet() { width: 100% !important; } +mobile() { width: 100% !important; } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://xlline.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://xlline.github.io/tags/Hexo/"},{"name":"NexT","slug":"NexT","permalink":"https://xlline.github.io/tags/NexT/"}]},{"title":"网络工程师基础","slug":"OSI七层模型","date":"2018-10-25T09:02:34.000Z","updated":"2021-09-11T08:41:43.661Z","comments":true,"path":"2018/10/25/OSI七层模型/","link":"","permalink":"https://xlline.github.io/2018/10/25/OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B/","excerpt":"OSIOSI（开放系统互联(Open System Interconnection)），把网络通信的工作分为7层,分别是物理层,数据链路层,网络层,传输层,会话层,表示层和应用层。","text":"OSIOSI（开放系统互联(Open System Interconnection)），把网络通信的工作分为7层,分别是物理层,数据链路层,网络层,传输层,会话层,表示层和应用层。 通俗理解如下：物理层就是布线、光纤和其它电子设备，用来把两台网络通信设备连接在一起的东西。数据链路层就是MAC地址、交换机或者网卡和驱动程序，主要任务是把数据帧转换成二进制位供一层处理。网络层最主要的设备是路由器，主要作用是为了在数据外围针对IP地址路由的交换。传输层作用是每台计算机每台应用程序与他人发生通讯，互联端口的协议。会话层，两者之间的通讯过程就是一次会话过程。表示层，规范编码问题。负责转换为适合于OSI系统内部使用的传送语法。即提供格式化的表示和转换数据服务。数据的压缩和解压缩， 加密和解密等工作。应用层用于应用程序，确定进程之间通信的性质以满足用户需要以及提供网络与用户应用软件之间的接口服务如果你的程序需要一种具体格式的数据。 物理层为数据端设备提供传送数据的通路，传输数据 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"网络通信","slug":"网络通信","permalink":"https://xlline.github.io/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"}],"tags":[{"name":"网络通信","slug":"网络通信","permalink":"https://xlline.github.io/tags/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"},{"name":"OSI","slug":"OSI","permalink":"https://xlline.github.io/tags/OSI/"}]},{"title":"轻量级标记语言Markdown的语法（GFM）","slug":"Markdown-GFM","date":"2018-10-18T07:29:14.000Z","updated":"2021-09-11T08:42:20.475Z","comments":true,"path":"2018/10/18/Markdown-GFM/","link":"","permalink":"https://xlline.github.io/2018/10/18/Markdown-GFM/","excerpt":"Hexo下使用的MarkDown是Github的GFM，整理汇总常用语法命令方便后续查找。此篇包含常用的语法，当然也一些偶尔会用到的，基本上可以满足日常使用。","text":"Hexo下使用的MarkDown是Github的GFM，整理汇总常用语法命令方便后续查找。此篇包含常用的语法，当然也一些偶尔会用到的，基本上可以满足日常使用。 常用基础字体相关斜体:用 * 或 _ 包裹，紧贴被强调文本 1*斜体文本* 我这是测试斜体哦 粗体:用 ** 或 __ 包裹，紧贴被强调文本 1**粗体文本** 我这是测试粗体哦 删除线： 用 ~~ 包裹被删除文本 1~~我这是测试删除文字哦~~ 我这是测试删除文字哦 段落文本行 : 即一行文字，markdown 中换行必须进行手动操作，自动换行将会变成一个空格段 落 : 由数行文字成一段，markdown 中由空行划分段落。输入两个以上空格再回车，进行手动换行 标题底线形式(Setext) : 标题下方插入任意数量的=(一级标题）或-（二级标题）井号形式(atx) : 标题行首插入1至6个#加上空格，构成一至六级标题 12345678910一级标题=二级标题-------# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 引用区块段落行首插入 &gt; 。插入多个 &gt; 可在区块内实现多重嵌套 12345&gt;aaabbb&gt;aaa&gt;bbb aaabbb aaabbb 列表无序列表 : 行首插入 *、+ 或 - ，加上一个空格 可生成无序列表项目，可通过制表符进行多重嵌套有序列表 : 数字. + 可生成相应编号列表项目，可通过制表符进行多重嵌套 123456789101112* 项目一* 项目二+ 项目一 + 项目二 + 项目三- 项目一- 项目二1. 项目一2. 项目二 项目一 项目二 项目一 项目二 项目三 项目一 项目二 项目一 项目二 代码块原生 md使用一个制表符（4个空格）进行缩进即可生成代码区块GFM采用围栏式代码区块，在代码上下一行使用三个反引号 ```， 并在第一行反引号后自定义代码语种，支持相应语种的代码高亮 行内代码：用 ` 包裹hello world！ 链接行内式 : [显示文本](链接 \"标签\")参考式 : [显示文本][唯一id]，然后于文章任意处起一行 : [唯一id]: 链接 \"链接标题\"自动式 : &lt;链接&gt;, 必须标明通讯协议标题锚 : [显示文本](#某个标题) 123456有问题？有[必应](https://www.bing.com \"bing.com\")！ 有问题？别[百度][1]！ 可能的话，用 &lt;https://www.google.com&gt; 好一点。 [脚注](#脚注)其实也有点像标题锚的其实, 但更像 html 中的锚 ...[1]: https://www.baidu.com 分割线在一行中使用3个及以上的 * 、- 或 _ 可生成分割线， 符号之间允许有空格但不允许有任何字符，三个以上 - 推荐用 - - - 表示，防止产生与标题相同的歧义 1234567第一段- - -第二段***第三段___第四段 图片使用 ! ，在图片链接之前添加就可以额行内式:![](图片链接 \"图片标签\")参考式:![][唯一id]，然后于文章任意处起一行 : [唯一id]: 图片链接 \"图片标签\" 拓展emoji 表情如 :smile: 为 :smile: , :kissing: 为 :kissing:。具体表情参考 GFM 表情列表 😜 如果不知道如何添加emoji表情，请 参考文章 不同的列表嵌套方法每缩进指定数量空格，嵌套一层列表，空格数量可以自行设定 12345678* 项目一* 项目二 * part a * part b * part c * chapter one * chapter two* 项目三 表格表格为横行竖列，首行为标题，第二行指定表格内容布局，第三行开始为表格数据，示例如下： 12345标题一 | 标题二 | 标题三- | :-: | -:a | 一 | 1b | 二 | 2c | 三 | 3.1 task1&lt;br/&gt;3.2 task2&lt;br/&gt;3.3 task3&lt;br/&gt; 解析：| 作为表格列的分割标志:- | :-: | -:作为表格标题与内容的分割标志，同时控制内容的布局，:- 表示左对齐，相应的后两个为居中和右对齐， - 数量不限，- 默认为左对齐 标题一 标题二 标题三 a 一 1 b 二 2 c 三 3.1 task13.2 task23.3 task3 任务列表 12- [x] Task 1- [ ] Task 2 Task 1 Task 2 本篇结束了，拜拜喽。💐 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://xlline.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://xlline.github.io/tags/Hexo/"},{"name":"Markdown","slug":"Markdown","permalink":"https://xlline.github.io/tags/Markdown/"}]}]}